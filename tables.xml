<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="tables" xml:lang="ru">
    <info>
        <title>Таблицы</title>
    </info>
    <indexterm>
        <primary>TABLE</primary>
    </indexterm>
    <para>Firebird — это реляционная СУБД. Помимо всего прочего это означает, что все данные в
        Firebird хранятся в виде таблиц. Таблица, как ее понимают с точки зрения SQL, очень похожа
        на обычную таблицу, которую можно нарисовать от руки на листе бумаги или создать в программе
        вроде Microsoft Excel. У таблиц в Firebird имеются столбцы и строки, в которых размещаются
        данные. Таблица обязательно имеет имя, уникальное в пределах одной базы данных. Таблицы
        являются основным хранилищем информации в базе данных, и поэтому необходимо ответственно
        относиться к созданию таблиц.</para>
    <para>Существуют правила, описывающие, как создавать таблицы в реляционной базе данных,
        отражающие данные реального мира и в то же время позволяющие организовать эффективное
        хранение информации в базе данных. Процесс применения этих правил для проектирования
        "правильной" базы данных называется <emphasis role="italic">нормализацией</emphasis>. Мы не
        зря взяли слово "правильной" в кавычки, потому что "нормализованная база данных" и
        "оптимизированная база данных" не являются синонимами. Необходимо не просто слепо следовать
        правилам нормализации, но и всегда делать поправку на условия конкретной задачи.</para>
    <para>Нормализация таблиц в базе данных хорошо и подробно рассмотрена в книге [14], и потому мы
        не будем пытаться объять необъятное и вернемся к нашей конкретной области – к таблицам
        Firebird.</para>
    <section xml:id="ddl-table-create">
        <title>Создание таблицы</title>
        <indexterm>
            <primary>CREATE TABLE</primary>
        </indexterm>
        <para>Рассмотрим синтаксис предложения DDL (DDL – это Data Definition Language, подробнее
            см. в глоссарии), которое позволяет создавать таблицы:
            <programlisting>
CREATE [GLOBAL TEMPORARY] TABLE <replaceable>tablename</replaceable>
  [EXTERNAL [FILE] '<replaceable>&lt;filespec&gt;</replaceable>']
  (<replaceable>&lt;col_def&gt;</replaceable> [, <replaceable>&lt;col_def&gt;</replaceable> | <replaceable>&lt;tconstraint&gt;</replaceable> ...])  
  [ON COMMIT {DELETE | PRESERVE} ROWS];   
  </programlisting>
        </para>
        <para>Здесь <replaceable>tablename</replaceable> — имя создаваемой таблицы,
                <replaceable>&lt;col_def&gt;</replaceable> — описание столбцов (иногда мы будем
            говорить — полей) создаваемой таблицы. Если указана опция <code>[GLOBAL
                TEMPORARY]</code>, то будет создана глобальная временная таблица (GTT), о которых мы
            поговорим позже. Опция <code>[EXTERNAL [FILE]
                    '<replaceable>&lt;filespec&gt;</replaceable>']</code> означает, что будет
            создана так называемая внешняя таблица, которая хранится не в общем файле базы данных, а
            в отдельном файле с именем <replaceable>&lt;filespec&gt;</replaceable>. </para>
        <para>Для определения обычных (Persistent) таблиц необходимо задать её имя
                <replaceable>tablename</replaceable> и определить столбцы
                <replaceable>&lt;col_def&gt;</replaceable>, кроме того вы можете задать ограничения
            таблицы <replaceable>&lt;tconstraint&gt;</replaceable>. Теперь надо подробнее
            рассмотреть, как определить столбцы. </para>
        <para>Синтаксис создания столбца описывается следующим предложением DDL:
            <programlisting>
<replaceable>&lt;col_def&gt;</replaceable> ::= 
    <replaceable>&lt;regular_col_def&gt;</replaceable> 
  | <replaceable>&lt;computed_col_def&gt;</replaceable> 
  | <replaceable>&lt;identity_col_def&gt;</replaceable>        
                    
<replaceable>&lt;regular_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> { <replaceable>&lt;datatype&gt;</replaceable> | <replaceable>domainname</replaceable> } 
  [DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>}] 
  [NOT NULL]     
  [<replaceable>&lt;col_constraint&gt;</replaceable>]
  [COLLATE <replaceable>collation_name</replaceable>]        
                     
<replaceable>&lt;computed_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> [<replaceable>&lt;datatype&gt;</replaceable>] 
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<replaceable>&lt;expression&gt;</replaceable>) 
                    
<replaceable>&lt;identity_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> [<replaceable>&lt;datatype&gt;</replaceable>] 
  GENERATED BY DEFAULT AS IDENTITY [(START WITH <replaceable>startvalue</replaceable>)] 
  [<replaceable>&lt;col_constraint&gt;</replaceable>]         
        </programlisting>
        </para>
        <para>Столбцы могут быть обычными <replaceable>&lt;col_def&gt;</replaceable>, вычисляемыми
                <replaceable>&lt;computed_col_def&gt;</replaceable> или столбцами идентификации
                <replaceable>&lt;identity_col_def&gt;</replaceable>. Каждый столбец в таблице должен
            иметь имя, уникальное в пределах таблицы.</para>
        <para>Для обычных столбцов также обязательно указывать тип, который определяется выражением
                <replaceable>&lt;datatype&gt;</replaceable>, или домен
                <replaceable>domainname</replaceable>. Типы данных были рассмотрены в главе "Типы
            данных", поэтому вы легко можете понять, как формируется SQL-выражение для описания типа
            столбца. </para>
        <para>Необязательная опция <database>DEFAULT</database> позволяет указать значение по
            умолчанию для столбца таблицы. Это значение будет помещено в столбец таблицы при
            выполнении оператора <database>INSERT</database>, если значение не будет указано для
            этого столбца. В качестве значения по умолчанию может быть литерал совместимый по типу,
            значение NULL или контекстная переменная, тип которой совместим с типом столбца. Если
            значение по умолчанию явно не устанавливается, то подразумевается пустое значение, NULL.
            Использование выражений в значении по умолчанию недопустимо.</para>
        <para>Например, мы можем сформировать следующие выражения для создания столбца с числовым
            значением по умолчанию:
            <programlisting language="sql">
QUANTITY INT DEFAULT 0    
        </programlisting>
        </para>
        <para>В качестве значения по умолчанию мы можем использовать контекстную переменную.
            Например мы можем добавить поле в котором автоматически будет прописана дата создания
            записи:
            <programlisting language="sql">
CREATED_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP    
        </programlisting>
        </para>

        <para>Для некоторых полей совершенно необходимо, чтобы поле имело какое-то непустое
            значение. Такие поля ещё называют обязательными. По умолчанию столбец может принимать
            значение NULL. Необязательное предложение <database>NOT NULL</database> указывает, что
            столбцу не может быть присвоено значение NULL. Например,
            <programlisting language="sql">
NAME VARCHAR(80) NOT NULL    
        </programlisting>
        </para>
        <para>При этом создастся поле, в котором нельзя хранить неопределенные (NULL) значения.
            Обычно ограничение NOT NULL сочетается с опцией DEFAULT, которая гарантированно
            присваивает какое-либо корректное значение этому полю.</para>
        <para>Но часто ограничения NOT NULL бывает недостаточно. Например, в случае хранения в базе
            данных каких-либо цен совершенно очевидно, что они не могут принимать отрицательные
            значения (хотя было бы здорово, чтобы нам приплачивали при покупке какого-нибудь
            товара). Чтобы заставить сервер проверять заносимые в базу данных значения цен на
            условие положительности, следует так определить столбец:
            <programlisting language="sql">
PRICE NUMERIC(18, 2) CHECK (PRICE>0)    
        </programlisting>
        </para>
        <para>При этом заносимые в столбец PRICE значения будут проверяться на условие
            положительности. Надо отметить, что различные непротиворечивые опции могут сочетаться,
            например можно задать непустое значение и проверку на положительность:
            <programlisting language="sql">
PRICE NUMERIC(18, 2) NOT NULL CHECK (PRICE>0)  
        </programlisting>
        </para>
        <para>Надо отметить, что проверки могут выполнять множество полезных функций по управлению
            данными в базе данных. Подробнее их использование мы рассмотрим в главе "Ограничения
            базы данных". </para>
        <para>Некоторые опции при создании столбцов сочетаться не могут, например нельзя задать
            значение по умолчанию NULL и одновременно ограничение на непустое значение. </para>
        <para>Для типов <database class="datatype">CHAR</database>, <database class="datatype"
                >VARCHAR</database> и <database class="datatype">BLOB</database> с подтипом TEXT
            можно указать набор символов в предложении <database>CHARACTER SET</database>. Если
            набор символов не указан, то по умолчанию принимается тот набор символов, что был указан
            при создании базы данных. Если же при создании базы данных не был указан набор символов,
            то по умолчанию принимается набор символов NONE. В этом случае данные хранятся и
            извлекаются, так как они были поданы. В столбец можно загружать данные в любой
            кодировке, но невозможно загрузить эти данные в столбец с другой кодировкой.
            Транслитерация между исходными и конечными кодировками не выполняется, что может
            приводить к ошибкам.</para>
        <para>Необязательное предложение <database>COLLATE</database> позволяет задать порядок
            сортировки для строковых типов данных (за исключением <database class="datatype"
                >BLOB</database>). Если порядок сортировки не указан, то по умолчанию принимается
            порядок сортировки по умолчанию для указанного набора сортировки.</para>
        <para>Определение столбца таблицы может также включать ограничения столбца. Об ограничениях
            таблицы и столбца мы поговорим позже.</para>
        <para>Давайте подключимся к ранее созданной базе данных, и попробуем поработать с таблицами
            на практике. Для создания, удаления и модифицирования таблиц подойдет как любой из
            административных инструментов Firebird, например, стандартная утилита
                <application>isql.exe</application> из комплекта поставки Firebird.</para>
        <para>Вот пример простой таблицы, названной TABLE_EXAMPLE и содержащей 3 поля различных
            типов:
            <programlisting language="sql">
CREATE TABLE Table_example (
  ID    INTEGER,
  NAME  VARCHAR(80),
  PRICE NUMERIC(18, 2));   
    </programlisting>
        </para>
        <para>Эта таблица иллюстрирует наиболее часто встречающийся в процессе разработки базы
            данных случай. </para>
        <para>Для определения столбца, можно воспользоваться ранее описанным доменом. Домен — это
            тип, определяемый пользователем для удобства применения определенных сочетаний
            параметров типов. Если определение столбца основано на домене, оно может включать новое
            значение по умолчанию, дополнительные ограничения <database>CHECK</database>,
            предложение <database>COLLATE</database>, которые перекрывают значения указанные при
            определении домена. Определение такого столбца может включать дополнительные ограничения
            столбца, например NOT NULL, если домен его ещё не содержит.</para>
        <important>
            <para>Следует обратить внимание на то, что если в определении домена было указано
                    <database>NOT NULL</database>, на уровне столбца невозможно определить
                допустимость использования в нем значения NULL. Если вы хотите чтобы на основе
                домена можно было определять столбцы допускающие псевдозначение NULL и не
                допускающее его, то хорошей практикой является создание домена допускающего NULL и
                указание ограничения <database>NOT NULL</database> у столбцов таблицы там где это
                необходимо.</para>
        </important>
        <para>Например, можно определить домен D_MONEY для хранения денежных значений с точностью 2
            знака после запятой. Определив домен, можно воспользоваться им для задания типа поля:
            <programlisting language="sql">
CREATE TABLE Table_example (
  ID    INTEGER,
  NAME  VARCHAR(80),
  PRICE D_MONEY);   
    </programlisting>
        </para>
        <para>При этом поле PRICE будет иметь тип, определяемый доменом D_MONEY. Таким образом,
            определив в домене тип поля, необходимые проверки и ограничения, мы можем многократно
            применять этот домен для создания полей одинакового назначения, например денежных, без
            утомительного и таящего в себе опасность ошибиться переписывания определений типов
            переменных.</para>
        <indexterm>
            <primary>COMPUTED BY</primary>
        </indexterm>
        <indexterm>
            <primary>GENERATED ALWAYS AS</primary>
        </indexterm>
        <indexterm>
            <primary>Столбец</primary>
            <secondary>Вычисляемый столбец</secondary>
        </indexterm>
        <para>Помимо обычных столбцов таблицы Firebird могут содержать вычисляемые столбцы.
            Вычисляемые поля могут быть определены с помощью предложения COMPUTED [BY] или
                <database>GENERATED ALWAYS AS</database> (согласно стандарту SQL-2003). Они
            эквивалентны по смыслу. Для вычисляемых полей не требуется описывать тип данных (но
            допустимо), СУБД вычисляет подходящий тип в результате анализа выражения. В выражении
            требуется указать корректную операцию для типов данных столбцов, входящих в его состав.
            При явном указании типа столбца для вычисляемого поля результат вычисления приводится к
            указанному типу, то есть, например, результат числового выражения можно вывести как
            строку. Вычисление выражения происходит для каждой строки выбранных данных, если в
            операторе выборки данных SELECT, присутствует такой столбец.</para>
        <tip>
            <para>Вместо использования вычисляемого столбца в ряде случаев имеет смысл использовать
                обычный столбец, значение которого рассчитывается в триггерах на добавление и
                обновление данных. Это может снизить производительность вставки/модификации записей,
                но повысит производительность выборки данных.</para>
        </tip>
        <para>Например, мы можем пожелать иметь в нашей таблице столбец, вычисляющий 10% от значения
            поля PRICE. Для этого мы можем ввести следующую команду:
            <programlisting language="sql">
CREATE TABLE Table_example (
  ID    INTEGER,
  NAME  VARCHAR(80),
  PRICE NUMERIC(18, 2),
  PRICE_DISCONT COMPUTED BY (PRICE * 0.1));   
    </programlisting>
        </para>
        <para>Но не думайте, что теперь, как только мы вставим данные в поле PRICE, в поле
            PRICE_DISCONT окажется десятая часть от значения этого поля. Нет, процесс тут более
            сложен. На самом деле мы получим искомую десятую часть только при обращении к полю
            PRICE_DISCONT, например при выполнении запроса SELECT к этой таблице. То есть в
            вычисляемом поле не хранятся какие-либо данные, а при каждой выборке производится
            вычисление выражения, связанного с полем, и результат выдается в ответ на запрос.</para>
        <indexterm>
            <primary>IDENTITY</primary>
        </indexterm>
        <indexterm>
            <primary>Столбец</primary>
            <secondary>Столбец идентификации</secondary>
        </indexterm>
        <para>Существует ещё один вид столбцов — так называемые столбцы идентификации или
            автоинкрементные столбцы. Столбцы идентификации доступны начиная с Firebird 3.0. Столбцы
            идентификации могут быть определены с помощью предложения <database>GENERATED BY DEFAULT
                AS IDENTITY</database>. Столбец идентификации представляет собой столбец, связанный
            с внутренним генератором последовательностей. Подробнее о последовательностях
            (гененраторах) мы расскажем позже в главе Последовательности (генераторы). Его значение
            устанавливается автоматически каждый раз, когда оно не указано в операторе INSERT.
            Необязательное предложение <database>START WITH</database> позволяет указать начальное
            значение отличное от нуля.</para>
        <formalpara>
            <title>Правила</title>
            <para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Тип данных столбца идентификации должен быть целым числом с нулевым
                            масштабом. Допустимыми типами являются SMALLINT, INTEGER, BIGINT,
                            NUMERIC(x,0) и DECIMAL(x,0);</para>
                    </listitem>
                    <listitem>
                        <para>Идентификационный столбец не может иметь DEFAULT и COMPUTED
                            значений.</para>
                    </listitem>
                </itemizedlist>
            </para>
        </formalpara>
        <note>
            <para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Идентификационный столбец не может быть изменён, чтобы стать обычным
                            столбцом. Обратное тоже верно.</para>
                    </listitem>
                    <listitem>
                        <para>Идентификационные столбцы неявно являются NOT NULL столбцами.</para>
                    </listitem>
                    <listitem>
                        <para>Уникальность не обеспечивается автоматически. Ограничения UNIQUE или
                            PRIMARY KEY требуются для гарантии уникальности.</para>
                    </listitem>
                </itemizedlist>
            </para>
        </note>
        <para>Столбцы идентификации часто используются для организации суррогатный первичных ключей.
            Подробней о первичных ключах и других ограничениях целостности мы расскажем позже в
            главе Ограничения базы данных.</para>
        <para>Давайте посмотрим на пример таблицы со столбцом идентификации. <programlisting language="sql">
CREATE TABLE objects (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(15)
);

INSERT INTO objects (name) VALUES ('Table');
INSERT INTO objects (name) VALUES ('Book');
INSERT INTO objects (id, name) VALUES (10, 'Computer');

SELECT * FROM objects;
</programlisting>
            <screen>
ID           NAME
============ ===============
           1 Table
           2 Book
          10 Computer
</screen>
        </para>
        <para>Итак, мы рассмотрели способы создания таблиц и полей с различными опциями.</para>
    </section>
    <section>
        <title>Изменение таблицы</title>

        <para>Однако бывают случаи, когда необходимо изменить уже существующую таблицу. Конечно, мы
            можем пересоздать таблицу целиком. Для этого следует выполнить команду удаления таблицы
            и вновь создать ее, например так:
            <programlisting language="sql">
DROP TABLE Table_example;
CREATE TABLE Table_example(ID INTEGER, PRICE NUMERIC(15,2));
</programlisting></para>
        <indexterm>
            <primary>RECREATE TABLE</primary>
        </indexterm>
        <para>Существует также оператор RECREATE TABLE, который объединяет операторы DROP TABLE и
            CREATE TABLE.
            <programlisting language="sql">
RECREATE TABLE Table_example(ID INTEGER, PRICE NUMERIC(15,2));
</programlisting>
        </para>
        <indexterm>
            <primary>ALTER TABLE</primary>
        </indexterm>
        <para>Но такой способ изменения таблиц имеет значительные недостатки. При удалении таблицы с
            помощью команды DROP все данные, которые существовали в таблице, уничтожаются и, чтобы
            их не потерять, приходится копировать их во временные таблицы. Это весьма хлопотно.
            Поэтому для легкого изменения структуры таблиц существует команда ALTER TABLE, которая
            позволяет добавлять новые поля, удалять существующие, а также добавлять/удалять
            ограничения ссылочной целостности.</para>
        <para>Приведём синтаксис оператора ALTER TABLE.
            <programlisting>
ALTER TABLE <replaceable>tablename</replaceable> 
  <replaceable>&lt;operation&gt;</replaceable> [, <replaceable>&lt;operation&gt;</replaceable>];       

<replaceable>&lt;operation&gt;</replaceable> ::=      
    ADD <replaceable>&lt;col_def&gt;</replaceable> 
  | ADD <replaceable>&lt;tconstraint&gt;</replaceable> 
  | DROP <replaceable>colname</replaceable>   
  | DROP CONSTRAINT <replaceable>constr_name</replaceable>   
  | ALTER [COLUMN] <replaceable>colname</replaceable> <replaceable>&lt;col_mod&gt;</replaceable>
                        
<replaceable>&lt;col_def&gt;</replaceable> ::= <replaceable>&lt;regular_col_def&gt;</replaceable> | <replaceable>&lt;computed_col_def&gt;</replaceable> | <replaceable>&lt;identity_col_def&gt;</replaceable>                        

<replaceable>&lt;regular_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> { <replaceable>&lt;datatype&gt;</replaceable> | <replaceable>domainname</replaceable> }
  [DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>}]
  [NOT NULL]
  [<replaceable>&lt;col_constraint&gt;</replaceable>]
  [COLLATE <replaceable>collation_name</replaceable>]   


<replaceable>&lt;computed_col_def&gt;</replaceable>  ::=   
  <replaceable>colname</replaceable> [<replaceable>&lt;datatype&gt;</replaceable>] 
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<replaceable>&lt;expression&gt;</replaceable>)
                        
<replaceable>&lt;identity_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> [<replaceable>&lt;datatype&gt;</replaceable>] GENERATED BY DEFAULT AS IDENTITY 
  [(START WITH <replaceable>startvalue</replaceable>)] [<replaceable>&lt;col_constraint&gt;</replaceable>]                          

<replaceable>&lt;col_mod&gt;</replaceable> ::= <replaceable>&lt;regular_col_mod&gt;</replaceable> | <replaceable>&lt;computed_col_mod&gt;</replaceable> | <replaceable>&lt;identity_col_mod&gt;</replaceable> 

<replaceable>&lt;regular_col_mod&gt;</replaceable> ::=
     TO <replaceable>newname</replaceable> 
  |  POSITION <replaceable>newpos</replaceable>                       
  |  TYPE { <replaceable>&lt;datatype&gt;</replaceable>  | <replaceable>domainname</replaceable> }  
  |  SET DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>} 
  |  DROP DEFAULT 
  |  SET NOT NULL
  |  DROP NOT NULL  

<replaceable>&lt;computed_col_mod&gt;</replaceable> ::=
     TO <replaceable>newname</replaceable> 
  |  POSITION <replaceable>newpos</replaceable>  
  | [TYPE <replaceable>&lt;datatype&gt;</replaceable>] {GENERATED ALWAYS AS | COMPUTED [BY]} (<replaceable>&lt;expression&gt;</replaceable>)  

<replaceable>&lt;identity_col_mod&gt;</replaceable> ::=
     TO <replaceable>newname</replaceable> 
  |  POSITION <replaceable>newpos</replaceable>  
  |  RESTART [ WITH <replaceable>startvalue</replaceable> ]         
        </programlisting>
        </para>
        <para>Как видно из синтаксической схемы возможности оператора ALTER TABLE довольно обширны,
            поэтому будем разбирать этот оператор по частям. Кроме того, одиночный оператор
                <database>ALTER TABLE</database> позволяет производить множество операций
            добавления/удаления столбцов и ограничений, а также модификаций столбцов. Список
            операций выполняемых при модификации таблицы разделяется запятой.</para>
        <note>
            <title>Счётчик форматов</title>

            <para>В Firebird метаданные таблиц имеют формат. С каждым форматом связан так называемый
                счётчик форматов. Это позволяет быстро добавлять или удалять поля таблицы без
                переписывания всех записей таблицы так чтобы они соответствовали новому формату.
                После модификации структуры таблицы при чтении записей они преобразуются к
                последнему формату таблицы.</para>
            <para>Некоторые изменения структуры таблицы увеличивают счётчик форматов, закреплённый
                за каждой таблицей. Количество форматов для каждой таблицы ограничено значением 255.
                После того, как счётчик форматов достигнет этого значения, вы не сможете больше
                менять структуру таблицы. </para>
            <para>Для сброса счётчика форматов необходимо сделать резервное копирование и
                восстановление базы данных (утилитой <application>gbak</application>). </para>
        </note>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ADD</secondary>
        </indexterm>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ADD CONSTRAINT</secondary>
        </indexterm>
        <para>Предложение <database>ADD</database> позволяет добавить новый столбец или новое
            ограничение таблицы. Синтаксис определения столбца и синтаксис описания ограничения
            таблицы полностью совпадают с синтаксисом, описанным в операторе <link
                linkend="ddl-table-create">CREATE TABLE</link>. </para>
        <para>При каждом добавлении нового столбца номер формата увеличивается на единицу.
            Добавление нового ограничения таблицы не влечёт за собой увеличение номера
            формата.</para>
        <note>
            <para>При добавлении нового столбца, не допускающего значения NULL, в таблицу <emphasis
                    role="italic">с данными</emphasis> необходимо также установить значение по
                умолчанию с помощью предложения <database>DEFAULT</database>. Дело в том, что в этом
                случае также происходит проверка данных на допустимость. А поскольку при добавлении
                нового столбца, он для всех строк таблицы содержит значение NULL, будет
                сгенерировано исключение. Это справедливо для Firebird 3.0 и выше. Firebird 2.5 не
                осуществляет такую проверку, что может сыграть злую шутку при попытки восстановления
                такой базы данных утилитой <application>gbak</application>.</para>
        </note>
        <para>Приведём примеры добавления столбцов и ограничений.</para>
        <para>Например, мы желаем добавить в таблицу еще один столбец, предназначенный для хранения
            данных об отчестве человека:
            <programlisting language="sql">
ALTER TABLE Table_example ADD Patronimic VARCHAR(80);        
        </programlisting>
        </para>
        <para>После выполнения этой команды в нашей таблице Table_example появится новый столбец с
            именем Patronimic и типом VARCHAR(80). </para>
        <para>А теперь добавим ограничение уникальности на Фамилию, имя и отчество:
            <programlisting language="sql">
ALTER TABLE Table_example ADD CONSTRAINT UK_FIO UNIQUE(Surname, Name, Patronimic);        
        </programlisting>
        </para>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>DROP</secondary>
        </indexterm>
        <para>Предложение <database>DROP</database> удаляет указанный столбец таблицы. Столбец
            таблицы не может быть удалён, если от него существуют зависимости. Другими словами для
            успешного удаления столбца на него должны отсутствовать ссылки. Ссылки на столбец могут
            содержаться: <itemizedlist spacing="compact">
                <listitem>
                    <para>в ограничениях столбцов или таблицы;</para>
                </listitem>
                <listitem>
                    <para>в индексах;</para>
                </listitem>
                <listitem>
                    <para>в хранимых процедурах и триггерах;</para>
                </listitem>
                <listitem>
                    <para>в представлениях.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>При каждом удалении столбца номер формата увеличивается на единицу. </para>
        <para>Таким образом, если мы пожелаем удалить из таблицы столбец с именем NAME, то следует
            выполнить
            <programlisting language="sql">
ALTER TABLE Table_example DROP Name;       
        </programlisting>
        </para>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>DROP CONSTRAINT</secondary>
        </indexterm>
        <para>Предложение <database>DROP CONSTRAINT</database> удаляет указанное ограничение столбца
            или таблицы. Ограничение первичного ключа или уникального ключа не могут быть удалены,
            если они используются в ограничении внешнего ключа другой таблицы. В этом случае,
            необходимо удалить ограничение <database>FOREIGN KEY</database> до удаления
                <database>PRIMARY KEY</database> или <database>UNIQUE</database> ключа, на которые
            оно ссылается. </para>
        <para>Удаление ограничения столбца или ограничения таблицы не влечёт за собой увеличение
            номера формата. </para>
        <para>Если хотим удалить ограничение уникальности на Фамилию, имя и отчество, добавленное
            ранее, то следует выполнить:
            <programlisting language="sql">
ALTER TABLE Table_example DROP CONSTRAINT UK_FIO;        
        </programlisting>
        </para>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
        </indexterm>
        <para>Для изменения самого столбца используется предложение ALTER [COLUMN], оно позволяет
            изменить следующие характеристики существующих столбцов: <itemizedlist spacing="compact">
                <listitem>
                    <para>изменение имени (не изменяет номер формата);</para>
                </listitem>
                <listitem>
                    <para>изменение типа данных (увеличивает номер формата на единицу);</para>
                </listitem>
                <listitem>
                    <para>изменение позиции столбца в списке столбцов таблицы (не изменяет номер
                        формата);</para>
                </listitem>
                <listitem>
                    <para>удаление значения по умолчанию столбца (не изменяет номер формата);</para>
                </listitem>
                <listitem>
                    <para>добавление значения по умолчанию столбца (не изменяет номер
                        формата);</para>
                </listitem>
                <listitem>
                    <para>изменение типа и выражения для вычисляемого столбца (не изменяет номер
                        формата);</para>
                </listitem>
                <listitem>
                    <para>добавление ограничения NOT NULL (не изменяет номера формата);</para>
                </listitem>
                <listitem>
                    <para>удаление ограничения NOT NULL (не изменяет номера формата).</para>
                </listitem>
            </itemizedlist></para>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
            <tertiary>TO</tertiary>
        </indexterm>
        <para>Ключевое слово <database>TYPE</database> изменяет тип существующего столбца на другой
            допустимый тип. Не допустимы любые изменения типа, которые могут привести к потере
            данных. Например, количество символов в новом типе для столбца не может быть меньше, чем
            было установлено ранее. </para>
        <para>Ключевое слово TO используется для переименования существующего столбца. Новое имя
            столбца не должно присутствовать в таблице. </para>
        <para>Невозможно изменение имени столбца, если этот столбец включён в какое-либо ограничение
            — первичный или уникальный ключ, внешний ключ, ограничение столбца или проверочное
            ограничение таблицы CHECK. Имя столбца также нельзя изменить, если этот столбец таблицы
            используется в каком-либо триггере, в хранимой процедуре или представлении. </para>
        <para>Приведём пример переименования столбца. Допустим, мы решили, что для хранения имен
            лучше использовать поле HUMAN_NAME, а не просто NAME. В этом случае необходимо
            воспользоваться оператором:
            <programlisting language="sql">
ALTER TABLE Table_example
ALTER COLUMN NAME TO HUMAN_NAME;   
        </programlisting>
        </para>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
            <tertiary>TYPE</tertiary>
        </indexterm>
        <para>Ключевое слово <database>TYPE</database> используется для изменения типа существующего
            столбца на другой <emphasis role="italic">допустимый</emphasis> тип. Не допустимы любые
            изменения типа, которые могут привести к потере данных. Например, количество символов в
            новом типе для столбца не может быть меньше, чем было установлено ранее. </para>
        <note>
            <para>Если столбец был объявлен как массив, то изменить ни его тип, ни размерность
                нельзя.</para>
            <para>Нельзя изменить тип данных у столбца, который принимает участие в связке внешний
                ключ / первичный (уникальный) ключ.</para>
        </note>
        <para> Допустим мы решили увеличить максимальное количество символов для поля NAME, в этом
            случае следует выполнить запрос:
            <programlisting language="sql">
ALTER TABLE Table_example
ALTER COLUMN NAME TYPE VARCHAR(63);   
        </programlisting>
        </para>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
            <tertiary>POSITION</tertiary>
        </indexterm>
        <para>Используя ключевое слово <database>POSITION</database> вы можете изменить позицию
            столбца в таблице. Позиции столбцов нумеруются с единицы. Например мы решили переместить
            столбец NAME на первое место, для этого воспользуемся запросом:
            <programlisting language="sql">
ALTER TABLE Table_example
ALTER COLUMN NAME POSITION 1;   
        </programlisting>
        </para>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
            <tertiary>SET DEFAULT</tertiary>
        </indexterm>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
            <tertiary>DROP DEFAULT</tertiary>
        </indexterm>
        <para>Для установки и удаления значения по умолчанию используются ключевые слова SET DEFAULT
            и DROP DEFAULT соответственно. Значение по умолчанию установленное для столбца
            перекрывает значение по умолчанию установленное в домене. Если у домена ессть значение
            по умолчанию. то при удалении значения по умолчанию столбца его перекроет значение по
            умолчанию домена. Примеры применения приведены ниже:
            <programlisting language="sql">
ALTER TABLE STOCK
ALTER COLUMN MODEL SET DEFAULT 1;

ALTER TABLE STOCK
ALTER COLUMN MODEL DROP DEFAULT;
        </programlisting>
        </para>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
            <tertiary>SET NOT NULL</tertiary>
        </indexterm>
        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
            <tertiary>DROP NOT NULL</tertiary>
        </indexterm>
        <para>Что бы установить ограничение NOT NULL для столбца таблицы используется предложение
                <database>SET NOT NULL</database>. Предложение <database>DROP NOT NULL</database>
            удаляет ограничение NOT NULL для столбца таблицы. Эта возможность доступна начиная с
            Firebird 3.0.</para>
        <note>
            <para>Успешное добавление ограничения NOT NULL происходит, только после полной проверки
                данных таблицы, для того чтобы убедится что столбец не содержит значений NULL. </para>
            <para>Явное ограничение NOT NULL на столбце, базирующегося на домене, преобладает над
                установками домена. В этом случае изменение домена для допустимости значения NULL,
                не распространяется на столбец таблицы. </para>
        </note>
        <para>Примеры:
            <programlisting language="sql">
ALTER TABLE Table_example
ALTER COLUMN NAME SET NOT NULL;

ALTER TABLE STOCK
ALTER COLUMN MODEL DROP NOT NULL;
        </programlisting>
        </para>

        <indexterm>
            <primary>ALTER TABLE</primary>
            <secondary>ALTER [COLUMN]</secondary>
            <tertiary>RESTART [WITH]</tertiary>
        </indexterm>
        <para>Для столбцов идентификации (<database>GENERATED BY DEFAULT AS IDENTITY</database>)
            позволено изменять начальное значение. Если указано только предложение
                <database>RESTART</database>, то происходит сброс значения генератора в ноль.
            Необязательное предложение WITH позволяет указать для нового значения внутреннего
            генератора отличное от нуля значение. Невозможно изменить обычный столбец на столбец
            идентификации и наоборот.</para>
        <para>В следующем примере мы устанавливаем значение генератора связанного со столбцом
            идентификации в 100.
            <programlisting language="sql">
ALTER TABLE objects
ALTER ID RESTART WITH 100;
        </programlisting>
        </para>
        <para>Для вычисляемых столбцов (<database>GENERATED ALWAYS AS</database> или
                <database>COMPUTED BY</database>) позволяется изменить тип и выражение вычисляемого
            столбца. Невозможно изменить обычный столбец на вычисляемый и наоборот. </para>
        <para>Ниже показан пример изменения вычисляемого столбца:
            <programlisting language="sql">
ALTER TABLE SALARY_HISTORY
ALTER NEW_SALARY GENERATED ALWAYS 
AS (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100),
ALTER SALARY_CHANGE COMPUTED 
BY (OLD_SALARY * PERCENT_CHANGE / 100);
        </programlisting>
        </para>
        <para>Напоследок продемонстрируем возможность выполнения оператором ALTER TABLE сразу
            множество действий по модификации структуры таблицы:
            <programlisting language="sql">
ALTER TABLE STOCK
ALTER COLUMN MODEL SET DEFAULT 1,
ALTER COLUMN ITEMID TYPE BIGINT,
ALTER COLUMN ITEMID DROP NOT NULL,
ALTER COLUMN PROPID SET NOT NULL,
ALTER COLUMN MODELNAME TO NAME;
        </programlisting>
        </para>

    </section>
    <section>
        <title>Удаление таблицы</title>

        <para>Для удаления таблиц используется оператор DROP TABLE. Его синтаксис доволно простой:
            <programlisting>
DROP TABLE <replaceable>tablename</replaceable>; 
        </programlisting>
        </para>
        <para> Если таблица имеет зависимости, то удаление не будет произведено. При удалении
            таблицы будут также удалены все триггеры на её события и индексы, построенные для её
            полей.</para>
        <para>Удалить таблицу могут только администраторы базы данных, её владелец и пользователи с
            привилегией DROP ANY TABLE.</para>

        <para>Итак, мы рассмотрели создание, модификацию и удаление таблиц в Firebird. Теперь
            придется немного углубиться в теорию баз данных. Firebird, как уже было сказано,
            является реляционной базой данных. Помимо всего прочего это означает, что каждая запись
            в таблице должна иметь некоторый признак, по которому одну запись можно отличить от
            другой. Для этой цели служит специальный механизм уникальных ключей.</para>
    </section>
    <section>
        <title>Первичные ключи в таблицах</title>

        <para>Конечно, мы можем создать таблицу, не содержащую никаких ключей. Это никто нам не
            запрещает. Но, как уже говорилось, создание работоспособной базы данных невозможно без
            следования правилам нормализации. Наличие ключей — важнейший элемент нормализации.
            Поэтому, хоть мы и не ставим целью на рассмотрение теории и нормализации баз данных, нам
            придется ввести определение ключей и рассмотреть их роль в Firebird.</para>

        <para>Будем двигаться постепенно и начнем с самого распространенного типа ключей — с
            первичного ключа.</para>

        <para>Итак, что же такое <emphasis role="italic">первичный ключ</emphasis>? Это одно или
            более полей в таблице, однозначно идентифицирующих записи в пределах этой таблицы.
            Звучит сложно, однако на самом деле все очень просто. Представьте себе обыкновенную
            таблицу, например бухгалтерскую ведомость. Что является самым первым столбцом?
            Правильно, порядковый номер – 1, 2, 3… Этот номер указывает на уникальную строку в
            пределах таблицы, и достаточно знать этот номер, чтобы найти в этой таблице строку. В
            данном примере это и будет первичный ключ.</para>

        <para>Абсолютное большинство таблиц в реляционной базе данных обязательно имеют первичный
            ключ (часто пишут PK – сокращение от Primary key). Общей рекомендацией при создании
            таблиц является создавать первичный ключ. Создать первичный ключ можно как при создании
            таблицы, так и позже. Допустим, мы уже к моменту создания таблицы решили, что первичным
            ключом у нас будет поле ID. Тогда добавить первичный ключ можно следующим образом:
            <programlisting language="sql">
CREATE TABLE Table_example (
    ID INTEGER NOT NULL,
    NAME VARCHAR(80),
    PRICE NUMERIC(18, 2),
    CONSTRAINT pkTable PRIMARY KEY (ID));        
        </programlisting>
        </para>
        <para>Итак, что необходимо сделать, чтобы создать первичный ключ на таблицу table_example.
            Внимательно рассмотрим, что изменилось в определении таблицы? Во-первых, колонка ID
            получила дополнительное определение NOT NULL. Это важно — первичный ключ должен быть
            уникальным и не допускать неопределенных значений. А NULL, как вы знаете, это
            неопределенное значение. Таким образом, все поля, входящие в первичный ключ, должны
            иметь ограничение NOT NULL. </para>
        <para>Чтобы завершить создание первичного ключа, в конце таблицы дописывается предложение
            вида <code>[CONSTRAINT <replaceable>constr_name</replaceable>]
                    <replaceable>&lt;key_type&gt;</replaceable>
                    (<replaceable>&lt;col_list&gt;</replaceable>)</code>. Полный синтаксис
            ограничений рассмотрен в главе "<link linkend="constraints">Ограничения базы
                данных</link>", и для нашего примера первичного ключа будет иметь вид:
            <programlisting language="sql">
CONSTRAINT pkTable PRIMARY KEY (ID)
        </programlisting>
        </para>
        <para> Здесь — pkTable — имя первичного ключа, а ID — столбцы, входящие в него. Такой способ
            определять первичные ключи для таблиц удобен при массовом создании таблиц (например, при
            построении прототипа базы данных на основе скриптов, получаемых с помощью различных
            CASE-средств). Но что делать, если нам нужно добавить/удалить первичный ключ в таблицу,
            когда она уже существует и наполнена данными? Для этого следует воспользоваться еще
            одним расширением команды — ALTER TABLE. Пример добавления первичного ключа в нашу
            таблицу:
            <programlisting language="sql">
ALTER TABLE TABLE_EXAMPLE ADD CONSTRAINT pkTable PRIMARY KEY (ID);
        </programlisting>
        </para>
        <para>При этом в таблицу Table_example добавится точно такой же первичный ключ, как и в
            предыдущем примере, когда он создавался вместе с таблицей. Чтобы удалить первичный ключ,
            необходимо ввести следующую команду:
            <programlisting language="sql">
ALTER TABLE Table_example DROP CONSTRAINT pkTable;
        </programlisting>
        </para>
        <para>При этом ключ с именем pkTable будет удален из базы данных.</para>
    </section>
    <section>
        <title>Естественные и суррогатные первичные ключи</title>

        <para>Надо сказать несколько слов о реализации первичного ключа. Так как он предназначен для
            обеспечения уникальности, то никакие две записи в одной таблице не могут иметь
            одинаковых значений этого ключа. То есть, чтобы удовлетворить этому условию, при
            занесении новой записи в таблицу Firebird должен просмотреть все записи в таблице и
            выяснить, нет ли уже таких значений в таблице. Для быстрого поиска в Firebird существует
            механизм <emphasis role="italic">индексов</emphasis> — специальных объектов Firebird,
            которые позволяют очень быстро найти запись в таблице. Поэтому при создании и удалении
            первичного ключа создается или удаляется индекс на то поле (или поля), которое входит в
            первичный ключ.</para>

        <para>Как уже было сказано, первичный ключ может содержать несколько полей. При этом будет
            отслеживаться уникальность сочетания значений этих полей. Например, если мы определим
            ключ на поля ID и NAME, то сервер будет следить за тем, чтобы во всей таблице не было
            одинаковых сочетаний этих полей. То есть сочетания полей ID и NAME вроде 1 и "Иванов", 2
            и "Иванов" будут корректными, поскольку они отличаются значениями поля ID.</para>

        <para>Таким образом, первичный ключ может включать несколько полей любых типов. Однако на
            практике самым распространенным видом ключа является счетчик — целочисленное поле,
            которое содержит увеличивающиеся значения. Почему так? Это является отражением давнего
            спора между <emphasis role="italic">естественными</emphasis> и <emphasis role="italic"
                >суррогатными</emphasis> ключами. Концепция естественных ключей утверждает, что в
            качестве ключа надо стараться использовать значения, реально существующие в предметной
            области, которую отражает база данных. Например, если мы разрабатываем систему учета
            людей для паспортного стола, то согласно этой концепции необходимо в качестве первичного
            ключа взять сочетание номера и серии паспорта. Действительно, каждый человек должен
            иметь свое уникальное сочетание номера и серии паспорта. Однако как быть с тем, что
            человек может поменять паспорт в течение жизни (в связи с достижением определенного
            возраста, при заключении брака и т. д.)? В этом случае нам будет необходимо сменить
            номер и серию паспорта, поставленные в соответствие конкретному человеку, т. е.
            фактически, сменить наш первичный ключ. Это нежелательно с точки зрения разработки
            приложений баз данных: при разветвленной системе связей между таблицами (этому посвящена
            следующая глава) может понадобиться слишком много усилий разработчика для отслеживания
            этой ситуации.</para>

        <para>Поэтому в большинстве случаев используется суррогатный ключ. Суррогатный — значит
            искусственный, т. е. не существующий в предметной области, которую описывает наша база
            данных, а созданный искусственно — для удобства разработки приложений базы
            данных.</para>
    </section>
    <section>
        <title>Способы реализации суррогатных ключей</title>

        <para>Как уже было сказано, обычно первичным ключом является счетчик. Некоторые СУБД, такие,
            как MySQL и MS SQL, имеют специальный тип — счетчик (auto increment). При добавлении в
            таблицу новой записи значение поля с этим типом автоматически увеличивается на величину
            приращения — обычно на единицы. </para>

        <para>До Firebird 3.0 не было поля типа счетчик, однако существовала возможность реализовать
            подобное поведение с помощью так называемых генераторов или последовательностей. Начиная
            с Firebird 3.0 для реализации счётчиков можно воспользоваться IDENTITY полями. Для
            начала разберёмся с последовательностями.</para>

        <section>
            <title>Использование последовательностей для первичных ключей</title>

            <para>Что такое последовательность? Говоря по-простому, последовательность — это
                именованный счетчик. Внутри базы данных мы можем создать счетчик, дать ему
                уникальное имя в пределах этой базы и управлять значениями этого счетчика. Это и
                будет последовательность. </para>
            <note>
                <para>Термины последовательность и генератор являются синонимами. Генераторы были
                    введены ещё в Interbase. Однако, когда их включили в SQL-стандарт им дали
                    название последовательности.</para>
            </note>
            <para>Чтобы это пояснить — вот пример предложений DDL:
                <programlisting language="sql">
CREATE GENERATOR g1;
SET GENERATOR g1 TO 2445;        
        </programlisting>
                или
                <programlisting language="sql">
CREATE SEQUENCE g1;
ALTER SEQUENCE g1 RESTART WITH 2445;        
        </programlisting>
            </para>
            <para>В этом примере в первой строчке в базе данных создается последовательность с
                именем g1, а во второй — значение последовательности устанавливается в 2445.
                Подробнее о создании и изменении последовательностей, а также их опциях мы поговорим
                позже в главе "Последовательности".</para>
            <para>Возникает вопрос как же нам получать следующее значение последовательности.
                Существует два способа. Согласно SQL стандарту следующее значение последовательности
                получают с помощью оператора NEXT VALUE FOR.
                <programlisting language="sql">
NextId = NEXT VALUE FOR g1;       
        </programlisting>
                Чтобы получить значение последовательности в клиентском приложении, можно
                воспользоваться таким запросом:
                <programlisting language="sql">
SELECT NEXT VALUE FOR g1 AS ID
FROM RDB$DATABASE
        </programlisting>
                Так как в таблице RDB$ Database всегда содержится только одна запись, то мы получим
                в результате данного запроса следующее значение последовательности g1.</para>
            <para>Другой способ, который появился исторически первым получение генератора с помощью
                функции GEN_ID. В отличие от предыдущего способа с помощью этой функции можно
                получать значение генератора с любым приращением, а не только тем что указано в
                самом генераторе. </para>
            <tip>
                <para>Это может быть полезно при вставке большого количества записей: мы можем
                    сделать приращение генератору на количество вставляемых записей, тем самым
                    сократив количество обращений к генератору. </para>
            </tip>
            <para>Следующий пример демонстрирует получение следующего значения последовательности с
                помощью функции GEN_ID.
                <programlisting language="sql">
NextId = GEN_ID(g1, 1);       
        </programlisting>
                Здесь NextId — переменная (как использовать переменные в Firebird — см. в следующих
                главах), g1 — генератор (последовательность), 1 — приращение. В этом примере в
                переменную current_value попадет значение генератора g1 после прибавления к нему
                приращения 1, т. е. следующее значение генератора! </para>
            <para>Обратите внимание, что приращение может быть не равно единице! Более того, оно
                может быть даже отрицательным:
                <programlisting language="sql">
NextId = GEN_ID (g1, -23)       
        </programlisting>
                В результате выполнения этой функции текущее значение последовательности g1
                уменьшиться на 23. Как видите, диапазон возможных применений генераторов довольно
                широк — его можно использовать не только для получения значений первичных ключей, но
                и для отслеживания глобальных изменений в базе данных. </para>
            <para>Люди, знакомые с базами данных, могут задать вопрос: "А что будет, если
                одновременно несколько клиентов попробуют внести данные в одну и ту же таблицу и
                одновременно "дёрнут" последовательность? Получат ли они одно или разные значения
                последовательности?" Однозначно, что они получат РАЗНЫЕ значения последовательности.
                Какой бы "одновременной" ни была попытка получить значение последовательности,
                каждый обратившийся получит свое уникальное значение. Это гарантируется самой
                "конструкцией" последовательностей: они работают на самом низком уровне сервера и
                никакие процессы записи и вставки не влияют на них — часто говорят, что
                последовательности работают "вне контекста транзакций". Что такое транзакции, вы
                можете узнать в главе "Транзакции. Параметры транзакций", а как устроены
                последовательности (генераторы) — в главе "Структура базы данных Firebird".</para>
            <para>Таким образом при помощи последовательностей мы имеем надежный механизм для
                формирования уникальных первичных ключей. Однако как же нам воспользоваться этим
                механизмом? Как поместить получаемое от последовательности значение в поле
                первичного ключа?</para>
            <para>Для этого есть два способа — вставка первичного ключа на стороне клиента и на
                стороне сервера. Чтобы освоить первый способ, следует обратиться к главе "Создание
                приложений на Delphi с использованием FireDac", а чтобы понять второй — к главе
                "Триггеры". Здесь мы лишь кратко скажем, в чем заключается суть обоих
                способов.</para>
            <para>В случае формирования первичного ключа на клиенте происходит следующее. Когда
                сформирована запись, которая будет вставлена в базу данных, выполняется оператор
                    <code>NEXT VALUE FOR <replaceable>seq_name</replaceable></code> или вызов
                функции <code>GEN_ID(<replaceable>seq_name</replaceable>, 1)</code> и полученное
                значение подставляется в сформированную запись. Происходит вставка в таблицу, при
                этом мы получаем гарантированно уникальный первичный ключ.</para>
            <para>Второй способ — формирование первичного ключа на стороне сервера — вообще
                исключает всякую заботу на стороне клиента о том, каково будет значение первичного
                ключа. В этом случае при вставке записи срабатывает триггер — специальный объект
                базы данных, который может осуществлять какие-либо действия при
                вставке/удалении/изменении записей в таблицах. И в этом триггере выполняется
                оператор <code>NEXT VALUE FOR <replaceable>seq_name</replaceable></code> или вызов
                функции <code>GEN_ID(<replaceable>seq_name</replaceable>, 1)</code>, полученное
                значение последовательности присваивается нужному столбцу.</para>
            <para>Достоинством второго способа является то, что при разработке клиентского
                приложения совершенно не надо заботиться о формировании первичного ключа, достаточно
                лишь раз написать нужный триггер. Для получения значения сформированного ключа в
                клиентском приложении мы можем воспользоваться предложением RETURNING, которое
                необходимо дописать к INSERT запросу. В этом случае INSERT запрос к таблице
                Table_example будет выглядеть так:
                <programlisting language="sql">
INSER INTO Table_example(NAME)
VALUES (:NAME)
RETURNING ID
            </programlisting>
            </para>
            <note>
                <para>Предложение RETURNING должно поддерживаться компонентами доступа. Старые
                    версии компонентов могут не поддерживать это предложение.</para>
            </note>
            <para>Какой способ лучше — однозначно сказать нельзя, все зависит от конкретной задачи,
                но возможные варианты разрешения вопросов работы с первичным ключом будут еще не раз
                затронуты далее в этой книге.</para>
        </section>
        <section>
            <title>Столбцы идентификации</title>

            <para>Столбец идентификации представляет собой столбец, связанный с внутренним
                генератором последовательностей. Его значение устанавливается автоматически каждый
                раз, когда оно не указано в операторе INSERT. Это очень описанный выше способ когда
                значение последовательности получают в триггере и присваивают его столбцу. Столбцы
                идентификации доступны начиная с Firebird 3.0. Их синтаксис описан ранее в операторе
                CREATE TABLE.</para>
            <para>Для получения значения сформированного ключа в клиентском приложении мы можем
                воспользоваться предложением RETURNING, которое необходимо дописать к INSERT
                запросу. Пример того как это сделать показан выше.</para>
        </section>
        <section>
            <title>Использование UUID для первичных ключей</title>

            <para>В качестве первичного ключа вы можете использовать глобальный уникальный
                идентификатор. Достоинством таких ключей является. то что они являются уникальными в
                распределённой системе, что позволяет построить мульти-мастер репликацию. Основным
                недостатком таких ключей является увеличение размера индекса по сравнению с ключами
                на основе целочисленных значений.</para>

            <para>Вы можете генерировать значение таких ключей как на клиентской стороне так и на
                сервере. Для генерации уникального идентификатора на стороне сервера существует
                встроенная функция GEN_UUID. Эта функция возвращает универсальный уникальный
                идентификатор ID в виде 16-байтной строки символов, отвечающий требованиям стандарта
                RFC-4122. Функция возвращает строку UUID 4-ой версии, где несколько битов
                зарезервированы, а остальные являются случайными. Данная функция возвращает
                результат с типом <code>CHAR(16) CHARACTER SET OCTETS</code>, поэтому столбец
                первичного ключа должен быть объявлен с таким же типом.</para>

            <para>В Firebird есть функция UUID_TO_CHAR, которая конвертирует 16-ти байтный UUID в
                его 36-ти знаковое ASCII человекочитаемое представление. Есть и обратная функция
                CHAR_TO_UUID, которая преобразует читабельную 36-ти символьную символику UUID к
                соответствующему 16-ти байтовому значению UUID. </para>
        </section>

    </section>
    <section>
        <title>Глобальные временные таблицы</title>

        <para>Ранее мы упоминали о глобальных временных таблицах. Теперь настало время рассмотреть
            их чуть подробнее. Глобальные временные таблицы (в дальнейшем сокращённо
                <abbrev>GTT</abbrev>) так же, как и обычные таблицы, являются постоянными
            метаданными, но данные в них ограничены по времени существования транзакцией (значение
            по умолчанию) или соединением с БД. Каждая транзакция или соединение имеет свой
            собственный экземпляр GTT с данными, изолированный от всех остальных. Экземпляры
            создаются только при условии обращения к GTT, и данные в ней удаляются при завершении
            транзакции или отключении от БД. Метаданные GTT могут быть изменены или удалены с
            помощью инструкций ALTER TABLE и DROP TABLE.</para>
        <para>Приведём сокращённый синтаксис создания GTT:
            <programlisting>
CREATE GLOBAL TEMPORARY TABLE <replaceable>name</replaceable>
  (<replaceable>&lt;column_def&gt;</replaceable> [, {<replaceable>&lt;column_def&gt;</replaceable> | <replaceable>&lt;table_constraint&gt;</replaceable>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]                  
                </programlisting>
        </para>
        <para>Если в операторе создания глобальной временной таблицы указано необязательное
            предложение <database>ON COMMIT DELETE ROWS</database>, то будет создана GTT
            транзакционного уровня (по умолчанию). При указании предложения <database>ON COMMIT
                PRESERVE ROWS</database> — будет создана GTT уровня соединения с базой
            данных.</para>
        <para>Предложение EXTERNAL [FILE] нельзя использовать для глобальной временной
            таблицы.</para>
        <para>GTT обладают всеми атрибутами обычных таблиц (ключи, внешние ключи, индексы и
            триггеры), но имеют ряд ограничений:</para>
        <para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>GTT и обычные таблицы не могут ссылаться друг на друга;</para>
                </listitem>
                <listitem>
                    <para>GTT уровня соединения (<quote>PRESERVE ROWS</quote>) GTT не могут
                        ссылаться на GTT транзакционного уровня (<quote>DELETE ROWS</quote>);</para>
                </listitem>
                <listitem>
                    <para>Ограничения домена не могут ссылаться на любую GTT;</para>
                </listitem>
                <listitem>
                    <para>Уничтожения экземпляра GTT в конце своего жизненного цикла не вызывает
                        срабатывания триггеров до/после удаления.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Разработчики информационных систем по разному применяют GTT. Одни использует их для
            промежуточных вычислений в качестве буфера в хранимых процедурах, другие — в качестве
            списка значений для фильтрации. Вы сами можете придумать и другие применения. </para>
        <para>Давайте посмотрим примеры создания различных типов глобальных временных таблиц.</para>
        <para>В примере ниже создаётся глобальная временных таблица уровня соединения:
            <programlisting language="sql">
CREATE GLOBAL TEMPORARY TABLE MYCONNGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP);
ON COMMIT PRESERVE ROWS;                   
                </programlisting>
        </para>
        <para>А теперь создадим глобальную временную таблицу уровня транзакции ссылающейся внешним
            ключом на глобальную временную таблицу уровня соединения.
            <programlisting language="sql">
CREATE GLOBAL TEMPORARY TABLE MYTXGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    PARENT_ID INTEGER NOT NULL REFERENCES MYCONNGTT(ID),
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP);                  
                </programlisting>
        </para>
        <para>Для модификации и удаления временных таблиц используются те же операторы что и для
            обычных таблиц.</para>
    </section>
    <section>
        <title>Заключение</title>

        <para>Итак, в этой главе мы рассмотрели, как создавать и модифицировать таблицы в Firebird,
            а также как обращаться с первичными ключами. Таким образом, мы рассмотрели главные
            объекты в Firebird, которые можно условно назвать статическими, поскольку они только
            хранят информацию и не осуществляют ее преобразования. Далее мы поведем разговор о
            методах контроля за информацией и о преобразовании информации внутри базы данных.</para>
    </section>
</chapter>
