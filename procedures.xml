<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="procedures" xml:lang="ru">
    <info>
        <title>Хранимые процедуры</title>
    </info>
    <para>Предметом этой главы является один из наиболее мощных инструментов, предлагаемых
        разработчикам приложений баз данных Firebird для реализации бизнес-логики. Хранимые
        процедуры (англ. stored procedures) позволяют реализовать значительную часть логики
        приложения на уровне базы данных и таким образом повысить производительность всего
        приложения, централизовать обработку данных и уменьшить количество кода, необходимого для
        выполнения поставленных задач. Практически любое достаточно сложное приложение баз данных не
        обходится без использования хранимых процедур</para>
    <para>Помимо этих широко известных преимуществ использования хранимых процедур, общих для
        большинства реляционных СУБД, хранимые процедуры Firebird могут играть роль практически
        полноценных наборов данных, что позволяет использовать возвращаемые ими результаты в обычных
        SQL-запросах.</para>
    <para>Часто начинающие разработчики представляют себе хранимые процедуры просто как набор
        специфических SQL-запросов, которые что-то делают внутри базы данных, причем бытует мнение,
        что работать с хранимыми процедурами намного сложнее, чем реализовать ту же функциональность
        в клиентском приложении, на языке высокого уровня. </para>
    <para>Так что же такое хранимые процедуры в Firebird?</para>
    <para>Хранимая процедура (ХП) — это часть метаданных базы данных, представляющая собой
        откомпилированную во внутреннее представление Firebird подпрограмму, написанную на
        специальном языке, компилятор которого встроен в ядро сервера Firebird.</para>
    <para>Хранимую процедуру можно вызывать из клиентских приложений, из триггеров, хранимых функций
        и других хранимых процедур. Хранимая процедура выполняется внутри серверного процесса и
        может манипулировать данными в базе данных, а также возвращать вызвавшему ее клиенту (т. е.
        триггеру, ХП, функции, приложению) результаты своего выполнения.</para>
    <para>Основой мощных возможностей, заложенных в ХП, является процедурный язык программирования,
        имеющий в своем составе как модифицированные предложения обычного SQL, такие, как INSERT,
        UPDATE и SELECT, так и средства организации ветвлений и циклов (IF, WHILE), а также средства
        обработки ошибок и исключительных ситуаций. Кроме того, вы можете выполнять динамический
        SQL, обращаться к другим базам данных и выполнять часть операторов в автономных транзакциях.
        Язык хранимых процедур позволяет реализовать сложные алгоритмы работы с данными, а благодаря
        ориентированности на работу с реляционными данными ХП получаются значительно компактнее
        аналогичных процедур на традиционных языках. </para>
    <para>Надо отметить, что и для триггеров используется этот же язык программирования, за
        исключением ряда особенностей и ограничений. Отличия подмножества языка, используемого в
        триггерах, от языка ХП подробно рассмотрены в главе "Триггеры". </para>

    <section>
        <title>Пример простой хранимой процедуры</title>

        <para>Настало время создать первую хранимую процедуру и на ее примере изучить процесс
            создания хранимых процедур. Но для начала следует сказать несколько слов о том, как
            работать с хранимыми процедурами. Дело в том, что своей славой малопонятного и
            неудобного инструмента ХП обязаны чрезвычайно бедным стандартным средствам разработки и
            отладки хранимых процедур. В документации по Firebird рекомендуется создавать процедуры
            с помощью файлов SQL скриптов, содержащих текст ХП, которые подаются на вход
            интерпретатору isql, и таким образом производить создание и модификацию ХП. Если в этом
            SQL-скрипте на этапе компиляции текста процедуры в BLR (о BLR см. главу "Структура базы
            данных Firebird") возникнет ошибка, то isql выведет сообщение о том, на какой строке
            файла SQL-скрипта возникла эта ошибка. Исправляйте ошибку и повторяйте все сначала. Про
            отладку в современном понимании этого слова, т. е. о трассировке выполнения, с
            возможностью посмотреть промежуточные значения переменных, речь вообще не идет.
            Очевидно, что такой подход не способствует росту привлекательности хранимых процедур в
            глазах разработчика. </para>

        <para>Однако помимо стандартного минималистского подхода к разработке ХП существуют также
            инструменты сторонних разработчиков, которые делают работу с хранимыми процедурами
            весьма удобной. Большинство универсальных продуктов для работы с Firebird, перечисленных
            в приложении "Инструменты администратора и разработчика Firebird", предоставляют удобный
            инструментарий для работы с ХП. Мы рекомендуем обязательно воспользоваться одним из этих
            инструментов для работы с хранимыми процедурами и изложение материала будем вести в
            предположении, что у вас имеется удобный GUI-инструмент, избавляющий от написания
            традиционных SQL-скриптов.</para>

        <para>Синтаксис хранимых процедур описывается следующим образом:
            <programlisting>
{CREATE [OR ALTER] | RECREATE} PROCEDURE <replaceable>procname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])    
  { EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> }  | 
  { AS       
      [<replaceable>&lt;declarations&gt;</replaceable>]       
    BEGIN       
      [<replaceable>&lt;compound_statement&gt;</replaceable>]      
      [<replaceable>&lt;compound_statement&gt;</replaceable> ...]  
    END
  }   
  
<replaceable>&lt;inparam&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> [{= | DEFAULT} <replaceable>&lt;value&gt;</replaceable>]  

<replaceable>&lt;outparam&gt;</replaceable>  ::=  <replaceable>&lt;param_decl&gt;</replaceable>  
                    
<replaceable>&lt;value&gt;</replaceable> ::=  {<replaceable>literal</replaceable> | NULL | <replaceable>context_var</replaceable>} 
                    
<replaceable>&lt;param_decl&gt;</replaceable> ::= <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
                    
<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'    

<replaceable>&lt;type&gt;</replaceable> ::= <replaceable>&lt;datatype&gt;</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable> 
                    
<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} 
  | BOOLEAN 
  | {FLOAT | DOUBLE PRECISION} 
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])]                     

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
  <replaceable>&lt;declare_var&gt;</replaceable>; |      
  <replaceable>&lt;declare_cursor&gt;</replaceable>; |     
  <replaceable>&lt;declare_subfunc&gt;</replaceable> |     
  <replaceable>&lt;declare_subproc&gt;</replaceable> 
                
<replaceable>&lt;compound_statement&gt;</replaceable> ::= <replaceable>&lt;block&gt;</replaceable> | <replaceable>&lt;statement&gt;</replaceable>  
                
<replaceable>&lt;block&gt;</replaceable> ::=  
    BEGIN       
      [<replaceable>&lt;compound_statement&gt;</replaceable>]      
      [<replaceable>&lt;compound_statement&gt;</replaceable> ...]  
    END                
                       </programlisting>
        </para>
        <para>Итак исходя из синтаксиса можно увидеть что хранимая процедура может быть написана на
            языке PSQL или на любом другом внешнем языке программирования, такие процедуры
            называются внешними (см. предложение EXTERNAL). В последнем случае код процедуры
            находиться в компилируемых динамических библиотеках (dll или so). Эта возможность стала
            доступна начиная с Firebird 3.0. Внешние хранимые процедуры мы рассмотрим позже в главе
                "<link linkend="udr">Написание UDR</link>", а предметом данной главы является
            написание хранимых процедур на языке PSQL.</para>
        <para>Синтаксис создания хранимой процедуры выглядит довольно объемно и может быть даже
            громоздко, но на самом деле все очень просто. Для того чтобы постепенно освоить
            синтаксис, давайте будем рассматривать постепенно усложняющиеся примеры.</para>
        <para>Итак, вот пример очень простой хранимой процедуры, которая принимает на входе два
            числа, складывает их и возвращает полученный результат:
            <programlisting language="sql">
CREATE PROCEDURE SP_Add(
  first_arg DOUBLE PRECISION,
  second_arg DOUBLE PRECISION)
RETURNS (Result DOUBLE PRECISION)
AS
BEGIN
  Result = first_arg + second_arg;
  SUSPEND;
END            
        </programlisting>
        </para>
        <para>Как видите, все просто: после команды CREATE PROCEDURE указывается имя вновь
            создаваемой процедуры (которое должно быть уникальным в пределах базы данных) — в данном
            случае SP_Add, затем в скобках через запятую перечисляются входные параметры ХП —
            first_arg и second_arg — с указанием их типов. </para>
        <para>Список входных параметров является необязательной частью оператора CREATE PROCEDURE —
            бывают случаи, когда все данные для своей работы процедура получает посредством запросов
            к таблицам внутри тела процедуры.</para>
        <note>
            <para>В хранимых процедурах используются любые скалярные типы данных Firebird. В
                качестве типов данных разрешено использовать домены, а вот применение массивов не
                предусмотрено.</para>
        </note>
        <para>Далее идет ключевое слово RETURNS, после которого в скобках перечисляются возвращаемые
            параметры с указанием их типов — в данном случае только один — Result.</para>
        <para>Если процедура не должна возвращать параметры, то слово RETURNS и список возвращаемых
            параметров отсутствуют.</para>
        <para>После RETURNS указано ключевое слово AS. До ключевого слова AS идет <emphasis
                role="italic">заголовок</emphasis>, а после него — <emphasis role="italic"
                >тело</emphasis> процедуры.</para>
        <para>Тело хранимой процедуры представляет собой перечень локальных переменных (если они
            есть), явных курсоров, подпрограмм и составного оператора (блок операторов). Составной
            оператор определён при помощи операторных скобок BEGIN .. END. Он выполняется как одна
            единица кода. В хранимых процедурах и других PSQL модулях возможно присутствие
            произвольного количества блоков, как последовательных, так и вложенных друг в друга.
            Максимальная глубина ограничена 512 уровнями вложенности блоков. Все операторы за
            исключением блоков BEGIN ... END отделяются друг от друга точкой с запятой (;). Никакой
            другой символ не является допустимым терминатором операторов PSQL. В данном случае тело
            ХП очень простое — мы просто складываем два входных аргумента и присваиваем их результат
            выходному, а затем вызываем команду SUSPEND. Чуть позже мы разъясним суть действия этой
            команды, а пока лишь отметим, что она нужна для передачи возвращаемых параметров туда,
            откуда была вызвана хранимая процедура.</para>
    </section>
    <section>
        <title>Разделители в хранимых процедурах</title>

        <para>Обратите внимание, что оператор внутри процедуры заканчивается точкой с запятой (;).
            Как известно, точка с запятой является стандартным разделителем команд в SQL — она
            является сигналом интерпретатору SQL, что текст команды введен полностью и надо начинать
            его обрабатывать. Не получится ли так, что, обнаружив точку с запятой в середине ХП,
            интерпретатор SQL сочтет, что команда введена полностью и попытается выполнить часть
            хранимой процедуры? Это предположение не лишено смысла. Действительно, если создать
            файл, в который записать вышеприведенный пример, добавить команду соединения с базы
            данных и попытаться выполнить этот SQL-скрипт с помощью интерпретатора
                <application>isql</application>, то будет возвращена ошибка, связанная с
            неожиданным, по мнению интерпретатора, окончанием команды создания хранимой процедуры.
            Если создавать хранимые процедуры с помощью файлов SQL-скриптов, без использования
            специализированных инструментов разработчика Firebird, то необходимо перед каждой
            командой создания ХП (то же относится и к триггерам, функциям и пакетам) менять
            разделитель команд скрипта на другой символ, отличный от точки с запятой, а после текста
            ХП восстанавливать его обратно. Команда <application>isql</application>, изменяющая
            разделитель предложений SQL, выглядит так:
            <programlisting>
SET TERM <replaceable>&lt;new_term&gt;</replaceable><replaceable>&lt;old_term&gt;</replaceable>                        
        </programlisting>
        </para>
        <para>Для типичного случая создания хранимой процедуры это выглядит так:
            <programlisting language="sql">
SET TERM ^;
CREATE PROCEDURE some_procedure
…
END
^
SET TERM ;^                       
        </programlisting>
        </para>
    </section>
</chapter>
