<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="procedures" xml:lang="ru">
    <info>
        <title>Хранимые процедуры</title>
    </info>
    <para>Предметом этой главы является один из наиболее мощных инструментов, предлагаемых
        разработчикам приложений баз данных Firebird для реализации бизнес-логики. Хранимые
        процедуры (англ. stored procedures) позволяют реализовать значительную часть логики
        приложения на уровне базы данных и таким образом повысить производительность всего
        приложения, централизовать обработку данных и уменьшить количество кода, необходимого для
        выполнения поставленных задач. Практически любое достаточно сложное приложение баз данных не
        обходится без использования хранимых процедур</para>
    <para>Помимо этих широко известных преимуществ использования хранимых процедур, общих для
        большинства реляционных СУБД, хранимые процедуры Firebird могут играть роль практически
        полноценных наборов данных, что позволяет использовать возвращаемые ими результаты в обычных
        SQL-запросах.</para>
    <para>Часто начинающие разработчики представляют себе хранимые процедуры просто как набор
        специфических SQL-запросов, которые что-то делают внутри базы данных, причем бытует мнение,
        что работать с хранимыми процедурами намного сложнее, чем реализовать ту же функциональность
        в клиентском приложении, на языке высокого уровня. </para>
    <para>Так что же такое хранимые процедуры в Firebird?</para>
    <para>Хранимая процедура (ХП) — это часть метаданных базы данных, представляющая собой
        откомпилированную во внутреннее представление Firebird подпрограмму, написанную на
        специальном языке, компилятор которого встроен в ядро сервера Firebird.</para>
    <para>Хранимую процедуру можно вызывать из клиентских приложений, из триггеров, хранимых функций
        и других хранимых процедур. Хранимая процедура выполняется внутри серверного процесса и
        может манипулировать данными в базе данных, а также возвращать вызвавшему ее клиенту (т. е.
        триггеру, ХП, функции, приложению) результаты своего выполнения.</para>
    <para>Основой мощных возможностей, заложенных в ХП, является процедурный язык программирования,
        имеющий в своем составе как модифицированные предложения обычного SQL, такие, как INSERT,
        UPDATE и SELECT, так и средства организации ветвлений и циклов (IF, WHILE), а также средства
        обработки ошибок и исключительных ситуаций. Кроме того, вы можете выполнять динамический
        SQL, обращаться к другим базам данных и выполнять часть операторов в автономных транзакциях.
        Язык хранимых процедур позволяет реализовать сложные алгоритмы работы с данными, а благодаря
        ориентированности на работу с реляционными данными ХП получаются значительно компактнее
        аналогичных процедур на традиционных языках. </para>
    <para>Надо отметить, что и для триггеров используется этот же язык программирования, за
        исключением ряда особенностей и ограничений. Отличия подмножества языка, используемого в
        триггерах, от языка ХП подробно рассмотрены в главе "Триггеры". </para>

    <section>
        <title>Пример простой хранимой процедуры</title>

        <para>Настало время создать первую хранимую процедуру и на ее примере изучить процесс
            создания хранимых процедур. Но для начала следует сказать несколько слов о том, как
            работать с хранимыми процедурами. Дело в том, что своей славой малопонятного и
            неудобного инструмента ХП обязаны чрезвычайно бедным стандартным средствам разработки и
            отладки хранимых процедур. В документации по Firebird рекомендуется создавать процедуры
            с помощью файлов SQL скриптов, содержащих текст ХП, которые подаются на вход
            интерпретатору isql, и таким образом производить создание и модификацию ХП. Если в этом
            SQL-скрипте на этапе компиляции текста процедуры в BLR (о BLR см. главу "Структура базы
            данных Firebird") возникнет ошибка, то isql выведет сообщение о том, на какой строке
            файла SQL-скрипта возникла эта ошибка. Исправляйте ошибку и повторяйте все сначала. Про
            отладку в современном понимании этого слова, т. е. о трассировке выполнения, с
            возможностью посмотреть промежуточные значения переменных, речь вообще не идет.
            Очевидно, что такой подход не способствует росту привлекательности хранимых процедур в
            глазах разработчика. </para>

        <para>Однако помимо стандартного минималистского подхода к разработке ХП существуют также
            инструменты сторонних разработчиков, которые делают работу с хранимыми процедурами
            весьма удобной. Большинство универсальных продуктов для работы с Firebird, перечисленных
            в приложении "Инструменты администратора и разработчика Firebird", предоставляют удобный
            инструментарий для работы с ХП. Мы рекомендуем обязательно воспользоваться одним из этих
            инструментов для работы с хранимыми процедурами и изложение материала будем вести в
            предположении, что у вас имеется удобный GUI-инструмент, избавляющий от написания
            традиционных SQL-скриптов.</para>

        <para>Синтаксис хранимых процедур описывается следующим образом:
            <programlisting>
{CREATE [OR ALTER] | RECREATE} PROCEDURE <replaceable>procname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])    
  { EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> }  | 
  { AS       
      [<replaceable>&lt;declarations&gt;</replaceable>]       
    BEGIN       
      [<replaceable>&lt;compound_statement&gt;</replaceable>]      
      [<replaceable>&lt;compound_statement&gt;</replaceable> ...]  
    END
  }   
  
<replaceable>&lt;inparam&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> [{= | DEFAULT} <replaceable>&lt;value&gt;</replaceable>]  

<replaceable>&lt;outparam&gt;</replaceable>  ::=  <replaceable>&lt;param_decl&gt;</replaceable>  
                    
<replaceable>&lt;value&gt;</replaceable> ::=  {<replaceable>literal</replaceable> | NULL | <replaceable>context_var</replaceable>} 
                    
<replaceable>&lt;param_decl&gt;</replaceable> ::= <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
                    
<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'    

<replaceable>&lt;type&gt;</replaceable> ::= <replaceable>&lt;datatype&gt;</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable> 
                    
<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} 
  | BOOLEAN 
  | {FLOAT | DOUBLE PRECISION} 
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])]                     

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
  <replaceable>&lt;declare_var&gt;</replaceable>; |      
  <replaceable>&lt;declare_cursor&gt;</replaceable>; |     
  <replaceable>&lt;declare_subfunc&gt;</replaceable> |     
  <replaceable>&lt;declare_subproc&gt;</replaceable> 
                
<replaceable>&lt;compound_statement&gt;</replaceable> ::= <replaceable>&lt;block&gt;</replaceable> | <replaceable>&lt;statement&gt;</replaceable>  
                
<replaceable>&lt;block&gt;</replaceable> ::=  
    BEGIN       
      [<replaceable>&lt;compound_statement&gt;</replaceable>]      
      [<replaceable>&lt;compound_statement&gt;</replaceable> ...]  
    END                
                       </programlisting>
        </para>
        <para>Итак исходя из синтаксиса можно увидеть что хранимая процедура может быть написана на
            языке PSQL или на любом другом внешнем языке программирования, такие процедуры
            называются внешними (см. предложение EXTERNAL). В последнем случае код процедуры
            находиться в компилируемых динамических библиотеках (dll или so). Эта возможность стала
            доступна начиная с Firebird 3.0. Внешние хранимые процедуры мы рассмотрим позже в главе
                "<link linkend="udr">Написание UDR</link>", а предметом данной главы является
            написание хранимых процедур на языке PSQL.</para>
        <para>Синтаксис создания хранимой процедуры выглядит довольно объемно и может быть даже
            громоздко, но на самом деле все очень просто. Для того чтобы постепенно освоить
            синтаксис, давайте будем рассматривать постепенно усложняющиеся примеры.</para>
        <para>Итак, вот пример очень простой хранимой процедуры, которая принимает на входе два
            числа, складывает их и возвращает полученный результат:
            <programlisting language="sql">
CREATE PROCEDURE SP_Add(
  first_arg DOUBLE PRECISION,
  second_arg DOUBLE PRECISION)
RETURNS (Result DOUBLE PRECISION)
AS
BEGIN
  Result = first_arg + second_arg;
  SUSPEND;
END            
        </programlisting>
        </para>
        <para>Как видите, все просто: после команды CREATE PROCEDURE указывается имя вновь
            создаваемой процедуры (которое должно быть уникальным в пределах базы данных) — в данном
            случае SP_Add, затем в скобках через запятую перечисляются входные параметры ХП —
            first_arg и second_arg — с указанием их типов. </para>
        <para>Список входных параметров является необязательной частью оператора CREATE PROCEDURE —
            бывают случаи, когда все данные для своей работы процедура получает посредством запросов
            к таблицам внутри тела процедуры.</para>
        <note>
            <para>В хранимых процедурах используются любые скалярные типы данных Firebird. В
                качестве типов данных разрешено использовать домены, а вот применение массивов не
                предусмотрено.</para>
        </note>
        <para>Далее идет ключевое слово RETURNS, после которого в скобках перечисляются возвращаемые
            параметры с указанием их типов — в данном случае только один — Result.</para>
        <para>Если процедура не должна возвращать параметры, то слово RETURNS и список возвращаемых
            параметров отсутствуют.</para>
        <para>После RETURNS указано ключевое слово AS. До ключевого слова AS идет <emphasis
                role="italic">заголовок</emphasis>, а после него — <emphasis role="italic"
                >тело</emphasis> процедуры.</para>
        <para>Тело хранимой процедуры представляет собой перечень локальных переменных (если они
            есть), явных курсоров, подпрограмм и составного оператора (блок операторов). Составной
            оператор определён при помощи операторных скобок BEGIN .. END. Он выполняется как одна
            единица кода. В хранимых процедурах и других PSQL модулях возможно присутствие
            произвольного количества блоков, как последовательных, так и вложенных друг в друга.
            Максимальная глубина ограничена 512 уровнями вложенности блоков. Все операторы за
            исключением блоков BEGIN ... END отделяются друг от друга точкой с запятой (;). Никакой
            другой символ не является допустимым терминатором операторов PSQL. В данном случае тело
            ХП очень простое — мы просто складываем два входных аргумента и присваиваем их результат
            выходному, а затем вызываем команду SUSPEND. Чуть позже мы разъясним суть действия этой
            команды, а пока лишь отметим, что она нужна для передачи возвращаемых параметров туда,
            откуда была вызвана хранимая процедура.</para>
    </section>
    <section>
        <title>Разделители в хранимых процедурах</title>

        <para>Обратите внимание, что оператор внутри процедуры заканчивается точкой с запятой (;).
            Как известно, точка с запятой является стандартным разделителем команд в SQL — она
            является сигналом интерпретатору SQL, что текст команды введен полностью и надо начинать
            его обрабатывать. Не получится ли так, что, обнаружив точку с запятой в середине ХП,
            интерпретатор SQL сочтет, что команда введена полностью и попытается выполнить часть
            хранимой процедуры? Это предположение не лишено смысла. Действительно, если создать
            файл, в который записать вышеприведенный пример, добавить команду соединения с базы
            данных и попытаться выполнить этот SQL-скрипт с помощью интерпретатора
                <application>isql</application>, то будет возвращена ошибка, связанная с
            неожиданным, по мнению интерпретатора, окончанием команды создания хранимой процедуры.
            Если создавать хранимые процедуры с помощью файлов SQL-скриптов, без использования
            специализированных инструментов разработчика Firebird, то необходимо перед каждой
            командой создания ХП (то же относится и к триггерам, функциям и пакетам) менять
            разделитель команд скрипта на другой символ, отличный от точки с запятой, а после текста
            ХП восстанавливать его обратно. Команда <application>isql</application>, изменяющая
            разделитель предложений SQL, выглядит так:
            <programlisting>
SET TERM <replaceable>&lt;new_term&gt;</replaceable><replaceable>&lt;old_term&gt;</replaceable>                        
        </programlisting>
        </para>
        <para>Для типичного случая создания хранимой процедуры это выглядит так:
            <programlisting language="sql">
SET TERM ^;
CREATE PROCEDURE some_procedure
…
END
^
SET TERM ;^                       
        </programlisting>
        </para>
    </section>
    <section>
        <title>Вызов хранимой процедуры</title>

        <para>Но вернемся к нашей хранимой процедуре. Теперь, когда она создана, ее надо как-то
            вызвать, передать ей параметры и получить возвращаемые результаты. Это сделать очень
            просто — достаточно написать SQL-запрос следующего вида:
            <programlisting language="sql">
SELECT *
FROM Sp_add(181.35, 23.09)            
        </programlisting>
        </para>
        <para>Этот запрос вернет нам одну строку, содержащую всего одно поле
                <varname>Result</varname>, в котором будет находиться сумма чисел
                <literal>181.35</literal> и <literal>23.09</literal> т. е.
            <literal>204.44</literal>.</para>
        <para>Таким образом, нашу процедуру можно использовать в обычных SQL-запросах, выполняющихся
            как в клиентских программах, так и в других ХП или триггерах. Такое использование нашей
            процедуры стало возможным из-за применения оператора SUSPEND в конце хранимой
            процедуры.</para>
        <para>Дело в том, что в Firebird существуют два типа хранимых процедур: процедуры-выборки
            (selectable procedures) и исполняемые процедуры (executable procedures). Отличие в
            работе этих двух видов ХП заключается в том, что процедуры-выборки обычно возвращают
            множество наборов выходных параметров, сгруппированных построчно, которые имеют вид
            набора данных, а исполняемые процедуры могут либо вообще не возвращать параметры, либо
            возвращать только один набор выходных параметров, перечисленных в Returns, т. е. одну
            строку параметров. Процедуры-выборки вызываются в запросах SELECT, а исполняемые
            процедуры — с помощью оператора EXECUTE PROCEDURE.</para>
        <para>Оба вида хранимых процедур имеют одинаковый синтаксис создания и формально ничем не
            отличаются, поэтому любая исполнимая процедура, имеющая выходные параметры, может быть
            вызвана в SELECT-запросе и любая процедура-выборка — с помощью EXECUTE PROCEDURE. Вопрос
            в том, как поведут себя ХП при разных типах вызова. Другими словами, разница заключается
            в проектировании процедуры для определенного типа вызова. То есть процедура-выборка
            специально создается для вызова из запроса SELECT, а исполняемая процедура — для вызова
            с использованием EXECUTE PROCEDURE. Давайте рассмотрим, в чем же заключаются отличия при
            проектировании этих двух видов ХП.</para>
        <para>Для того чтобы понять, как работает процедура-выборка, придется немного углубиться в
            теорию. Давайте представим себе обычный SQL-запрос вида SELECT ID, NAME FROM
            Table_example. В результате его выполнения мы получаем на выходе таблицу, состоящую из
            двух столбцов (ID и NAME) и некоторого количества строк (равного количеству строк в
            таблице Table_example). Возвращаемая в результате этого запроса таблица называется также
            набором данных SQL. Задумаемся же, как формируется набор данных во время выполнения
            этого запроса. Сервер, получив запрос, определяет, к каким таблицам он относится, затем
            выясняет, какое подмножество записей из этих таблиц необходимо включить в результат
            запроса. Далее сервер считывает каждую запись, удовлетворяющую результатам запроса,
            выбирает из нее нужные поля (в нашем случае это ID и NAME) и отсылает их клиенту. Затем
            процесс повторяется снова — и так для каждой отобранной записи.</para>
        <para>Все это отступление нужно для того, чтобы уважаемый читатель понял, что все наборы
            данных SQL формируются построчно, в том числе и в хранимых процедурах! И основное
            отличие процедур-выборок от исполняемых процедур в том, что первые спроектированы для
            возвращения множества строк, а вторые — только для одной. Поэтому они и применяются
            по-разному: процедура-выборка вызывается при помощи команды SELECT, которая "требует" от
            процедуры отдать все записи, которая она может вернуть. Исполняемая процедура вызывается
            с помощью EXECUTE PROCEDURE, которая "вынимает" из ХП только одну строку, а остальные
            (даже если они есть!) игнорирует.</para>
        <para>Давайте рассмотрим пример процедуры-выборки, чтобы было понятнее. Для упрощения
            создадим хранимую процедуру, которая работает точно так же, как запрос SELECT ID, NAME
            FROM Table_Example, т. е. она просто делает выборку полей ID и NAME из всей таблицы. Вот
            этот пример:
            <programlisting language="sql">
CREATE PROCEDURE Simple_Select_SP 
RETURNS (
    procID INTEGER,
    procNAME VARCHAR(80))
AS
BEGIN
  FOR
    SELECT ID, NAME FROM table_example
    INTO :procID, :procNAME
  DO
  BEGIN
    SUSPEND;
  END
END            
        </programlisting>
        </para>
        <para>Давайте разберем действия этой процедуры, названной Simple_Select_SP. Как видите, она
            не имеет входных параметров и имеет два выходных параметра – ID и NAME. Самое
            интересное, конечно, заключено в теле процедуры. Здесь использована конструкция FOR
            SELECT:
            <programlisting language="sql">
FOR
    SELECT ID, NAME FROM table_example
    INTO :procID, :procNAME
  DO
BEGIN
   /*что-то делаем с переменными procID и procName*/	
END        
        </programlisting>
        </para>
        <para>Этот кусочек кода означает следующее: для каждой строки, выбранной из таблицы
            Table_example, поместить выбранные значения в переменные procID и procName, а затем
            произвести какие-то действия с этими переменными. Вы можете сделать удивленное лицо и
            спросить: "Переменные? Какие еще переменные?" Это нечто вроде сюрприза этой главы — то,
            что в хранимых процедурах мы можем использовать переменные. В языке ХП можно объявлять
            как собственные локальные переменные внутри процедуры, так и использовать входные и
            выходные параметры в качестве переменных. </para>
        <para>Для того чтобы объявить локальную переменную в хранимой процедуре, необходимо
            поместить ее описание после ключевого слова AS и до первого слова BEGIN. Описание
            локальной переменной выглядит так:
            <programlisting>
DECLARE [VARIABLE] <replaceable>&lt;variable_name&gt;</replaceable> <replaceable>&lt;variable_type&gt;</replaceable> 
  [NOT NULL] [COLLATE <replaceable>&lt;collation&gt;</replaceable>] [{= | DEFAULT} <replaceable>&lt;literal&gt;</replaceable>] };           
        </programlisting>
        </para>
        <para>Например, чтобы объявить целочисленную локальную переменную MyInt, нужно вставить
            между AS и BEGIN следующее описание:
            <programlisting language="sql">
DECLARE VARIABLE MyInt INTEGER;            
        </programlisting>
        </para>
        <para>Переменные в нашем примере начинаются с двоеточия. Это сделано потому, что обращение к
            ним идет внутри SQL-команды FOR SELECT, поэтому для различения полей в таблицах, которые
            используются в SELECT, и переменных необходимо предварять последние двоеточием. Ведь
            переменные могут иметь точно такое же название, как и поля в таблицах!</para>
        <para>Но двоеточие перед именем переменной необходимо использовать только внутри
            SQL-запросов. Вне текстов обращение к переменной делается без двоеточия, например:
            <programlisting language="sql">
procName='Some name';            
        </programlisting>
        </para>
        <para>Но вернемся к телу нашей процедуры. Предложение FOR SELECT возвращает данные не в виде
            таблицы — набора данных, а по одной строчке. Каждое возвращаемое поле должно быть
            помещено в свою переменную: ID => procID, NAME => procName. В части DO эти переменные
            посылаются клиенту, вызвавшему процедуру, с помощью команды SUSPEND.</para>
        <para>Таким образом, команда FOR SELECT… DO организует цикл по записям, выбираемым в части
            SELECT этой команды. В теле цикла, образуемого частью DO, выполняется передача очередной
            сформированной записи клиенту с помощью команды SUSPEND.</para>
        <para>Итак, процедура-выборка предназначена для возвращения одной или более строк, для чего
            внутри тела ХП организуется цикл, заполняющий результирующие параметры-переменные. И в
            конце тела этого цикла обязательно стоит команда SUSPEND, которая вернет очередную
            строку данных клиенту. </para>
    </section>
    <section>
        <title>Циклы и операторы ветвления</title>

        <para>Помимо команды FOR SELECT... DO, организующей цикл по записям какой-либо выборки,
            существует другой вид цикла — WHILE...DO, который позволяет организовать цикл на основе
            проверки любых условий. Вот пример ХП, использующей цикл WHILE…DO. Эта процедура
            возвращает квадраты целых чисел от 0 до 99: <programlisting language="sql">
<![CDATA[            
CREATE PROCEDURE QUAD 
RETURNS (QUADRAT INTEGER)
AS
DECLARE VARIABLE I INTEGER;
BEGIN
  I=1;
  WHILE (i<100) DO
   BEGIN
      QUADRAT= I*I;
       I=I+1;
      SUSPEND;
   END
END
]]>            
        </programlisting>
        </para>
        <para>В результате выполнения запроса SELECT * FROM QUAD мы получим таблицу, содержащую один
            столбец QUADRAT, в котором будут квадраты целых чисел от 1 до 99.</para>
        <para>Помимо перебора результатов SQL-выборки и классического цикла, в языке хранимых
            процедур используется оператор IF...THEN..ELSE, позволяющий организовать ветвление в
            зависимости от выполнения каких-либо условий. Его синтаксис похож на большинство
            операторов ветвления в языках программирования высокого уровня, вроде Паскаля и
            Си.</para>
        <para>Давайте рассмотрим более сложный пример хранимой процедуры, которая делает следующее: <orderedlist>
                <listitem>
                    <para>Вычисляет среднюю цену в таблице Table_example (см. глава
                        "<?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?>Таблицы.
                        Первичные ключи и генераторы<?oxy_custom_end?>").</para>
                </listitem>
                <listitem>
                    <para>Далее для каждой записи в таблице делает следующую проверку: если
                        существующая цена (PRICE) больше средней цены, то устанавливает цену, равную
                        величине средней цены, плюс задаваемый фиксированный процент.</para>
                </listitem>
                <listitem>
                    <para>Если существующая цена меньше или равна средней цене, то устанавливает
                        цену, равную прежней цене, плюс половина разницы между прежней и средней
                        ценой.</para>
                </listitem>
                <listitem>
                    <para>Возвращает все измененные строки в таблице.</para>
                </listitem>
            </orderedlist></para>
        <para>Для начала определим имя ХП, а также входные и выходные параметры. Все это
            прописывается в заголовке хранимой процедуры:
            <programlisting language="sql">
CREATE PROCEDURE IncreasePrices (
  Percent2Increase DOUBLE PRECISION)
RETURNS (
  ID INTEGER, 
  NAME VARCHAR(80), 
  new_price DOUBLE PRECISION) 
AS           
        </programlisting>
        </para>
        <para>Процедура будет называться IncreasePrices, у нее один входной параметр
            Percent2Increase, имеющий тип DOUBLE PRECISION, и 3 выходных параметра – ID, NAME и
            new_price. Обратите внимание, что первые два выходных параметра имеют такие же имена,
            как и поля в таблице Table_example, с которой мы собираемся работать. Это допускается
            правилами языка хранимых процедур. Теперь мы должны объявить локальную переменную,
            которая будет использоваться для хранения среднего значения. Это объявление будет
            выглядеть следующим образом:
            <programlisting language="sql">
DECLARE VARIABLE avg_price DOUBLE PRECISION;            
        </programlisting>
        </para>
        <para>Теперь перейдем к телу хранимой процедуры. Откроем тело ХП ключевым словом BEGIN. </para>
        <para>Сначала нам необходимо выполнить первый шаг нашего алгоритма — вычислить среднюю цену.
            Для этого мы воспользуемся запросом следующего вида:
            <programlisting language="sql">
SELECT AVG(Price_1)
FROM Table_Example
INTO :avg_price;            
        </programlisting>
        </para>
        <para>Этот запрос использует агрегатную функцию AVG, которая возвращает среднее значение
            поля PRICE_1 среди отобранных строк запроса — в нашем случае среднее значение PRICE_1 по
            всей таблице Table_example. Возвращаемое запросом значение помещается в переменную
            avg_price. Обратите внимание, что переменная avg_price предваряется двоеточием — для
            того, чтобы отличить ее от полей, используемых в запросе.</para>
        <para>Особенностью данного запроса является то, что он всегда возвращает строго
            одну-единственную запись. Такие запросы называются singleton-запросами. И только такие
            выборки можно использовать в хранимых процедурах. Если запрос возвращает более одной
            строки, то его необходимо оформить в виде конструкции FOR SELECT...DO, которая
            организует цикл для обработки каждой возвращаемой строки.</para>
        <para>Итак, мы получили среднее значение цены. Теперь необходимо пройтись по всей таблице,
            сравнить значение цены в каждой записи со средней ценой и предпринять соответствующие
            действия.</para>
        <para>Сначала организуем перебор каждой записи из таблицы Table_example:
            <programlisting language="sql">
FOR 
    SELECT ID, NAME, PRICE_1
    FROM Table_Example
    INTO :ID, :NAME, :new_price
DO
BEGIN
  /*здесь обрабатываем каждую запись*/
END         
        </programlisting>
        </para>
        <para>При выполнении этой конструкции из таблицы Table_example построчно будут выниматься
            данные и значения полей в каждой строке будут присвоены переменным ID, NAME и new_price.
            Вы, конечно, помните, что эти переменные объявлены как выходные параметры, но
            беспокоиться, что выбранные данные будут возвращены как результаты, не стоит: тот факт,
            что выходным параметрам что-либо присвоено, не означает, что вызывающий ХП клиент
            немедленно получит эти значения! Передача параметров осуществляется только при
            исполнении команды SUSPEND, а до этого мы можем использовать выходные параметры в
            качестве обычных переменных – в нашем примере мы именно так и делаем с параметром
            new_price.</para>
        <para>Итак, внутри тела цикла BEGIN…END мы можем обработать значения каждой строки. Как вы
            помните, нам необходимо выяснить, как существующая цена соотносится со средней, и
            предпринять соответствующие действия. Эту процедуру сравнения мы реализуем с помощью
            оператора IF: <programlisting language="sql">
<![CDATA[
IF (new_price > avg_price) THEN /*если существующая цена больше средней цены*/
BEGIN
  /*то установим новую цену, равную величине средней цены, плюс фиксированный процент */
  new_price = (avg_price + avg_price*(Percent2Increase/100));
  
  UPDATE Table_example
  SET PRICE_1 = :new_price
  WHERE ID = :ID;
END
ELSE 
BEGIN
  /* Если существующая цена меньше или равна средней цене, то установим цену, 
     равную прежней цене, плюс половина разницы между прежней и средней ценой */
  new_price = (new_price + ((avg_price - new_price)/2));
  
  UPDATE Table_example
  SET PRICE_1 = :new_price
  WHERE ID = :ID;
END
]]>    
        </programlisting>
        </para>
        <para>Как видите, получилось достаточно большая конструкция IF, в которой трудно было бы
            разобраться, если бы не комментарии, заключенные в символы <code language="sql"
                >/**/</code>. </para>
        <para>Для того чтобы изменить цену в соответствии с вычисленной разницей, мы воспользуемся
            оператором UPDATE, который позволяет модифицировать существующие записи – одну или
            несколько. Для того чтобы однозначно указать, в какой записи нужно изменять цену, мы
            используем в условии WHERE поле первичного ключа, сравнивая его со значением переменной,
            в которой хранится значение ID для текущей записи: <code>ID=:ID</code>. Обратите
            внимание, что переменная ID предваряется двоеточием.</para>
        <para>После выполнения конструкции IF...THEN...ELSE в переменных ID, NAME и new_price
            находятся данные, которые мы должны возвратить клиенту, вызвавшему процедуру. Для этого
            после IF необходимо вставить команду SUSPEND, которая перешлет данные туда, откуда
            вызвали ХП. На время пересылки действие процедуры будет приостановлено, а когда от ХП
            потребуется новая запись, то она будет вновь продолжена, — и так будет продолжаться до
            тех пор, пока FOR SELECT...DO не переберет все записи своего запроса. </para>
        <para>Надо отметить, что помимо команды SUSPEND, которая только приостанавливает действие
            хранимой процедуры, существует команда EXIT, которая прекращает хранимую процедуру после
            передачи строки. Однако командой EXIT пользуются достаточно редко, поскольку она нужна в
            основном для того, чтобы прервать цикл при достижении какого-либо условия. </para>
        <para>При этом в случае, когда процедура вызывалась оператором SELECT и завершена по EXIT,
            последняя извлеченная строка не будет возвращена. То есть, если вам нужно прервать
            процедуру и все-таки получить эту строку, надо воспользоваться последовательностью
            <programlisting language="sql">
SUSPEND;
EXIT;            
        </programlisting>
        </para>
        <para>Основное назначение EXIT – получение singleton-наборов данных, возвращаемых параметров
            путем вызова через EXECUTE PROCEDURE. В этом случае устанавливаются значения выходных
            параметров, но из них не формируется набор данных SQL, и выполнение процедуры
            завершается. Давайте запишем текст нашей хранимой процедуры полностью, чтобы иметь
            возможность охватить ее логику одним взглядом: <programlisting language="sql">
<![CDATA[
CREATE PROCEDURE IncreasePrices (
  Percent2Increase DOUBLE PRECISION)
RETURNS (
  ID INTEGER, 
  NAME VARCHAR(80), 
  new_price DOUBLE PRECISION) 
AS
  DECLARE VARIABLE avg_price DOUBLE PRECISION;
BEGIN
  SELECT AVG(Price_1)
  FROM Table_Example
  INTO :avg_price;

  FOR 
      SELECT ID, NAME, PRICE_1
      FROM Table_Example
      INTO :ID, :NAME, :new_price
  DO
  BEGIN
    /*здесь обрабатываем каждую запись*/
    IF (new_price > avg_price) THEN /*если существующая цена больше средней цены*/
    BEGIN
      /*установим новую цену, равную величине средней цены, плюс фиксированный процент */
      new_price = (avg_price + avg_price*(Percent2Increase/100));
      
      UPDATE Table_example
      SET PRICE_1 = :new_price
      WHERE ID = :ID;
    END
    ELSE 
    BEGIN
      /* Если существующая цена меньше или равна средней цене, то устанавливает цену, равную прежней цене, плюс половина разницы между прежней и средней ценой */
      new_price = (new_price + ((avg_price - new_price)/2));
  
      UPDATE Table_example
      SET PRICE_1 = :new_price
      WHERE ID = :ID;
    END
    SUSPEND;
  END
END
]]>            
        </programlisting>
        </para>
        <para>Данный пример хранимой процедуры иллюстрирует применение основных конструкций языка
            хранимых процедур и триггеров. Далее мы рассмотрим способы применения хранимых процедур
            для решения некоторых часто возникающих задач.</para>
    </section>
    <section>
        <title>Курсоры</title>
        
        <para></para>
    </section>
    <section>
        <title>Рекурсивные хранимые процедуры</title>

        <para>Хранимые процедуры Firebird могут быть рекурсивными. Это означает, что из хранимой
            процедуры можно вызвать саму себя. Допускается до 1000 уровней вложенности хранимых
            процедур, однако надо помнить о том, что свободные ресурсы на сервере могут закончиться
            раньше, чем будет достигнута максимальная вложенность ХП.</para>

        <para>Одно из распространенных применений хранимых процедур — это обработка древовидных
            структур, хранящихся в базе данных. Деревья часто используются в задачах состава
            изделия, складских, кадровых и в других распространенных приложениях.</para>

        <para>Давайте рассмотрим пример хранимой процедуры, которая выбирает все товары
            определенного типа, начиная с определенного уровня вложенности. Пусть у нас есть
            следующая постановка задачи: имеем справочник товаров с иерархической структурой такого
            вида: <itemizedlist spacing="compact">
                <listitem>
                    <para>Товары<itemizedlist spacing="compact">
                            <listitem>
                                <para>Бытовая техника<itemizedlist spacing="compact">
                                        <listitem>
                                            <para>Холодильники<itemizedlist spacing="compact">
                                                  <listitem>
                                                  <para>Трёхкамерные</para>
                                                  </listitem>
                                                  <listitem>
                                                  <para>Двухкамерные</para>
                                                  </listitem>
                                                  <listitem>
                                                  <para>Однокамерные</para>
                                                  </listitem>
                                                </itemizedlist></para>
                                        </listitem>
                                        <listitem>
                                            <para>Стиральные машины<itemizedlist spacing="compact">
                                                  <listitem>
                                                  <para>Вертикальные</para>
                                                  </listitem>
                                                  <listitem>
                                                  <para>Фронтальные<itemizedlist spacing="compact">
                                                  <listitem>
                                                  <para>Классические</para>
                                                  </listitem>
                                                  <listitem>
                                                  <para>Узкие</para>
                                                  </listitem>
                                                  </itemizedlist></para>
                                                  </listitem>
                                                </itemizedlist></para>
                                        </listitem>
                                    </itemizedlist></para>
                            </listitem>
                            <listitem>
                                <para>Компьютерная техника</para>
                                <para>...</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
            </itemizedlist></para>
        <para>Эта структура справочника категорий товаров может иметь ветки различной глубины, а
            также нарастать со временем. Наша задача – обеспечить выборку всех конечных элементов из
            справочника с "разворачивание полного имени", начиная с любого узла. Например, если мы
            выбираем узел "Стиральные машины", то нам надо получить следующие категории:
                <itemizedlist spacing="compact">
                <listitem>
                    <para>Стиральные машины – Вертикальные</para>
                </listitem>
                <listitem>
                    <para>Стиральные машины – Фронтальные – Классические</para>
                </listitem>
                <listitem>
                    <para>Стиральные машины – Фронтальные – Узкие</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Определим структуру таблиц для хранения информации справочника товаров. Используем
            упрощенную схему для организации дерева в одной таблице:
            <programlisting language="sql">
CREATE TABLE GoodsTree (
  ID_GOOD INTEGER NOT NULL,
  ID_PARENT_GOOD INTEGER,
  GOOD_NAME VARCHAR(80),
  constraint pkGood primary key (ID_GOOD)
);       
        </programlisting>
        </para>
        <para>Создаем одну таблицу GoodsTree, в которой всего 3 поля: ID_GOOD – уникальный
            идентификатор категории, ID_PARENT_GOOD – идентификатор категории-родителя для данной
            категории и GOOD_NAME – наименование категории. Чтобы обеспечить целостность данных в
            этой таблице, наложим на эту таблицу ограничение внешнего ключа:
            <programlisting language="sql">
ALTER TABLE GoodsTree
ADD CONSTRAINT FK_goodstree
FOREIGN KEY (ID_PARENT_GOOD)
REFERENCES GOODSTREE(ID_GOOD);            
        </programlisting>
        </para>
        <para>Таблица ссылается сама на себя и данный внешний ключ следит за тем, чтобы в таблице не
            было ссылок на несуществующих родителей, а также препятствует попыткам удалить категории
            товаров, у которых есть потомки.</para>
        <para>Давайте занесем в нашу таблицу следующие данные: <informaltable frame="all">
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="1*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.3*"/>
                    <colspec colname="c3" colnum="3" colwidth="2.63*"/>
                    <thead>
                        <row>
                            <entry>ID_GOOD</entry>
                            <entry>ID_PARENT_GOOD</entry>
                            <entry>GOOD_NAME</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>1</entry>
                            <entry>NULL</entry>
                            <entry>GOODS</entry>
                        </row>
                        <row>
                            <entry>2</entry>
                            <entry>1</entry>
                            <entry>Бытовая техника </entry>
                        </row>
                        <row>
                            <entry>3</entry>
                            <entry>1</entry>
                            <entry>Компьютеры и комплектующие </entry>
                        </row>
                        <row>
                            <entry>4</entry>
                            <entry>2</entry>
                            <entry>Холодильники</entry>
                        </row>
                        <row>
                            <entry>5</entry>
                            <entry>2</entry>
                            <entry>Стиральные машины </entry>
                        </row>
                        <row>
                            <entry>6</entry>
                            <entry>4</entry>
                            <entry>Трехкамерные </entry>
                        </row>
                        <row>
                            <entry>7</entry>
                            <entry>4</entry>
                            <entry>Двухкамерные</entry>
                        </row>
                        <row>
                            <entry>8</entry>
                            <entry>4</entry>
                            <entry>Однокамерные </entry>
                        </row>
                        <row>
                            <entry>9</entry>
                            <entry>5</entry>
                            <entry>Вертикальные</entry>
                        </row>
                        <row>
                            <entry>10</entry>
                            <entry>5</entry>
                            <entry>Фронтальные</entry>
                        </row>
                        <row>
                            <entry>11</entry>
                            <entry>10</entry>
                            <entry>Узкие</entry>
                        </row>
                        <row>
                            <entry>12</entry>
                            <entry>10</entry>
                            <entry>Классические</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable></para>
        <para>Теперь, когда у нас есть место для хранения данных, мы можем приступить к созданию
            хранимой процедуры, выполняющей вывод всех "окончательных" категорий товаров в
            "развернутом" виде – например, для категории "Трехкамерные" полное имя категории будет
            выглядеть как "Бытовая техника Холодильники Трехкамерные".</para>
        <para>В хранимых процедурах, обрабатывающих древообразные структуры, сложилась своя
            терминология. Каждый элемент дерева называются узлом; а отношения между ссылающимися
            друг на друга узлами называется отношениями родитель-потомок. Узлы, находящиеся на самом
            конце дерева и не имеющие потомков, называются "листьями".</para>
        <para>У нашей хранимой процедуры входным параметром будет идентификатор категории, начиная с
            которого мы должны будем начать развертку. Хранимая процедура будет иметь следующий вид:
            <programlisting language="sql">
CREATE PROCEDURE GETFULLNAME (ID_GOOD2SHOW INTEGER)
RETURNS (
  FULL_GOODS_NAME VARCHAR(1000),
  ID_CHILD_GOOD INTEGER)  
AS
  DECLARE VARIABLE CURR_CHILD_NAME VARCHAR(80);
BEGIN
  /* Организуем внешний цикл FOR SELECT по непосредственным потомкам 
     товара с ID_GOOD=ID_GOOD2SHOW */
  FOR SELECT gt1.id_good, gt1.good_name
      FROM GoodsTree gt1
      WHERE gt1.id_parent_good=:ID_good2show
      INTO:ID_CHILD_GOOD, :full_goods_name
  DO
  BEGIN
    /* Проверка с помощью функции EXISTS, которая возвращает TRUE, 
      если запрос в скобках вернет хотя бы одну строку. Если у найденного узла 
      с ID_PARENT_GOOD = ID_CHILD_GOOD нет потомков, то он является "листом" 
      дерева и  попадает в результаты */
    IF (NOT EXISTS(
               SELECT * FROM GoodsTree
               WHERE GoodsTree.id_parent_good=:id_child_good))
    THEN
    BEGIN
      /* Передаем "лист" дерева в результаты */
      SUSPEND;
    END
    ELSE  /* Для узлов, у которых есть потомки */   
    BEGIN 
      /* сохраняем имя узла-родителя во временной переменной */
      CURR_CHILD_NAME=full_goods_name;
      /* рекурсивно запускаем эту процедуру */
      FOR 
        SELECT ID_CHILD_GOOD, full_goods_name
        FROM GETFULLNAME (:ID_CHILD_GOOD)
        INTO:ID_CHILD_GOOD, :full_goods_name
      DO BEGIN
        /* добавляем  имя узла-родителя к найденному имени потомка 
           с помощью операции конкатенации строк || */
        full_goods_name=CURR_CHILD_NAME||' '||full_goods_name;
        SUSPEND; /* возвращаем полное имя товара*/
      END 
    END
  END 
END
            
        </programlisting>
        </para>
        <para>Если мы выполним данную процедуру с входным параметром ID_GOOD2SHOW=1, то получим
            следующее: <informaltable frame="all">
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="2.68*"/>
                    <colspec colname="c2" colnum="2" colwidth="1*"/>
                    <thead>
                        <row>
                            <entry>FULL_GOODS_NAME</entry>
                            <entry>ID_CHILD_GOOD </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>Бытовая техника Холодильники Трехкамерные </entry>
                            <entry>6</entry>
                        </row>
                        <row>
                            <entry>Бытовая техника Холодильники Двухкамерные </entry>
                            <entry>7</entry>
                        </row>
                        <row>
                            <entry>Бытовая техника Холодильники Однокамерные</entry>
                            <entry>8</entry>
                        </row>
                        <row>
                            <entry>Бытовая техника Стиральные машины Вертикальные </entry>
                            <entry>9</entry>
                        </row>
                        <row>
                            <entry>Бытовая техника Стиральные машины Фронтальные Узкие</entry>
                            <entry>11</entry>
                        </row>
                        <row>
                            <entry>Бытовая техника Стиральные машины Фронтальные Классические </entry>
                            <entry>12</entry>
                        </row>
                        <row>
                            <entry>Компьютеры и комплектующие </entry>
                            <entry>3</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable></para>
        <para>Как видите, с помощью рекурсивной хранимой процедуры мы прошлись по всему дереву
            категорий и вывели полное наименование категорий-"листьев", которые находятся на самых
            кончиках ветвей.</para>
        <note>
            <para>У этой задачи есть более элегантное решение. Начиная с Firebird 2.1 поддерживаются
                рекурсивные запросы. С использованием рекурсивного запроса решение задачи выглядит
                следующим образом:
                <programlisting language="sql">
WITH RECURSIVE R AS (
  SELECT 
    gt1.id_good as id_good, 
    gt1.good_name as good_name
  FROM GoodsTree gt1
  WHERE gt1.id_parent_good=:ID_good2show 
  UNION ALL
  SELECT 
    gt1.id_good as id_good, 
    R.good_name || ' ' || gt1.good_name as good_name
  FROM GoodsTree gt1
  JOIN R ON gtl.id_parent_good = R.id_good
) 
SELECT
  good_name AS FULL_GOODS_NAME
  R.id_good AS ID_CHILD_GOOD
FROM R     
            </programlisting>
            </para>
        </note>
    </section>
    <section>
        <title>Заключение</title>

        <para>На этом закончим рассмотрение основных возможностей языка хранимых процедур. Очевидно,
            что полностью освоить разработку хранимых процедур при чтении одной главы невозможно,
            однако здесь мы постарались представить и объяснить основные концепции, связанные с
            хранимыми процедурами. Описанные конструкции и приемы проектирования ХП могут быть
            применены в большинстве приложений баз данных.</para>
        <para>Часть важных вопросов, связанных с разработкой хранимых процедур, будет раскрыта в
            следующей главе – "Расширенные возможности языка хранимых процедур Firebird", которая
            посвящена обработке исключений, разрешению ошибочных ситуаций в хранимых процедурах и
            работе с массивами.</para>
    </section>
</chapter>
