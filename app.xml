<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="app" xml:lang="ru"
    xmlns:xi="http://www.w3.org/2001/XInclude">
    <info>
        <title>Создание приложений с использованием Firebird</title>
    </info>


    <section xml:id="app-db">
        <title>Создание базы данных для примеров</title>

        <para/>
    </section>

    <section xml:id="app-delphi">
        <title>Создание приложений с использованием FireDac</title>

        <para>В данной главе будет описан процесс создания приложений для СУБД Firebird с
            использованием компонентов доступа FireDac и среды Delphi XE5. FireDac является
            стандартным набором компонентов доступа к различным базам данных начиная с Delphi
            XE3.</para>
        <para>Создайте новый проект <guimenu>File->New->VCL Forms Application - Delphi</guimenu>. В
            новый проект добавьте новый дата модуль <guimenu>File->New->Other</guimenu>, в
            появившемся мастере выберите <guimenu>Delphi Projects->Delphi Files->Data
                Module</guimenu>. Этот дата модуль будет главным в нашем проекте. Он будет содержать
            некоторые экземпляры глобальных компонентов доступа, которые должны быть доступны всем
            формам, которые должны работать с данными. Например, таким компонентом является
                <classname>TFDConnection</classname>.</para>

        <section>
            <title>Компонент TFDConnection</title>

            <para>Компонент <classname>TFDConnection</classname> обеспечивает подключение к
                различным типам баз данных. Будем указывать экземпляр этого компонента в свойствах
                    <property>Connection</property> остальных компонентов FireDac. К какому именно
                типу баз данных будет происходить подключение, зависит от значения свойства
                DriverName. Для доступа к Firebird нам необходимо выставить это свойство в значение
                FB. Для того чтобы подключение знало, с какой именно библиотекой доступа необходимо
                работать, разместим в главном дата модуле компонент
                    <classname>TFBPhysFBDriverLink</classname>. Его свойство
                    <property>VendorLib</property> позволяет указывать путь до клиентской
                библиотеки. Если оно не указано, то подключение к Firebird будет осуществляться
                через библиотеки, зарегистрированные в системе, например в
                    <filename>system32</filename>, что в ряде случаев может быть
                нежелательно.</para>

            <section>
                <title>Путь к клиентской библиотеке</title>

                <para>Мы будем размещать необходимую библиотеку доступа в папке
                        <filename>fbclient</filename>, которая расположена в папке приложения. Для
                    этого в коде на событие OnCreate дата модуля пропишем следующий код.
                    <programlisting language="delphi"> 
// указываем путь до клиентской библиотеки
xAppPath := ExtractFileDir(Application.ExeName) + PathDelim;
FDPhysFBDriverLink.VendorLib := xAppPath + 'fbclient' + PathDelim + 'fbclient.dll';
                </programlisting>
                </para>

                <important>
                    <para> Если вы компилируете 32 разрядное приложение, то вы должны использовать
                        32 разрядную библиотеку <filename>fbclient.dll</filename>. Для 64 разрядного
                        – 64 разрядную. Помимо файла <filename>fbclient.dll</filename> в ту же папку
                        желательно поместить библиотеки <filename>msvcp80.dll</filename> и
                            <filename>msvcr80.dll</filename> (для Firebird 2.5), и msvcp100.dll и
                        msvcr100.dll (для Firebird 3.0). Эти библиотеки можно найти либо в подпапке
                        bin (Firebird 2.5), либо в корневой папке сервера (Firebird 3.0). </para>
                    <para> Для того чтобы приложение правильно отображало собственные ошибки
                        firebird, необходимо также скопировать файл
                            <filename>firebird.msg</filename>. Для Firebird 2.5 и в более ранних
                        версиях он должен находиться на один уровень выше каталога клиентской
                        библиотеки, т.е. в нашем случае в каталоге приложения. Для Firebird 3 он
                        должен находиться в каталоге клиентской библиотеки, т.е. в каталоге
                        fbclient. </para>
                </important>

                <para>Если вам необходимо чтобы ваше приложение работало без установленного сервера
                    Firebird, т.е. в режиме Embedded, то для Firebird 2.5 необходимо заменить
                        <filename>fbclient.dll</filename> на <filename>fbembed.dll</filename>. При
                    желании имя библиотеки можно вынести в конфигурационный файл вашего приложения.
                    Для Firebird 3.0 ничего изменять не требуется (режим работы зависит от строки
                    подключения и значения параметра Providers в файле
                        <filename>firebird.conf</filename> или
                    <filename>databases.conf</filename>).</para>

                <tip>
                    <para>Даже если ваше приложение будет работать с Firebird в режиме Embedded,
                        разработку удобнее вести под полноценным сервером. Дело в том, что в режиме
                        Embedded Firebird работает в одном адресном пространстве с вашим
                        приложением, что может привести к нежелательным последствиям при
                        возникновении ошибок в вашем приложении. Кроме того, в момент разработки
                        среда Delphi и ваше приложение являются отдельными приложениями,
                        использующими Embedded. До версии 2.5 они не могут работать с одной базой
                        одновременно. </para>
                </tip>
            </section>

            <section>
                <title>Параметры подключения</title>

                <para>Компонент <classname>TFDConnection</classname> параметры подключения к базе
                    данных содержатся в свойстве Params (имя пользователя, пароль, набор символов
                    соединения и др.). Если воспользоваться редактором свойств
                        <classname>TFDConnection</classname> (двойной клик на компоненте), то
                    упомянутые свойства будут заполнены автоматически. Набор этих свойств зависит от
                    типа базы данных.</para>
                <para>
                    <table>
                        <?dbfo keep-together='auto'?>
                        <title>Основные свойства компонента TFDConnection</title>

                        <tgroup cols="2">
                            <colspec colwidth="2*" align="left"/>
                            <colspec colwidth="4*" align="left"/>
                            <thead>
                                <row valign="middle">
                                    <entry align="center">Свойство</entry>
                                    <entry align="center">Назначение</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row valign="middle">
                                    <entry>Pooled</entry>
                                    <entry><para>Используется ли пул соединений.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>Database</entry>
                                    <entry><para>Путь к базе данных или её псевдоним, определённый в
                                            файле конфигурации aliases.conf (или databases.conf)
                                            сервера Firebird.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>User_Name</entry>
                                    <entry><para>Имя пользователя.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>Password</entry>
                                    <entry><para>Пароль.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>OSAuthent</entry>
                                    <entry><para>Используется ли аутентификация средствами
                                            операционной системы.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>Protocol</entry>
                                    <entry><para>Протокол соединения. Допускаются следующие значения:<itemizedlist>
                                                <listitem>
                                                  <para>Local — локальный протокол;</para>
                                                </listitem>
                                                <listitem>
                                                  <para>NetBEUI — именованные каналы;</para>
                                                </listitem>
                                                <listitem>
                                                  <para>SPX — локальный протокол (до Firebird 2.0,
                                                  не поддерживается в современных версиях);</para>
                                                </listitem>
                                                <listitem>
                                                  <para>TCPIP – TCP/IP.</para>
                                                </listitem>
                                            </itemizedlist></para></entry>
                                </row>
                                <row>
                                    <entry>Server</entry>
                                    <entry><para>Имя сервера или его IP адрес. Если сервер работает
                                            на нестандартном порту, то необходимо также указать порт
                                            через слэш, например localhost/3051.</para></entry>
                                </row>
                                <row>
                                    <entry>SQLDialect</entry>
                                    <entry><para>Диалект. Должен совпадать с диалектом базы
                                            данных.</para></entry>
                                </row>
                                <row>
                                    <entry>RoleName</entry>
                                    <entry><para>Имя роли.</para></entry>
                                </row>
                                <row>
                                    <entry>CharacterSet</entry>
                                    <entry><para>Имя набора символов соединения.</para></entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
                <para>
                    <figure>
                        <title>Параметры подключения</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/firedac-connection-editor.png"
                                    align="center"/>
                            </imageobject>
                            <textobject>
                                <phrase>Параметры подключения</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>Дополнительные свойства: <itemizedlist>
                        <listitem>
                            <para><emphasis role="bold">Connected</emphasis> – управление
                                подсоединением к БД, или проверка состояния соединения. Это свойство
                                должно быть выставлено в True для работы мастеров других компонентов
                                FireDac . Если ваше приложение должно запрашивать данные для
                                авторизации, то важно не забыть сбросить это свойство в False перед
                                компиляцией вашего приложения.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">LoginPrompt</emphasis> – запрашивать ли имя
                                пользователя и пароль при попытке соединения.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Transaction</emphasis> – компонент
                                TFDTransaction , который будет использоваться в качестве
                                умолчательного для выполнения различных операций TFDConnection .
                                Если это свойство не назначено явно, TFDConnection создаст себе
                                экземпляр TFDTransaction самостоятельно, его параметры можно указать
                                в свойстве TxOptions.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">UpdateTransaction</emphasis> – компонент
                                TFDTransaction , который будет использоваться в качестве
                                умолчательного для одноимённых свойств компонентов TFDQuery . Если
                                это свойство не назначено явно, будет использовано значение из
                                свойства Transaction .</para>
                        </listitem>
                    </itemizedlist></para>
                <para>Поскольку параметры подключения, за исключением имени пользователя и пароля,
                    обычно не изменяются в процессе эксплуатации приложения, мы будем считывать их
                    из файла конфигурации.
                    <programlisting language="delphi"> 
// считываем параметры подключения
xIniFile := TIniFile.Create(xAppPath + 'config.ini');
try
  xIniFile.ReadSectionValues('connection', FDConnection.Params);
finally
  xIniFile.Free;
end;
                </programlisting>
                </para>
                <para>Файл <filename>config.ini</filename> содержит примерно следующие строки:
                    <programlisting language="ini"> 
[connection]
DriverID=FB
Protocol=TCPIP
Server=localhost/3051
Database=examples
OSAuthent=No
RoleName=
CharacterSet=UTF8
                </programlisting>
                </para>
                <para>Содержимое секции connection можно получить, скопировав содержимое свойства
                    Params компонента TFDConnection после работы мастера.</para>
                <note>
                    <para>На самом деле общие настройки обычно находятся в
                                <filename>%AppData%\<replaceable>Manufacture</replaceable>\<replaceable>AppName</replaceable></filename>
                        и сохраняются туда инсталлятором приложения. Однако при разработке удобно
                        чтобы файл настроек лежал где-нибудь поближе, например, в папке с
                        приложением.</para>
                    <para>Учтите, что если ваше приложение будет устанавливаться в папку
                            <filename>Program Files</filename> и файл настройки будет лежать там же,
                        то либо этот файл будет виртуализироваться в <filename>Program
                            Data</filename>, либо будут проблемы с его модификацией и последующим
                        чтением новых настроек. </para>
                </note>
            </section>
            <section>
                <title>Подключение к базе данных</title>

                <para>Для подключения к базе данных необходимо изменить свойство
                        <property>Connected</property> компонента
                        <classname>TFDConnection</classname> в значение <literal>True</literal> или
                    вызвать метод <function>Open</function>. В последний метод можно передать имя
                    пользователя и пароль в качестве параметров. В нашем приложении мы заменим
                    стандартный диалог соединения с базой данных. Дадим возможность ошибиться при
                    вводе регистрационной информации не более трёх раз, после чего приложение будет
                    закрыто. Для этого напишем следующий код в обработчике события
                        <property>OnCreate</property> главного датамодуля.
                    <programlisting language="delphi"> 
// делаем максимум 3 попытки входа в систему, потом закрываем приложение
xLoginCount := 0;
xLoginPromptDlg := TLoginPromptForm.Create(Self);
while (xLoginCount &lt; MAX_LOGIN_COUNT) and 
      (not FDConnection.Connected) do
begin
  try
    if xLoginPromptDlg.ShowModal = mrOK then
      FDConnection.Open(
        xLoginPromptDlg.UserName, xLoginPromptDlg.Password)
    else
      xLoginCount := MAX_LOGIN_COUNT;
  except
    on E: Exception do
    begin
      Inc(xLoginCount);
      Application.ShowException(E);
    end
  end;
end;
xLoginPromptDlg.Free;

if not FDConnection.Connected then
  Halt;

                </programlisting>
                </para>
            </section>
        </section>

        <section>
            <title>Компонент TFDTransaction</title>

            <para>Компонент <classname>TFDTransaction</classname> предназначен для явной работы с
                транзакциями.</para>
            <para>Клиентская часть Firebird допускает выполнение любых действий только в контексте
                транзакции. Поэтому если вы смогли получить доступ к данным без явного вызова
                    <function>TFDTransaction.StartTransaction</function>, то значит где-то в недрах
                FireDac этот вызов произошёл автоматически. Такое поведение крайне не рекомендуется
                использовать. Для корректной работы приложений с базой данных желательно управлять
                транзакциями вручную, то есть явно вызывать методы
                    <function>StartTransaction</function>, <function>Commit</function> и
                    <function>Rollback</function> компонента
                <classname>TFDTransaction</classname>.</para>
            <para>
                <table>
                    <?dbfo keep-together='auto'?>
                    <title>Основные свойства компонента TFDTransaction</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Свойство</entry>
                                <entry align="center">Назначение</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>Connection</entry>
                                <entry><para>Связь с компонентом FDConnection.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.AutoCommit</entry>
                                <entry><para>Управляет автоматическим стартом и завершением
                                        транзакции. Значение по умолчанию True.</para>
                                    <para>Если значение этого свойства установлено в True , то
                                        FireDAC делает следующее:</para>
                                    <para>Запускается транзакция (если требуется) перед выполнением
                                        каждой SQL команды, и завершает транзакцию после выполнения
                                        SQL команды. Если команда выполнится успешно, то транзакция
                                        будет завершена как COMMIT, иначе — ROLLBACK.</para>
                                    <para>Если приложение вызывает метод StartTransaction, то
                                        автоматическое управление транзакциями будет отключено, до
                                        тех пор, пока транзакция не завершится как Commit или
                                        Rollback.</para>
                                    <para>При использовании Firebird автоматическое управление
                                        транзакциями эмулируется самими компонентами
                                    FireDAC.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.AutoStart</entry>
                                <entry><para>Управляет автоматическим запуском транзакции. По
                                        умолчанию True.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.AutoStop</entry>
                                <entry><para>Управляет автоматическим завершением транзакции. По
                                        умолчанию True.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.DisconnectAction</entry>
                                <entry><para>Действие, которое будет выполнено при закрытии
                                        соединения, если транзакция активна. Значение по умолчанию
                                        xdCommit. Возможны следующие варианты:<itemizedlist>
                                            <listitem>
                                                <para>xdNone — ничего не будет сделано. Действие
                                                  будет отдано на откуп СУБД;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xdCommit — подтверждение транзакции;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xdRollback — откат транзакции.</para>
                                            </listitem>
                                        </itemizedlist></para>
                                    <para>В других компонентах доступа значение по умолчанию для
                                        подобного свойства xdRollback. Поэтому необходимо выставлять
                                        это свойство вручную в то значение, которое действительно
                                        требуется.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.EnableNested</entry>
                                <entry><para>Управляет вложенными транзакциями. Значение по
                                        умолчанию True.</para>
                                    <para>Когда транзакция активна, то следующий вызов
                                        StartTransaction создаст вложенную транзакцию. FireDAC
                                        эмулирует вложенные транзакции, используя точки сохранения,
                                        если СУБД не поддерживает вложенные транзакции в явном виде.
                                        Чтобы отключить вложенные транзакции, установите
                                        EnableNested в False, и последующий вызов StartTransaction
                                        вызовет исключение.</para>
                                    <para>Firebird не поддерживает вложенные транзакции в явном
                                        виде.</para></entry>
                            </row>
                            <row>
                                <entry>Options.Isolation</entry>
                                <entry><para>Определяет уровень изолированности транзакции. Это
                                        самое важное свойство транзакции. Значение по умолчанию
                                        xiReadCommited. Возможны следующие варианты:<itemizedlist>
                                            <listitem>
                                                <para>xiUnspecified – используется уровень изоляции
                                                  по умолчанию для вашей СУБД (в Firebird это
                                                  SNAPSHOT, т.е. с параметрами read write
                                                  concurrency wait);</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiDirtyRead – этого уровня изолированности в
                                                  Firebird не существует поэтому вместо него будет
                                                  использован READ COMMITED;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiReadCommited – уровень изолированности READ
                                                  COMMITED. В Firebird такая транзакция стартует с
                                                  параметрами read write read_committed rec_version
                                                  nowait;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiRepeatableRead – этого уровня
                                                  изолированности в Firebird не существует поэтому
                                                  вместо него будет использован SNAPSHOT;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiSnapshot – уровень изолированности SNAPSHOT
                                                  . В Firebird такая транзакция стартует с
                                                  параметрами read write concurrency wait;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiSerializable – уровень изолированности
                                                  SERIALIZABLE . На самом деле в Firebird не
                                                  существует транзакции с данным уровнем
                                                  изолированности, но он эмулируется запуском
                                                  транзакции с параметрами read write consistency
                                                  wait.</para>
                                            </listitem>
                                        </itemizedlist></para></entry>
                            </row>
                            <row>
                                <entry>Options.Params</entry>
                                <entry><para>Специфичные для СУБД параметры транзакции. В настоящее
                                        время используется только для Firebird и Interbase. Возможны
                                        комбинации из следующих значений:<itemizedlist
                                            spacing="compact">
                                            <listitem>
                                                <para>read</para>
                                            </listitem>
                                            <listitem>
                                                <para>write</para>
                                            </listitem>
                                            <listitem>
                                                <para>read_commited</para>
                                            </listitem>
                                            <listitem>
                                                <para>concurrency</para>
                                            </listitem>
                                            <listitem>
                                                <para>consistency</para>
                                            </listitem>
                                            <listitem>
                                                <para>wait</para>
                                            </listitem>
                                            <listitem>
                                                <para>nowait</para>
                                            </listitem>
                                            <listitem>
                                                <para>rec_version</para>
                                            </listitem>
                                            <listitem>
                                                <para>no rec_version</para>
                                            </listitem>
                                        </itemizedlist></para></entry>
                            </row>
                            <row>
                                <entry>Options.ReadOnly</entry>
                                <entry><para>Указывает является ли транзакция только для чтения. По
                                        умолчанию False . Если установлено в True , то любые
                                        изменения в рамках текущей транзакции невозможны, в Firebird
                                        в этом случае отсутствует значение read в параметрах
                                        транзакции.</para>
                                    <para>Установка этого свойства в True позволяет СУБД
                                        оптимизировать использование ресурсов.</para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>В отличие от других СУБД в Firebird и Interbase разрешено использовать сколько
                угодно компонентов <classname>TFDTransaction</classname> привязанных к одному
                соединению. В нашем приложении мы будем использовать одну общую читающую транзакцию
                для всех справочников и оперативных журналов, и по одной пишущей транзакции на
                каждый справочник/журнал.</para>
            <para>В нашем приложении мы не будем полагаться на автоматический старт и завершение
                транзакций, а потому во всех транзакциях Options.AutoCommit = False,
                Options.AutoStart = False и Options.AutoStop = False.</para>
            <para>Поскольку читающая транзакция общая для всех справочников и журналов, то удобно
                разместить её в главном дата модуле. Для обычной работы (показ данных в гриде и
                т.п.) обычно используются режим изолированости READ COMMITED (Options.Isolation =
                xiReadCommited), т.к. он позволяет транзакции видеть чужие, committed изменения базы
                данных просто путём повторного выполнения запросов (перечитывания данных). Поскольку
                эта транзакция используется только для чтения, установим свойство Options.ReadOnly в
                значение True. Таким образом, наша транзакция будет иметь параметры read
                read_commited rec_version. Транзакция с такими параметрами в Firebird может быть
                открытой сколь угодно долгое время (дни, недели, месяцы), без блокирования других
                транзакций или влияния на накопление мусора в базе данных (потому что на самом деле,
                на сервере такая транзакция стартует как committed).</para>
            <note>
                <para>Такую транзакцию нельзя использовать для отчётов (особенно если они используют
                    несколько последовательных запросов), потому что транзакция с режимом
                    изолированности READ COMMITED во время перечитывания данных будет видеть все
                    новые committed-изменения.</para>
                <para>Для отчётов рекомендуется использовать короткую транзакцию только для чтения с
                    режимом изолированности SNAPSHOT (Options.Isolation = xiSnapshot и
                    Options.ReadOnly= True). В данном примере работа с отчётами не
                    рассматривается.</para>
            </note>
            <para>Стартуем читающую транзакцию сразу после успешной установки соединения с базой
                данных, вызвав trRead.StartTransaction в событии OnCreate главного датамодуля, и
                завершаем перед закрытием соединения, вызвав tRead.Commit в событии OnDestroy
                главного датамодуля. Значение свойства Options.DisconnectAction равное xdCommit по
                умолчанию, подходит для транзакции только для чтения.</para>
            <para>Пишущая транзакция будет отдельной для каждого справочника/журнала. Её мы
                разместим на форме, которая относится непосредственно к нужному журналу. Пишущая
                транзакция должна быть максимально короткой для того, чтобы не удерживать Oldest
                Active Transaction, которая не даёт собрать мусор, что в свою очередь приводит к
                деградации производительности. Поскольку пишущая транзакция очень короткая мы можем
                использовать уровень изолированности SNAPSHOT. Таким образом, наша пишущая
                транзакция будет иметь параметры Options.ReadOnly=False и Options.Isolation =
                xiSnapshot. Для пишущих транзакций значение свойства Options.DisconnectAction по
                умолчанию не подходит, его необходимо выставить в значение xdRollback.</para>
        </section>
        <section>
            <title>Датасеты</title>

            <para>Работать с данными в FireDac можно при помощи компонент
                    <classname>TFDQuery</classname>, <classname>TFDTable</classname>,
                    <classname>TFDStoredProc</classname>, <classname>TFDCommand</classname>, но
                    <classname>TFDCommand</classname> не является датасетом.</para>
            <para><classname>TFDQuery</classname>, <classname>TFDTable</classname> и
                    <classname>TFDStoredProc</classname> унаследованы от
                    <classname>TFDRdbmsDataSet</classname>. Помимо наборов данных для работы
                непосредственно с базой данных, в FireDac существует также компонент
                    <classname>TFDMemTable</classname>, который предназначен для работы с набором
                данных в памяти, является аналогом <classname>TClientDataSet</classname>.</para>
            <para>Основным компонентом для работы с наборами данных является
                    <classname>TFDQuery</classname>. Возможностей этого компонента хватает
                практически для любых целей. Компоненты <classname>TFDTable</classname> и
                    <classname>TFDStoredProc</classname> всего лишь модификации, либо чуть
                расширенные, либо усеченные. Мы не будем их рассматривать и применять в нашем
                приложении. При желании вы можете ознакомиться с ними в документации по
                FireDac.</para>
            <para>Назначение компонента — буферизация записей, выбираемых оператором SELECT, для
                представления этих данных в Grid, а также для обеспечения "редактируемости" записи
                (текущей в буфере (гриде)). В отличие от компонента
                    <classname>IBX.TIBDataSet</classname> компонент <classname>TFDQuery</classname>
                не содержит свойств <property>RefreshSQL</property>, <property>InsertSQL</property>,
                    <property>UpdateSQL</property> и <property>DeleteSQL</property>. Вместо этого
                «редактируемость» обеспечивается компонентом <classname>TFDUpdateSQL</classname>,
                который устанавливается в свойство <property>UpdateObject</property>.</para>
            <note>
                <para>В ряде случаев можно сделать компонент <classname>TFDQuery</classname>
                    редактируемым без установки свойства <property>UpdateObject</property> и
                    прописывания запросов Insert/Update/Delete, просто установив свойство
                    UpdateOptions.RequestLive = True, при этом модифицирующие запросы будут
                    сгенерированы автоматически. Однако такой подход имеет множество ограничений на
                    основной SELECT запрос, поэтому не стоит полагаться на него. </para>
            </note>
            <para>
                <table>
                    <?dbfo keep-together='auto'?>
                    <title>Основные свойства компонента TFDQuery</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Свойство</entry>
                                <entry align="center">Назначение</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>Connection</entry>
                                <entry><para>Связь с компонентом FDConnection.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>MasterSource</entry>
                                <entry>
                                    <para>Ссылка на Master-источник данных (TDataSource) для
                                        FDQuery, используемого в качестве Detail.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>Transaction</entry>
                                <entry>
                                    <para>Транзакция, в рамках которой будет выполняться запрос,
                                        прописанный в свойстве SQL. Если свойство не указано будет
                                        использоваться транзакция по умолчанию для
                                        подключения.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateObject</entry>
                                <entry>
                                    <para>Связь с компонентом FDUpdateSQL, который обеспечивает
                                        «редактируемость» набора данных, когда SELECT запрос не
                                        отвечает требованиям для автоматического формирования
                                        модифицирующих запросов при установке
                                        UpdateOptions.RequestLive = True.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateTransaction</entry>
                                <entry>
                                    <para>Транзакция, в рамках которой будут выполняться
                                        модифицирующие запросы. Если свойство не указано, будет
                                        использована транзакция из свойства Transaction.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.CheckRequired</entry>
                                <entry>
                                    <para>Если свойство CheckRequired установлено в True, то FireDac
                                        контролирует свойство Required соответвующих полей, т.е.
                                        полей с ограничением NOT NULL. По умолчанию установлено в
                                        True.</para>
                                    <para>Если CheckRequired=True и в поле имеющее свойство
                                        Required=True не присвоено значение, то при вызове метода
                                        Post будет возбуждено исключение. Это может быть
                                        нежелательно в том случае, если значение этого поля может
                                        быть присвоено позже в BEFORE триггерах.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.EnableDelete</entry>
                                <entry>
                                    <para>Определяет, позволяется ли удаление записи из набора
                                        данных. Если EnableDelete=False, то при вызове метода Delete
                                        будет возбуждено исключение.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.EnableInsert</entry>
                                <entry>
                                    <para>Определяет, позволяется ли вставка записи в набор данных.
                                        Если EnableInsert=False, то при вызове метода Insert/Append
                                        будет возбуждено исключение.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.EnableUpdate</entry>
                                <entry>
                                    <para>Определяет, позволяется ли изменение записи в наборе
                                        данных. Если EnableUpdate=False, то при вызове метода Edit
                                        будет возбуждено исключение.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.FetchGeneratorsPoint</entry>
                                <entry>
                                    <para>Управляет моментом получения следующего значения
                                        генератора указанного в свойстве UpdateOptions.GeneratorName
                                        или свойстве GeneratorName автоинкрементного поля
                                        AutoGenerateValue = arAutoInc. Имеет следующие варианты значений:<itemizedlist>
                                            <listitem>
                                                <para>gpNone – значение генератора не
                                                  извлекается;</para>
                                            </listitem>
                                            <listitem>
                                                <para>gpImmediate – следующее значение генератора
                                                  извлекается сразу после вызова метода
                                                  Insert/Append;</para>
                                            </listitem>
                                            <listitem>
                                                <para>gpDeffered – следующее значение генератора
                                                  извлекается до публикации новой записи в базе
                                                  данных, т.е. во время выполнения методов Post или
                                                  ApplyUpdates.</para>
                                            </listitem>
                                        </itemizedlist> Значение по умолчанию gpDeffered. </para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.GeneratorName</entry>
                                <entry>
                                    <para>Имя генератора для извлечения следующего значения
                                        автоинкрементного поля.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.ReadOnly</entry>
                                <entry>
                                    <para>Указывает, является ли набор данных только для чтения. По
                                        умолчанию False. Если значение этого свойства установлено в
                                        True, то значения свойств EnableDelete, EnableInsert и
                                        EnableUpdate будут автоматически выставлены в False.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>UpdateOptions.RequestLive</entry>
                                <entry>
                                    <para>Установка RequestLive в True делает запрос «живым», т.е.
                                        редактируемым, если это возможно. При этом запросы
                                        Insert/Update/Delete будут сгенерированы автоматически. Эта
                                        опция накладывает множество ограничений на SELECT запрос,
                                        введена для обратной совместимости с BDE и не
                                        рекомендуется.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>UpdateOptions.UpdateMode</entry>
                                <entry>
                                    <para>Отвечает за проверку модификации записи. Это свойство
                                        позволяло контролировать возможное "перекрытие" обновлений
                                        для случаев, когда пользователь выполняет редактирование
                                        записи "долго", а другой пользователь может успеть
                                        отредактировать эту же запись и сохранить её раньше. То
                                        есть, первый пользователь на этапе редактирования даже не
                                        будет знать, что запись уже изменилась, возможно не один
                                        раз, и сумеет "затереть" эти обновления своим:<itemizedlist>
                                            <listitem>
                                                <para>upWhereAll — проверка на существование записи
                                                  по первичному ключу + проверка всех столбцов на
                                                  старые значения. Например
                                                  <programlisting language="sql">
update table 
set ... 
where pkfield = :old_ pkfield 
  and client_name = :old_client_name 
  and info = :old_info 
...                                                     
                                                </programlisting>
                                                  То есть, в данном случае запрос поменяет
                                                  информацию в записи только в том случае, если
                                                  запись до нас никто не успел изменить. Особенно
                                                  это важно, если существуют взаимозависимости между
                                                  значениями столбцов — например, минимальная и
                                                  максимальная зарплата, и т.п. </para>
                                            </listitem>
                                            <listitem>
                                                <para>upWhereCahnged — проверка записи на
                                                  существование по первичному ключу + плюс проверка
                                                  на старые значения только изменяемых столбцов.
                                                  <programlisting language="sql">
update table 
set ... 
where pkfield = :old_ pkfield 
  and client_name = :old_client_name 
  and info = :old_info 
...                                                     
                                                </programlisting>
                                                </para>
                                            </listitem>
                                            <listitem>
                                                <para>upWhereKeyOnly (по умолчанию) — проверка
                                                  записи на существование по первичному
                                                  ключу.</para>
                                            </listitem>
                                        </itemizedlist>
                                    </para>
                                    <para>Последняя проверка соответствует генерируемому
                                        автоматически для UpdateSQL запросу. Поэтому, при возможных
                                        конфликтах обновлений в многопользовательской среде
                                        необходимо дописывать условия к where самостоятельно. И,
                                        разумеется, также необходимо при реализации аналога
                                        upWhereChanged удалять лишние изменения столбцов в update
                                        table set ... - то есть, оставлять в перечне set только
                                        действительно изменённые столбцы, иначе запрос перепишет
                                        чужие обновления этой записи. Как вы понимаете, это означает
                                        необходимость динамического конструирования запроса
                                        UpdateSQL.</para>
                                    <para>Если вы хотите задать настройки обнаружения конфликтов
                                        обновления индивидуально для каждого поля, то вы можете
                                        воспользоваться свойством ProviderFlags для каждого
                                        поля.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>CachedUpdates</entry>
                                <entry>
                                    <para>Определяет, будет ли набор данных кэшировать изменения без
                                        немедленного внесения их в базу данных. Если это свойство
                                        установлено в значение True, то любые изменения
                                        (Insert/Post, Update/Post, Delete) вносятся в базу данных не
                                        сразу, а сохраняется в специальном журнале. Приложение
                                        должно явно применить изменения, вызвав метод ApplyUpdates.
                                        В этом случае все изменения будут выполнены в течение малого
                                        промежутка времени и в одной короткой транзакции. По
                                        умолчанию значение этого свойства False.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>SQL</entry>
                                <entry>
                                    <para>Содержит SQL запрос. Если это свойство содержит SELECT
                                        запрос, то его необходимо выполнять методом Open. В
                                        противном случае необходимо использовать методы Execute или
                                        ExecSQL.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
        </section>
        <section>
            <title>Компонент TFDUpdateSQL</title>

            <para>Компонент TFDUpdateSQL позволяет переопределять SQL команды, сгенерированные для
                автоматического обновления набора данных. Он может быть использован для внесения
                обновлений в компоненты TFDQuery, TFDTable и TFDStoredProc. Использование
                TFDUpdateSQL является необязательным для компонентов TFDQuery и TFDTable, потому что
                эти компоненты способны автоматически генерировать команды для публикации обновлений
                из набора данных в СУБД. Использование TFDUpdateSQL является обязательным для
                возможности обновления набора данных TFDStoredProc. Рекомендуем применять его
                всегда, даже для самых простых случаев, чтобы получать полный контроль над тем какие
                запросы выполняются в вашем приложении.</para>

            <para>Для того чтобы указать SQL команды на этапе проектирования, используйте редактор
                TFDUpdateSQL времени проектирования, который вызывается двойным щелчком по
                компоненту.</para>

            <note>
                <para>Для работы многих редакторов времени проектирования FireDac требуется, чтобы
                    было активно подключение к базе данных (TFDConnection.Connected = True) и
                    транзакция находилась в режиме автостарта (TFDTransaction.Options.AutoStart =
                    True). Но такие настройки могут мешать при работе приложения. Например,
                    пользователь должен входить в программу под своим логином, а TFDConnection
                    подключается к базе данных под SYSDBA. Поэтому после каждого использования
                    редакторов времени проектирования рекомендуем проверять свойство
                    TFDConnection.Connected и сбрасывать его. Кроме того, вам придётся включать и
                    выключать автостарт транзакции предназначенной только для чтения.</para>
            </note>

            <para>
                <figure>
                    <title>Настройка TFDUpdateSQL. Генерация запросов.</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-fdupdatesql.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Настройка TFDUpdateSQL. Генерация запросов.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>На закладке Generate вы можете упростить себе задачу по написанию
                Insert/Update/Delete/Refresh запросов. Для этого выберете таблицу для обновления, её
                ключевые поля, поля для обновления, и поля которые будут перечитаны после
                обновления, и нажмите на кнопку «Generate SQL». После чего запросы будут
                сгенерированы автоматически, и вы перейдёте на закладку «SQL Commands», где можете
                поправить каждый из запросов. <figure>
                    <title>Настройка TFDUpdateSQL. SQL команды.</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-fdupdatesql-sql.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Настройка TFDUpdateSQL. SQL команды.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <note>
                <para>Поскольку product_id не включено в Updating Fields, оно отсутствует в
                    генерируемом запросе insert. Предполагается, что этот столбец заполняется
                    автоматически триггером (с генератором), или же этот это IDENTITY столбец
                    (начиная с Firebird 3.0). При получении значения генератора для этого столбца с
                    сервера, рекомендуется вручную добавить столбец PRODUCT_ID в предложение
                    RETURNING оператора INSERT.</para>
            </note>
            <para>На закладке Options находятся некоторые свойства, которые могут повлиять на
                генерацию запросов. Эти свойства не относятся к самому компоненту TFDUpdateSQL, а
                являются ссылками на свойства UpdateOptions набора данных, у которого указан текущий
                TFDUpdateSQL в свойстве UpdateObject. Так сделано исключительно ради
                удобства.</para>
            <para>
                <table>
                    <?dbfo keep-together='auto'?>
                    <title>Основные свойства компонента TFDUpdateSQL</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Свойство</entry>
                                <entry align="center">Назначение</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>Connection</entry>
                                <entry><para>Связь с компонентом FDConnection.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>DeleteSQL</entry>
                                <entry><para>SQL запрос для удаления записи.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>FetchRowSQL</entry>
                                <entry><para>SQL запрос для возврата одной текущей (обновлённой,
                                        вставленной) записи. (RefreshSQL)</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>InsertSQL</entry>
                                <entry><para>SQL запрос для вставки записи.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>LockSQL</entry>
                                <entry><para>SQL запрос для блокировки одной текущей записи. (FOR
                                        UPDATE WITH LOCK).</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>ModifySQL</entry>
                                <entry><para>SQL запрос для модификации записи.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>UnlockSQL</entry>
                                <entry><para>SQL запрос для разблокировки текущей записи. В Firebird
                                        не применяется.</para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>Как вы уже заметили, у компонента TFDUpdateSQL нет свойства Transaction. Это
                потому, что компонент не выполняет модифицирующие запросы непосредственно, а лишь
                заменяет автоматически сгенерированные запросы в наборе данных, который является
                предком TFDRdbmsDataSet.</para>
        </section>
        <section>
            <title>Компонент TFDCommand</title>

            <para>Компонент TFDCommand предназначен для выполнения SQL запросов. Он не является
                предком TDataSet, а потому удобен лишь для выполнения SQL запросов, не возвращающих
                набор данных.</para>
            <para>
                <table>
                    <?dbfo keep-together='auto'?>
                    <title>Основные свойства компонента TFDCommand</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Свойство</entry>
                                <entry align="center">Назначение</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>Connection</entry>
                                <entry><para>Связь с компонентом FDConnection.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Transaction</entry>
                                <entry>
                                    <para>Транзакция, в рамках которой будет выполняться SQL
                                        команда.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>CommandKind</entry>
                                <entry><para>Тип команды. <itemizedlist>
                                            <listitem>
                                                <para>skUnknown – неизвестен. В этом случае тип
                                                  команды будет определятся автоматически по тексту
                                                  команды внутренним парсером;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skStartTransaction – команда для старта
                                                  транзакции;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skCommit – команда завершения и подтверждения
                                                  транзакции;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skRollback – команда завершения и отката
                                                  транзакции;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skCreate – команда CREATE … для создания
                                                  нового объекта метаданных;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skAlter – команда ALTER … для модификации
                                                  объекта метаданных;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skDrop – команда DROP … для удаления объекта
                                                  метаданных;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skSelect – команда SELECT для выборки
                                                  данных;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skSelectForLock – команда SELECT … WITH LOCK
                                                  для блокировки выбранных строк;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skInsert – команда INSERT … для вставки новой
                                                  записи;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skUpdate – команда UPDATE … для модификации
                                                  записей;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skDelete – команда DELETE … для удаления
                                                  записей;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skMerge – команда MERGE INTO …</para>
                                            </listitem>
                                            <listitem>
                                                <para>skExecute – команда EXECUTE PROCEDURE или
                                                  EXECUTE BLOCK;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skStoredProc – вызов хранимой
                                                  процедуры;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skStoredProcNoCrs – вызов хранимой процедуры
                                                  не возвращающей курсор;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skStoredProcWithCrs – вызов хранимой процедуры
                                                  возвращающей курсор.</para>
                                            </listitem>
                                        </itemizedlist> Обычно тип команды определяется
                                        автоматически по тексту SQL запроса.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>CommandText</entry>
                                <entry>
                                    <para>Текст SQL запроса.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
        </section>

        <section>
            <title>Создание справочников</title>

            <para>В нашем приложении мы создадим два справочника: справочник товаров и справочник
                заказчиков. Каждый из справочников представляет собой форму с сеткой TDBGrid,
                источником данных TDataSource, набором данных TFDQuery, пишущей транзакции
                TFDTransaction.</para>

            <para>Рассмотрим создание справочников на примере справочника заказчиков.</para>

            <para>
                <figure>
                    <title>Форма справочника Customers</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-customers-form.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Форма справочника Customers.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <note>
                <para>Компонент trRead не виден, потому что находится не на форме, а в модуле
                    dmMain.</para>
            </note>

            <para>Разместим компонент TFDQuery на форме с именем qryCustomers. Этот набор данных
                будет указан в свойстве DataSet источника данных DataSource. В свойстве Transaction
                укажем ReadOnly транзакцию trRead, которая была создана в главном датамодуле
                проекта. В свойстве UpdateTransaction указываем транзакцию trWrite, в свойстве
                Connection — соединение расположенное в главном датамодуле. В свойстве SQL напишем
                следующий запрос:
                <programlisting language="sql"> 
SELECT
    customer_id,
    name,
    address,
    zipcode,
    phone
FROM
    customer
ORDER BY name
                </programlisting>
            </para>

            <para>Пишущая транзакция trWrite должна быть максимально короткой, и иметь режим
                изолированности SNAPSHOT. Мы не будем полагаться на автоматический старт и
                завершение транзакции, а будем стартовать и завершать транзакцию явно. Таким
                образом, наша транзакция должна иметь следующие свойства:
                <programlisting> 
Options.AutoStart = False
Options.AutoCommit = False
Options.AutoStop = False
Options.DisconnectAction = xdRollback
Options.Isolations = xiSnapshot
Options.ReadOnly = False
                </programlisting>
            </para>

            <para>На самом деле необязательно устанавливать режим изолированности SNAPSHOT для
                простых INSERT/UPDATE/DELETE. Однако если у таблицы есть сложные триггеры, или
                вместо простых запросов INSERT/UPDATE/DELETE вызывается хранимая процедура, то
                желательно использовать уровень изолированности SNAPSHOT.</para>

            <para>Дело в том, что уровень изолированности READ COMMITED не обеспечивает атомарности
                оператора в пределах одной транзакции (statement read consistency). Таким образом,
                оператор SELECT может возвращать данные, которые попали в базу данных после начала
                выполнения запроса. В принципе режим изолированности SNAPSHOT можно рекомендовать
                почти всегда, если транзакция будет короткой.</para>

            <para>Для возможности редактирования набора данных необходимо заполнить свойства
                InsertSQL, ModifySQL, DeleteSQL и FetchRowSQL. Эти свойства могут быть сгенерированы
                мастером, но после этого может потребоваться некоторая правка. Например вы можете
                дописать предложение RETURNING, удалить модификацию некоторых столбцов, или же вовсе
                заменить автоматически сгенерированный запрос на вызов хранимой процедуры.</para>

            <formalpara>
                <title>InsertSQL:</title>

                <para>
                    <programlisting language="sql"> 
INSERT INTO customer (customer_id,
                      name,
                      address,
                      zipcode,
                      phone)
VALUES (:new_customer_id,
        :new_name,
        :new_address,
        :new_zipcode,
        :new_phone)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>ModifySQL:</title>

                <para>
                    <programlisting language="sql"> 
UPDATE customer
SET name = :new_name,
    address = :new_address,
    zipcode = :new_zipcode,
    phone = :new_phone
WHERE (customer_id = :old_customer_id)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>DeleteSQL:</title>

                <para>
                    <programlisting language="sql"> 
DELETE FROM customer
WHERE (customer_id = :old_customer_id)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>FetchRowSQL:</title>

                <para>
                    <programlisting language="sql"> 
SELECT
    customer_id,
    name,
    address,
    zipcode,
    phone
FROM
    customer
WHERE customer_id = :old_customer_id
                </programlisting>
                </para>
            </formalpara>

            <para>В этом справочнике будем получать значение генератора перед вставкой записи в
                таблицу. Для этого необходимо установить значение свойств компонента TFDQuery в
                следующие значения UpdateOptions.GeneratorName = GEN_CUSTOMER_ID и
                UpdateOptions.AutoIncFields = CUSTOMER_ID. Есть другой способ, когда значение
                генератора (автоинкрементного поля) возвращается после выполнения INSERT запроса с
                помощью предложения RETURNING. Этот способ будет показан позже.</para>

            <para>Для добавления новой записи и редактирования существующей принято использовать
                модальные формы, по закрытию которых с результатом mrOK изменения вносятся в базу
                данных. Обычно для создания таких форм используются DBAware компоненты, которые
                позволяют отображать значения некоторого поля в текущей записи и немедленно вносить
                изменения в текущую запись набора данных в режимах Insert/Edit, т.е. до Post. Но
                перевести набор данных в режим Insert/Edit можно только стартовав пишущую
                транзакцию. Таким образом, если кто-то откроет форму для внесения новой записи и
                уйдёт на обед, не закрыв эту форму, у нас будет висеть активная транзакция до тех
                пор, пока сотрудник не вернётся с обеда и не закроет форму. Это в свою очередь
                приведёт к тому, что активная транзакция будет удерживать сборку мусора, что позже
                приведёт к снижению производительности. Эту проблему можно решить одним из двух способов:<orderedlist>
                    <listitem>
                        <para>Использовать режим CachedUpdates , что позволяет держать транзакцию
                            активной только на очень короткий промежуток времени, а именно на время
                            внесения изменений.</para>
                    </listitem>
                    <listitem>
                        <para>Отказаться от применения DBAware компонентов. Однако этот путь
                            потребует от вас дополнительных усилий.</para>
                    </listitem>
                </orderedlist></para>

            <para>Мы покажем применение обоих способов. Для справочников гораздо удобнее
                использовать первый способ. Рассмотрим код редактирования записи поставщика
                <programlisting language="delphi"> 
procedure TCustomerForm.actEditRecordExecute(Sender: TObject);
var
  xEditor: TEditCustomerForm;
begin
  xEditor := TEditCustomerForm.Create(Self);
  try
    xEditor.OnClose := CustomerEditorClose;
    xEditor.CustomerForm := Self;
    xEditor.Caption := 'Edit customer';
    qryCustomer.CachedUpdates := True;
    qryCustomer.Edit;
    xEditor.ShowModal;
  finally
    xEditor.Free;
  end;
end;
                </programlisting>
            </para>
            <para>По коду видно, что перед переводом набора данных в режим редактирования мы
                устанавливаем ему режим CachedUpdates, а вся логика обработки редактирования
                происходит в модальной форме.
                <programlisting language="delphi"> 
procedure TCustomerForm.CustomerEditorClose (Sender: TObject;
  var Action: TCloseAction);
begin
  if TForm(Sender).ModalResult &lt;&gt; mrOK then
  begin
    // отменяем все изменения
    qryCustomer.Cancel;
    qryCustomer.CancelUpdates;
    // возвращаем набор данных в обычный режим обновления
    qryCustomer.CachedUpdates := False;
    // и позволяем закрыть форму
    Action := caFree;
    Exit;
  end;

  try
    // подтверждаем изменения на уровне набора данных
    qryCustomer.Post;
    // стартуем транзакцию
    trWrite.StartTransaction;
    // если в наборе данных есть изменения
    if (qryCustomer.ApplyUpdates = 0) then
    begin
      // записываем их в БД
      qryCustomer.CommitUpdates;
      // и подтверждаем транзакцию
      trWrite.Commit;
    end
    else begin
      raise Exception.Create(qryCustomer.RowError.Message);
    end;
    qryCustomer.CachedUpdates := False;
    Action := caFree;
  except
    on E: Exception do
    begin
      // откатываем транзакцию
      if trWrite.Active then
        trWrite.Rollback;
      Application.ShowException(E);
      // Не закрываем окно, даём возможность исправить ошибку
      Action := caNone;
    end;
  end;
end;
                </programlisting>
            </para>
            <para>Из кода видно, что до тех пор, пока кнопка OK не нажата, пишущая транзакция не
                стартует вовсе. Таким образом, пишущая транзакция активна только на время переноса
                данных из буфера набора данных в базу данных. Поскольку мы копим в буфере не более
                одной записи, транзакция будет активна очень короткое время, что и
                требовалось.</para>

            <para>Справочник товаров делается аналогично справочнику заказчиков. Однако в нём мы
                продемонстрируем другой способ получения автоинкрементных значений.</para>

            <para>Основной запрос будет выглядеть следующим образом:
                <programlisting language="sql"> 
SELECT
    product_id,
    name,
    price,
    description
FROM product
ORDER BY name
                </programlisting>
            </para>
            <para>Свойство компонента TFDUpdateSQL.InsertSQL будет содержать следующий запрос:
                <programlisting language="sql"> 
INSERT INTO PRODUCT
(NAME, PRICE, DESCRIPTION)
VALUES (:NEW_NAME, :NEW_PRICE, :NEW_DESCRIPTION)
RETURNING PRODUCT_ID
                </programlisting>
            </para>
            <para>В этом запросе появилось предложение RETURNING, которое вернёт значение поля
                PRODUCT_ID после изменения его в BEFORE INSERT триггере. В этом случае не имеет
                смысла выставлять значение свойства UpdateOptions.GeneratorName. Кроме того, полю
                PRODUCT_ID необходимо выставить свойства Required = False и ReadOnly = True,
                поскольку значение этого свойства не вносится напрямую. В остальном всё примерно
                также как это организовано для справочника производителей.</para>
        </section>

        <section>
            <title>Создание журналов</title>

            <para>В нашем приложении будет один журнал «Счёт-фактуры». В отличие от справочников
                журналы содержат довольно большое количество записей и являются часто
                пополняемыми.</para>

            <para>Счёт-фактура — состоит из заголовка, где описываются общие атрибуты (номер, дата,
                заказчик …), и строк счёт-фактуры со списком товаром, их количеством, стоимостью и
                т.д. Для таких документов удобно иметь два грида: в главном отображаются данные о
                шапке документа, а в детализирующем — список товаров. Таким образом, на форму
                документа нам потребуется поместить два компонента TDBGrid, к каждому из которых
                привязать свой TDataSource, которые в свою очередь будут привязаны к своим TFDQuery.
                В нашем случае набор данных с шапками документы будет называться qryInvoice, а со
                строками документа qryInvoiceLine.</para>

            <para>В свойстве Transaction обоих наборов данных укажем ReadOnly транзакцию trRead,
                которая была создана в главном датамодуле проекта. В свойстве UpdateTransaction
                указываем транзакцию trWrite, в свойстве Connection — соединение, расположенное в
                главном датамодуле.</para>

            <para>Большинство журналов содержат поле с датой создания документа. Чтобы уменьшить
                количество выбираемых данных обычно принято вводить такое понятие как рабочий период
                для того, чтобы уменьшить объём данных передаваемый на клиента. Рабочий период — это
                диапазон дат, внутри которого требуются рабочие документы. Поскольку приложение
                может содержать более одного журнала, то имеет смысл разместить переменные,
                содержащие дату начала и окончания рабочего периода, в глобальном датамодуле dmMain,
                который, так или иначе, используется всеми модулями, работающими с БД. При старте
                приложения рабочий период обычно инициализируется датой начала и окончания текущего
                квартала (могут быть другие варианты). В ходе работы приложения можно изменить
                рабочий период по желанию пользователя.</para>

            <para>
                <figure>
                    <title>Форма журнала Invoices</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-invoices-form.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Форма журнала Invoices.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Поскольку чаще всего требуются именно последние введённые документы, то имеет
                смысл сортировать их по дате в обратном порядке. С учётом вышесказанного, в свойстве
                SQL набора данных qryInvoice запрос будет выглядеть следующим образом:
                <programlisting language="sql"> 
SELECT
  invoice.invoice_id AS invoice_id,
  invoice.customer_id AS customer_id,
  customer.NAME AS customer_name,
  invoice.invoice_date AS invoice_date,
  invoice.total_sale AS total_sale,
  IIF(invoice.payed=1, 'Yes', 'No') AS payed 
FROM
  invoice
  JOIN customer ON customer.customer_id = invoice.customer_id 
WHERE invoice.invoice_date BETWEEN :date_begin AND :date_end
ORDER BY invoice.invoice_date DESC
                </programlisting>
            </para>

            <para>При открытии этого набора данных необходимо будет инициализировать параметры
                запроса:
                <programlisting language="delphi"> 
qryInvoice.ParamByName('date_begin').AsSqlTimeStamp := dmMain.BeginDateSt;
qryInvoice.ParamByName('date_end').AsSqlTimeStamp := dmMain.EndDateSt;
qryInvoice.Open;
                </programlisting>
            </para>

            <para>Все операции над счёт-фактурой будем производить с помощью хранимых процедур, хотя
                в более простых случаях это можно делать и с помощью обычных запросов
                INSERT/UPDATE/DELETE. </para>

            <para>Каждую хранимую процедуру будем выполнять как отдельный запрос в компонентах
                TFDCommand. Этот компонент не является предком TFDRdbmsDataSet, не буферизирует
                данные и возвращает максимум одну строку результата, поэтому его использование несёт
                меньше накладных расходов для запросов, не возвращающих данные. Поскольку наши
                хранимые процедуры выполняют модификацию данных, то свойство Transaction компонентов
                TFDCommand необходимо установить транзакцию trWrite.</para>

            <note>
                <para>Хранимые процедуры вставки, редактирования и добавления записи можно также
                    разместить в соответствующих свойствах компонента TFDUpdateSQL.</para>
            </note>

            <para>Для работы с шапкой счёт-фактуры предусмотрено четыре операции: добавление,
                редактирование, удаление и установка признака «оплачено». Как только счёт-фактура
                оплачена, мы запрещаем любые её модификации, как в шапке, так и в строках. Это
                сделано на уровне хранимых процедур. Приведём тексты запросов для вызова хранимых
                процедур.</para>

            <formalpara>
                <title>qryAddInvoice.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_add_invoice(
  NEXT VALUE FOR gen_invoice_id, 
  :CUSTOMER_ID, 
  :INVOICE_DATE
)
                </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>qryEditInvoice.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_edit_invoice(
  :INVOICE_ID, 
  :CUSTOMER_ID, 
  :INVOICE_DATE
)
                </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>qryDeleteInvoice.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_delete_invoice(:INVOICE_ID)
                </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>qryPayForInvoice.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_pay_for_inovice(:invoice_id)
                </programlisting>
                </para>
            </formalpara>

            <para>Поскольку наши хранимые процедуры вызываются не из компонента TFDUpdateSQL, то
                после их выполнения необходимо вызвать qryInvoice.Refresh для обновления данных в
                гриде.</para>

            <para>Вызов хранимых процедур, для которых не требуется ввод данных, производится
                следующим образом:
                <programlisting language="delphi"> 
if MessageDlg('Вы действительно хотите удалить счёт фактуру?', mtConfirmation,
  [mbYes, mbNo], 0) = mrYes then
begin
  // Стартуем транзакцию
  trWrite.StartTransaction;
  try
    qryDeleteInvoice.ParamByName('INVOICE_ID').AsInteger :=
      qryInvoice.FieldByName('INVOICE_ID').AsInteger;
    // выполнение хранимой процедуры
    qryDeleteInvoice.Execute;
    // подтверждение транзакции
    trWrite.Commit;
    // обновление данных в гриде
    qryInvoice.Refresh;
  except
    on E: EFDDBEngineException do
    begin
      if trWrite.Active then
        trWrite.Rollback;
      Application.ShowException(E);
    end;
  end;
end;
                </programlisting>
            </para>

            <para>Для добавления новой записи и редактирования существующей, как и в случае со
                справочниками мы будем использовать модальные формы. В данном случае мы не будем
                использовать DBAware компоненты. Ещё одна особенность - для выбора заказчика мы
                будем использовать компонент TButtonedEdit. Он будет отображать наименование
                текущего заказчика, а по нажатию кнопки вызывать модальную форму с гридом для выбора
                заказчика. Конечно, можно было бы воспользоваться чем-то вроде TDBLookupCombobox,
                но, во-первых заказчиков может быть очень много и пролистывать такой выпадающий
                список будет неудобно, во-вторых для поиска нужного заказчика одного названия может
                быть недостаточно.</para>

            <para>
                <figure>
                    <title>Форма редактирования счёт-фактуры</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-editinvoice-form.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Форма редактирования счёт-фактуры.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>В качестве модальной окна для выбора заказчика используем ту же форму, что была
                создана для ввода заказчиков. Код обработчика нажатия кнопки в компоненте
                TButtonedEdit будет выглядеть следующим образом:
                <programlisting language="delphi"> 
procedure TEditInvoiceForm.edtCustomerRightButtonClick(Sender: TObject);
var
  xSelectForm: TCustomerForm;
begin
  xSelectForm := TCustomerForm.Create(Self);
  try
    xSelectForm.Visible := False;
    if xSelectForm.ShowModal = mrOK then
    begin
      FCustomerId := xSelectForm.qryCustomer.FieldByName('CUSTOMER_ID')
        .AsInteger;
      edtCustomer.Text := xSelectForm.qryCustomer.FieldByName('NAME').AsString;
    end;
  finally
    xSelectForm.Free;
  end;
end;
                </programlisting>
            </para>
            <para>Поскольку мы используем не DBAware компоненты, то при вызове формы редактирования
                нам будет необходимо инициализировать код заказчика и его наименование для
                отображения.
                <programlisting language="delphi"> 
procedure TInvoiceForm.actEditInvoiceExecute(Sender: TObject);
var
  xEditor: TEditInvoiceForm;
begin
  xEditor := TEditInvoiceForm.Create(Self);
  try
    xEditor.InvoiceForm := Self;
    xEditor.EditMode := emInvoiceEdit;
    xEditor.Caption := 'Редактирование счёт-фактуры';

    xEditor.InvoiceId := qryInvoice.FieldByName('INVOICE_ID').AsInteger;
    xEditor.SetCustomer(qryInvoice.FieldByName('CUSTOMER_ID').AsInteger,
                        qryInvoice.FieldByName('CUSTOMER_NAME').AsString);
    xEditor.InvoiceDate := qryInvoice.FieldByName('INVOICE_DATE').AsDateTime;

    xEditor.ShowModal;
  finally
    xEditor.Free;
  end;
end;

procedure TEditInvoiceForm.SetCustomer(ACustomerId: Integer;
  const ACustomerName: string);
begin
  FCustomerId := ACustomerId;
  edtCustomer.Text := ACustomerName;
end;
                </programlisting>
            </para>
            <para>Обработку добавления новой счёт-фактуры и редактирование существующей будем
                осуществлять в событии закрытия модальной формы, также, как это сделано для
                справочников. Однако здесь мы уже не будем переводить набор данных в режим
                CachedUpdates, поскольку модификация производится с помощью хранимых процедур, и мы
                не используем DBAware компоненты. </para>
            <para>
                <programlisting language="delphi"> 
procedure TEditInvoiceForm.FormClose(Sender: TObject; var Action: TCloseAction);
var
  xCustomerId: Integer;
begin
  // если форма закрыта не по нажатию кнопки OK, 
  // то вообще ничего не делаем. Транзакция не стартует.
  if ModalResult &lt;&gt; mrOK then
  begin
    Action := caFree;
    Exit;
  end;

  // Выполняем всё в короткой транзакции
  FInvoiceForm.trWrite.StartTransaction;
  try
    if FEditMode = emInvoiceAdd then
    begin
      // если FcustomerId = 0, то прамаетру CUSTOMER_ID выставляем значение NULL 
      if FCustomerId &lt;&gt; 0 then
        FInvoiceForm.qryAddInvoice.ParamByName('CUSTOMER_ID').AsInteger :=
          FCustomerId
      else
        FInvoiceForm.qryAddInvoice.ParamByName('CUSTOMER_ID').Clear;

      FInvoiceForm.qryAddInvoice.ParamByName('INVOICE_DATE').AsSQLTimeStamp :=
        DateTimeToSQLTimeStamp(FInvoiceDate);
      // выполяем хранимую процедуру для вставки записи
      FInvoiceForm.qryAddInvoice.Execute();
    end;
    if FEditMode = emInvoiceEdit then
    begin
      FInvoiceForm.qryEditInvoice.ParamByName('INVOICE_ID').AsInteger :=
        FInvoiceId;
      FInvoiceForm.qryEditInvoice.ParamByName('CUSTOMER_ID').AsInteger :=
        FCustomerId;
      FInvoiceForm.qryEditInvoice.ParamByName('INVOICE_DATE').AsSQLTimeStamp :=
        DateTimeToSQLTimeStamp(FInvoiceDate);
      // выполняем хранимую процедуру для редактирования записи
      FInvoiceForm.qryEditInvoice.Execute();
    end;
    // подтверждение транзакции
    FInvoiceForm.trWrite.Commit;
    // обновление данных в гриде
    FInvoiceForm.qryInvoice.Refresh;

    Action := caFree;
  except
    on E: Exception do
    begin
      if FInvoiceForm.trWrite.Active then
        FInvoiceForm.trWrite.Rollback;
      Application.ShowException(E);
      // Не закрываем модальное окно. Даём пользователю возможность
      // исправить ошибку
      Action := caNone;
    end;
  end;
end;
                </programlisting>
            </para>

            <para>Теперь перейдём к позициям накладной. Набору данных qryInvoiceLine установим
                свойство MasterSource = MasterSource, который привязан к qryInvoice, а свойство
                MasterFields = INVOICE_ID. В свойстве SQL напишем следующий запрос:
                <programlisting language="sql"> 
SELECT
    invoice_line.invoice_line_id AS invoice_line_id,
    invoice_line.invoice_id AS invoice_id,
    invoice_line.product_id AS product_id,
    product.name AS productname,
    invoice_line.quantity AS quantity,
    invoice_line.sale_price AS sale_price,
    invoice_line.quantity * invoice_line.sale_price AS total
FROM
    invoice_line
JOIN product ON product.product_id = invoice_line.product_id
WHERE invoice_line.invoice_id = :invoice_id
                </programlisting>
            </para>
            <para>Все модификации, как и в случае с шапкой счёт-фактуры, будем осуществлять с
                помощью хранимых процедур. Приведём тексты запросов для вызова хранимых
                процедур.</para>
            <formalpara>
                <title>qryAddInvoiceLine.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_add_invoice_line(
  :invoice_id, 
  :product_id, 
  :quantity
)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>qryEditInvoiceLine.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_edit_invoice_line(
  :invoice_line_id,
  :quantity
)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>qryDeleteInvoiceLine.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_delete_invoice_line(
  :invoice_line_id
)
                </programlisting>
                </para>
            </formalpara>

            <para>Форма для добавления новой записи и редактирования существующей, как и в случае с
                шапкой не будет использовать DBAware. Для выбора товара мы будем использовать
                компонент TButtonedEdit. Код обработчика нажатия кнопки в компоненте TButtonedEdit
                будет выглядеть следующим образом:
                <programlisting language="delphi"> 
procedure TEditInvoiceLineForm.edtProductRightButtonClick(Sender: TObject);
var
  xSelectForm: TGoodsForm;
begin
  // не позволяем изменять товар в режиме редактирования
  // это можно сделать только при добавлении новой позиции
  if FEditMode = emInvoiceLineEdit then
    Exit;

  xSelectForm := TGoodsForm.Create(Self);
  try
    xSelectForm.Visible := False;
    if xSelectForm.ShowModal = mrOK then
    begin
      FProductId := xSelectForm.qryGoods.FieldByName('PRODUCT_ID')
        .AsInteger;
      edtProduct.Text := xSelectForm.qryGoods.FieldByName('NAME').AsString;
      // в данном случае мы копируем также цену по прайсу
      edtPrice.Text := xSelectForm.qryGoods.FieldByName('PRICE').AsString;
    end;
  finally
    xSelectForm.Free;
  end;
end;
                </programlisting>
            </para>
            <para>Поскольку мы используем не DBAware компоненты, то при вызове формы редактирования
                нам будет необходимо инициализировать код товара, его наименование и стоимость для
                отображения.
                <programlisting language="delphi"> 
procedure TInvoiceForm.actEditInvoiceLineExecute(Sender: TObject);
var
  xEditor: TEditInvoiceLineForm;
begin
  xEditor := TEditInvoiceLineForm.Create(Self);
  try
    xEditor.InvoiceForm := Self;
    xEditor.EditMode := emInvoiceLineEdit;
    xEditor.Caption := 'Редактирование позиции';

    xEditor.InvoiceLineId := qryInvoiceLine.FieldByName('INVOICE_LINE_ID').AsInteger;
    xEditor.SetProduct(qryInvoiceLine.FieldByName('PRODUCT_ID').AsInteger,
                       qryInvoiceLine.FieldByName('PRODUCTNAME').AsString,
                       qryInvoiceLine.FieldByName('SALE_PRICE').AsCurrency);
    xEditor.Quantity := qryInvoiceLine.FieldByName('QUANTITY').AsInteger;

    xEditor.ShowModal;
  finally
    xEditor.Free;
  end;
end;

procedure TEditInvoiceLineForm.SetProduct(AProductId: Integer;
  AProductName: string; APrice: Currency);
begin
  FProductId := AProductId;
  edtProduct.Text := AProductName;
  edtPrice.Text := CurrToStr(APrice);
end;
                </programlisting>
            </para>
            <para>Обработку добавления новой позиции и редактирование существующей будем производить
                в событии закрытия модальной формы.
                <programlisting language="delphi"> 
procedure TEditInvoiceLineForm.FormClose(Sender: TObject;
  var Action: TCloseAction);
var
  xCustomerId: Integer;
begin
  // если форма закрыта не по нажатию кнопки OK, 
  // то вообще ничего не делаем. Транзакция не стартует.
  if ModalResult &lt;&gt; mrOK then
  begin
    Action := caFree;
    Exit;
  end;

  // Всё делаем в короткой транзакции
  FInvoiceForm.trWrite.StartTransaction;
  try
    if FEditMode = emInvoiceLineAdd then
    begin
      FInvoiceForm.qryAddInvoiceLine.ParamByName('INVOICE_ID').AsInteger :=
        FInvoiceId;

      if FProductId = 0 then
        raise Exception.Create('Не выбран товар');
        

      FInvoiceForm.qryAddInvoiceLine.ParamByName('PRODUCT_ID').AsInteger :=
        FProductId;
      FInvoiceForm.qryAddInvoiceLine.ParamByName('QUANTITY').AsInteger :=
        FQuantity;
      // Выполняем хранимую процедуру для добавления позиции 
      FInvoiceForm.qryAddInvoiceLine.Execute();
    end;

    if FEditMode = emInvoiceLineEdit then
    begin
      FInvoiceForm.qryEditInvoiceLine.ParamByName('INVOICE_LINE_ID').AsInteger :=
        FInvoiceLineId;
      FInvoiceForm.qryEditInvoiceLine.ParamByName('QUANTITY').AsInteger :=
        FQuantity;
      // Выполняем хранимую процедуру для редактирования  
      FInvoiceForm.qryEditInvoiceLine.Execute();
    end;
    // Подтверждаем транзакцию
    FInvoiceForm.trWrite.Commit;
    // Обновляем оба грида
    FInvoiceForm.qryInvoice.Refresh;
    FInvoiceForm.qryInvoiceLine.Refresh;

    Action := caFree;
  except
    on E: Exception do
    begin
      if FInvoiceForm.trWrite.Active then
        FInvoiceForm.trWrite.Rollback;
      Application.ShowException(E);
      // Не загрываем окно редактирования. Позволяем пользователю исправить ошибку
      Action := caNone;
    end;
  end;
end;
                </programlisting>
            </para>
            <para>В итоге у нас получилось приложение которое выглядит следующим образом: <figure>
                    <title>Скриншот работающего приложения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-screen.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Скриншот работающего приложения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
        </section>

        <section>
            <title>Заключение</title>

            <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_delphi_source.zip"
                    >Исходные коды примера приложения</link>
                <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_database.zip"
                    >Готовая БД</link>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ibase.ru"
                    >www.ibase.ru</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibsurgeon.com">www.ibsurgeon.com</link>
                <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="mailto:support@ibase.ru">support@ibase.ru</link>, <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="mailto:support@ib-aid.com">support@ib-aid.com</link></para>
        </section>
    </section>

    <section xml:id="app-ef-winform">
        <title>Создание приложений с использованием Entity Framework</title>

        <para>В данной главе будет описан процесс создания приложений для СУБД Firebird с
            использованием компонентов доступа Entity Framework и среды Visual Studio 2015. </para>

        <para><emphasis role="bold">ADO.NET Entity Framework</emphasis> (EF) —
            объектно-ориентированная технология доступа к данным, является object-relational mapping
            (ORM) решением для .NET Framework от Microsoft. Предоставляет возможность взаимодействия
            с объектами как посредством LINQ в виде LINQ to Entities, так и с использованием Entity
            SQL.</para>
        <para>Entity Framework предполагает три возможных способа взаимодействия с базой данных:<itemizedlist>
                <listitem>
                    <para><emphasis role="bold">Database first</emphasis>: Entity Framework создаёт
                        набор классов, которые отражают модель конкретной базы данных.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Model first</emphasis>: сначала разработчик создаёт
                        модель базы данных, по которой затем Entity Framework создаёт реальную базу
                        данных на сервере.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Code first</emphasis>: разработчик создаёт класс
                        модели данных, которые будут храниться в БД, а затем Entity Framework по
                        этой модели генерирует базу данных и её таблицы.</para>
                </listitem>
            </itemizedlist></para>
        <para>В своём приложении мы будем использовать подход Code First, однако вы без труда
            сможете использовать и другие подходы.</para>
        <note>
            <para>На самом деле у нас уже есть база данных. Поэтому будем просто писать код который
                бы привёл к созданию нашей БД.</para>
        </note>

        <section xml:id="app-dotnet-vsprepare">
            <title>Подготовка Visual Studio 2015 для работы с Firebird</title>

            <para>Для работы с Firebird вам необходимо установить:<itemizedlist>
                    <listitem>
                        <para>FirebirdSql.Data.FirebirdClient.dll</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework.Firebird.dll</para>
                    </listitem>
                    <listitem>
                        <para>DDEX Provider for Visual Studio</para>
                    </listitem>
                </itemizedlist></para>

            <para>Установка первых двух не вызывает никаких сложностей. В настоящий момент они
                распространяются и устанавливаются в проект с помощью NuGet. А вот последняя
                библиотека, предназначенная для работы мастеров Visual Studio, устанавливается не
                так легко и может потратить у вас много сил и времени.</para>
            <para>Добрые люди попытались автоматизировать процесс установки и включить установку
                всех компонентов в один дистрибутив (<link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://sourceforge.net/projects/firebird-4-8-0-ddex-installer/"
                    >http://sourceforge.net/projects/firebird-4-8-0-ddex-installer/</link>). Однако
                в ряде случаев вам может потребоваться ручная установка всех компонентов. В этом
                случае вам потребуется скачать:<itemizedlist>
                    <listitem>
                        <para>FirebirdSql.Data.FirebirdClient-4.10.0.0.msi (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/FirebirdSql.Data.FirebirdClient-4.10.0.0.msi/download"
                                >http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/FirebirdSql.Data.FirebirdClient-4.10.0.0.msi/download</link>)
                        </para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework.Firebird-4.10.0.0-NET45.7z (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/EntityFramework.Firebird-4.10.0.0-NET45.7z/download"
                                >http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/EntityFramework.Firebird-4.10.0.0-NET45.7z/download</link>)
                        </para>
                    </listitem>
                    <listitem>
                        <para>DDEXProvider-3.0.2.0.7z (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0.7z/download"
                                >http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0.7z/download</link>)
                        </para>
                    </listitem>
                    <listitem>
                        <para>DDEXProvider-3.0.2.0-src.7z (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0-src.7z/download"
                                >http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0-src.7z/download</link>)
                        </para>
                    </listitem>
                </itemizedlist></para>
            <para>Далее описан процесс установки:<orderedlist>
                    <listitem>
                        <para>Устанавливаем FirebirdSql.Data.FirebirdClient-4.10.0.0.msi</para>
                    </listitem>
                    <listitem>
                        <para>Распаковываем EntityFramework.Firebird-4.10.0.0-NET45.7z в папку с
                            установленным клиентом Firebird. У меня это папка <filename>c:\Program
                                Files (x86)\FirebirdClient\</filename>
                        </para>
                        <important>
                            <para>Это необходимо делать с правами администратора. Как и другие
                                действия с защищёнными директориями.</para>
                        </important>
                    </listitem>
                    <listitem>
                        <para>Необходимо установить сборки Firebird в GAC. Для удобство пописываем в
                            %PATH% путь до утилиты <application>gacutil</application> для .NET
                            Framework 4.5. У меня этот путь <filename>c:\Program Files
                                (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1
                                Tools\</filename></para>
                    </listitem>
                    <listitem>
                        <para>Запускаем командную строку <application>cmd</application> от имени
                            администратора и переходим в директорию с установленным клиентом.
                            <programlisting>
chdir "c:\Program Files (x86)\FirebirdClient"                                
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Теперь проверяем что FirebirdSql.Data.FirebirdClient установлен в GAC.
                            Для этого набираем команду <programlisting>
gacutil /l FirebirdSql.Data.FirebirdClient                                
</programlisting>
                            <screen>
Microsoft (R) .NET Global Assembly Cache Utility.  Version 4.0.30319.0
c Корпорация Майкрософт (Microsoft Corporation). Все права защищены.

В глобальном кэше сборок содержатся следующие сборки:
  FirebirdSql.Data.FirebirdClient, Version=4.10.0.0, Culture=neutral, PublicKeyToken=3750abcc3150b00c, processorArchitecture=MSIL

Число элементов = 1    
</screen>
                        </para>
                        <para>Если FirebirdSql.Data.FirebirdClient не был установлен в GAC, то
                            сделаем это с помощью команды
                            <programlisting>
gacutil /i FirebirdSql.Data.FirebirdClient.dll                               
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Теперь установим EntityFramework.Firebird в GAC
                            <programlisting>
gacutil /i EntityFramework.Firebird.dll                              
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Распаковываем <filename>DDEXProvider-3.0.2.0.7z</filename> в удобную
                            директорию. Я распаковал её в <filename>c:\Program Files
                                (x86)\FirebirdDDEX\</filename></para>
                    </listitem>
                    <listitem>
                        <para>Туда же распаковываем <filename>DDEXProvider-3.0.2.0-src.7z</filename>
                            содержимое поддиректории архива
                            <filename>/reg_files/VS2015</filename></para>
                        <note>
                            <para>Забавно, но по какой-то причине этих файлов нет в предыдущем
                                архиве со скомпилированными dll библиотеками, но они присутствуют в
                                архиве с исходными кодами.</para>
                        </note>
                    </listitem>
                    <listitem>
                        <para>Открываем файл <filename>FirebirdDDEXProvider64.reg</filename> с
                            помощью блокнота. Находим строчку, которая содержит
                                <filename>%path%</filename> и меняем его на полный путь к файлу
                                <filename>FirebirdSql.VisualStudio.DataTools.dll</filename>
                            <programlisting>
   "CodeBase"="c:\\Program Files (x86)\\FirebirdDDEX\\FirebirdSql.VisualStudio.DataTools.dll"                         
                        </programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Сохраняем этот файл, запускаем его. На запрос добавить информацию в
                            реестр нажимаем ДА.</para>
                    </listitem>
                    <listitem>
                        <para>Теперь нужно отредактировать файл machine.config, в моем случае он
                            находится по пути:
                                <filename>C:\Windows\Microsoft.NET\Framework\v4.0.30319\Config</filename></para>
                        <para>Открываем этот файл блокнотом. Находим секцию <programlisting language="xml">
<![CDATA[
  <system.data>
    <DbProviderFactories>

]]>                            
                        </programlisting> Добавляем в эту секцию
                            строчку: <programlisting language="xml">
<![CDATA[
<add name="FirebirdClient Data Provider" 
     invariant="FirebirdSql.Data.FirebirdClient" 
     description=".Net Framework Data Provider for Firebird" 
     type="FirebirdSql.Data.FirebirdClient.FirebirdClientFactory, 
           FirebirdSql.Data.FirebirdClient, Version=4.10.0.0, Culture=neutral, 
           PublicKeyToken=3750abcc3150b00c" />
]]>                            
                        </programlisting>
                        </para>
                        <note>
                            <para>Всё это действительно для версии 4.10.0.</para>
                        </note>
                        <para>То же самое проделаем для <filename>machine.config</filename>, который
                            находится в
                                <filename>c:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\</filename></para>

                        <para>Установка закончена.</para>

                        <para>Для проверки, что всё успешно установилось, запускаем Visual Studio
                            2015. Находим обозреватель серверов и пытаемся подключиться к одной из
                            существующих баз данных Firebird.</para>
                    </listitem>
                </orderedlist></para>
            <para>
                <figure>
                    <title>Добавление подключения в Visual Studio</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-odbc.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Добавление подключения в Visual Studio.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Выбор провайдера подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-select-datasource.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Выбор провайдера подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Настройка подключения к Firebird</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-fbprovider.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Настройка подключения к Firebird.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Успешное подключение</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-connok.png"/>
                        </imageobject>
                        <textobject>
                            <phrase>Успешное подключение.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
        </section>

        <section>
            <title>Создание проекта</title>

            <para>В данной главе мы рассмотрим пример создания Windows Forms приложения. Остальные
                типы приложений хоть и отличаются, но принципы работы с Firebird через Entity
                Framework остаются те же.</para>

            <para>Прежде всего, после создания Windows Forms проекта нам необходимо добавить с
                помощью менеджера пакетов NuGet следующие пакеты:<itemizedlist spacing="compact">
                    <listitem>
                        <para>FirebirdSql.Data.FirebirdClient</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework.Firebird</para>
                    </listitem>
                </itemizedlist></para>

            <para>Для этого необходимо щёлкнуть правой клавишей мыши по имени проекта в обозревателе
                решений и в выпадающем меню выбрать пункт «Управление пакетами NuGet». <figure>
                    <title>Контекстное меню проекта</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-vsmenu-nuget.png"/>
                        </imageobject>
                        <textobject>
                            <phrase>Контекстное меню проекта.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>В появившемся менеджере пакетов произвести поиск и установку необходимых пакетов. <figure>
                    <title>Контекстное меню проекта</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-nuget.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Контекстное меню проекта.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
        </section>

        <section xml:id="app-dotnet-createedm">
            <title>Создание EDM модели</title>

            <para>В своём приложении мы будем использовать подход Code First.</para>

            <para>Для создания модели EDM необходимо щёлкнуть правой клавишей мыши по имени проекта
                в обозревателе решений и выбрать пункт меню <guimenu>Добавить -> Создать
                    элемент</guimenu>. <figure>
                    <title>Добавление элемента</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-add-elem.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Добавление элемента.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Далее в мастере добавления нового элемента выбираем пункт «Модель ADO.NET EDM». <figure>
                    <title>Добавление модели ADO.NET EDM</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-add-model.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Добавление модели ADO.NET EDM.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Поскольку у нас уже существует база данных, то будем генерировать EDM модель из
                базы данных. <figure>
                    <title>Выбор типа модели</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-edm-master.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Выбор типа модели.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Теперь надо выбрать подключение, из которого будет создана модель. Если Такого
                подключения нет, то его надо создать. <figure>
                    <title>Выбор подключения для модели</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-edm-selectsource.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Выбор подключения для модели.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Параметры подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-connection-params.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Параметры подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Кроме основных параметров подключения могут потребоваться также указать ряд
                дополнительных параметров, например, уровень изолированности транзакций (по
                умолчанию Read Commited), использование пула подключений и т.д. Поскольку Entity
                Framework (как впрочем, ADO.NET в целом) использует отсоединённую модель
                взаимодействия, при которой каждое подключение и транзакция активна очень короткий
                промежуток времени, то я бы рекомендовал задать режим изолированности Snapshot. <figure>
                    <title>Дополнительные свойства подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-connection-properties.png"/>
                        </imageobject>
                        <textobject>
                            <phrase>Дополнительные свойства подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>В процессе работы мастера создания модели у вас спросят, как хранить строку
                подключения. <figure>
                    <title>Сохранение строки подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-save-connectionstring.png" width="680"
                            />
                        </imageobject>
                        <textobject>
                            <phrase>Сохранение строки подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Если вы строите веб приложение или трёхзвенку, где все пользователи будут работать
                с базой данных под одной и той же учётной записью, то смело выбирайте «Да». Если же
                ваше приложение должно запрашивать учётные данные для соединения с базой данных
                выбирайте «Нет». Впрочем, с мастерами гораздо более удобно работать, когда у вас
                выбран пункт «Да». Вы всегда можете это изменить в готовом приложении, просто
                отредактировав строку подключения в файле конфигурации приложения
                        <filename><replaceable>&lt;AppName&gt;</replaceable>.exe.conf</filename>.
                Строка подключения будет сохранена в секции <emphasis role="bold"
                    >connectionStrings</emphasis> примерно в таком виде <programlisting language="xml">
<![CDATA[
<add name="DbModel" 
     connectionString="character set=UTF8; data source=localhost; 
                       initial catalog=examples; port number=3050; 
                       user id=sysdba; dialect=3; isolationlevel=Snapshot; 
                       pooling=True; password=masterkey;" 
     providerName="FirebirdSql.Data.FirebirdClient" />
]]>                    
                </programlisting>
            </para>
            <para>Для того чтобы файл конфигурации перестал хранить конфиденциальную информацию
                просто удалите из строки подключения <emphasis role="italic"
                    >password=masterkey;</emphasis></para>

            <note>
                <title>Замечание о работе с Firebird 3.0</title>
                <para> К сожалению текущий ADO .Net провайдер для Firebird (версия 5.9.0.0) не
                    поддерживает шифрование сетевого трафика (по умолчанию в Firebird 3.0). Поэтому
                    если вы желаете работать с Firebird 3.0, то вам необходимо изменить некоторые
                    настройки в <filename>firebird.conf</filename> (или в
                        <filename>databases.conf</filename> для конкретной БД), чтобы Firebird
                    работал без использования шифрования сети. Для этого необходимо поменять
                    следующие настройки:
                    <programlisting>
WireCrypt = Disabled                    
                </programlisting>
                </para>
            </note>

            <para>Далее у вас спросят, какие таблицы и представления должны быть включены модель. <figure>
                    <title>Сохранение строки подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-select-edm-tables.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Сохранение строки подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>В принципе EDM модель готова. После работы этого мастера у вас должно появиться 5
                новых файлов. Один файл модели и четыре файла описывающих каждую из сущностей
                модели.</para>

            <para>Давайте посмотрим один из сгенерированных файлов описывающих сущность INVOICE. <programlisting language="csharp">
<![CDATA[                
[Table("Firebird.INVOICE")]
public partial class INVOICE
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", 
       "CA2214:DoNotCallOverridableMethodsInConstructors")]
    public INVOICE()
    {
        INVOICE_LINES = new HashSet<INVOICE_LINE>();
    }

    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.None)]
    public int INVOICE_ID { get; set; }

    public int CUSTOMER_ID { get; set; }

    public DateTime? INVOICE_DATE { get; set; }

    public decimal? TOTAL_SALE { get; set; }

    public short PAYED { get; set; }

    public virtual CUSTOMER CUSTOMER { get; set; }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", 
       "CA2227:CollectionPropertiesShouldBeReadOnly")]
    public virtual ICollection<INVOICE_LINE> INVOICE_LINES { get; set; }
}  
]]>
            </programlisting>
            </para>
            <para>Класс содержат свойства, которые отображают поля таблицы INVOICE. Каждое из таких
                свойств снабжено атрибутами, описывающими ограничения. Подробнее об различных
                атрибутах вы можете почитать в документации Майкрософт <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://msdn.microsoft.com/en-us/data/jj591583">Code First Data
                    Annotations</link>.</para>
            <para>Кроме того, было сгенерировано ещё два навигационных свойства CUSTOMER и
                INVOICE_LINES. Первое содержит ссылку на сущность поставщика, второе — коллекцию
                строк накладных. Оно было сгенерировано потому, что таблица INVOICE_LINE имеет
                внешний ключ на таблицу INVOICE. Конечно, вы можете удалить это свойство из сущности
                INVOICE, но делать это вовсе не обязательно. Дело в том, что в данном случае
                свойства CUSTOMER и INVOICE_LINES использует так называемую «ленивую загрузку». При
                таком загрузка осуществляется при первом обращении к объекту, т.е. если связанные
                данные не нужны, то они не подгружаются. Однако при первом же обращении к
                навигационному свойству эти данные автоматически подгружаются из БД.</para>
            <para>При использовании ленивой загрузки надо иметь в виду некоторые моменты при
                объявлении классов. Так, классы, использующие ленивую загрузку должны быть
                публичными, а их свойства должны иметь модификаторы <emphasis role="bold"
                    >public</emphasis> и <emphasis role="bold">virtual</emphasis>.</para>
            <para>Теперь откроем файл <filename>DbModel.cs</filename> описывающий модель в целом. <programlisting language="csharp">
<![CDATA[  
public partial class DbModel : DbContext
{
    public DbModel()
        : base("name=DbModel")
    {
    }

    public virtual DbSet<CUSTOMER> CUSTOMERS { get; set; }
    public virtual DbSet<INVOICE> INVOICES { get; set; }
    public virtual DbSet<INVOICE_LINE> INVOICE_LINES { get; set; }
    public virtual DbSet<PRODUCT> PRODUCTS { get; set; }

    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        modelBuilder.Entity<CUSTOMER>()
            .Property(e => e.ZIPCODE)
            .IsFixedLength();

        modelBuilder.Entity<CUSTOMER>()
            .HasMany(e => e.INVOICES)
            .WithRequired(e => e.CUSTOMER)
            .WillCascadeOnDelete(false);

        modelBuilder.Entity<PRODUCT>()
            .HasMany(e => e.INVOICE_LINES)
            .WithRequired(e => e.PRODUCT)
            .WillCascadeOnDelete(false);

        modelBuilder.Entity<INVOICE>()
            .HasMany(e => e.INVOICE_LINES)
            .WithRequired(e => e.INVOICE)
            .WillCascadeOnDelete(false);

    }
}
]]>
            </programlisting>
            </para>

            <para>Здесь мы видим свойства описывающие набор данных для каждой сущности. А так же
                задание дополнительных свойств создания модели с помощью Fluent API. Полное описание
                Fluent API вы может прочитать в документации Microsoft <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://msdn.microsoft.com/en-us/data/jj591617.aspx"
                    >Configuring/Mapping Properties and Types with the Fluent API</link>.</para>
            <para>Зададим в методе OnModelCreating точность для свойств типа decimal с помощью
                Fluent API. Для этого допишем следующие строчки <programlisting language="csharp">
<![CDATA[ 
            modelBuilder.Entity<PRODUCT>()
                .Property(p => p.PRICE)
                .HasPrecision(15, 2);
            modelBuilder.Entity<INVOICE>()
                .Property(p => p.TOTAL_SALE)
                .HasPrecision(15, 2);

            modelBuilder.Entity<INVOICE_LINE>()
                .Property(p => p.SALE_PRICE)
                .HasPrecision(15, 2);

            modelBuilder.Entity<INVOICE_LINE>()
                .Property(p => p.QUANTITY)
                .HasPrecision(15, 0);
]]>
            </programlisting>
            </para>
        </section>

        <section>
            <title>Создание пользовательского интерфейса</title>

            <para>В нашем приложении мы создадим два справочника: справочник товаров и справочник
                заказчиков. Каждый справочник содержит сетку DataGridView, панель с кнопками
                ToolStrip, а также компонент BindingSource, который служит для упрощения привязки
                данных к элементам управления в форме. <figure>
                    <title>Форма справочника заказчиков</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-customer-form.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Форма справочника заказчиков.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>Поскольку по функционалу оба справочника похожи и реализованы схожим образом
                описывать мы будем только один.</para>

            <section xml:id="app-dotnet-getcontext">
                <title>Получение контекста</title>

                <para>Для работы с нашей моделью нам потребуется метод для получения контекста (или
                    модели). В принципе для этого достаточно выполнить:
                    <programlisting language="csharp">
DbModel dbContext = new DbModel();                    
                </programlisting>
                </para>
                <para>Однако, если в строке подключения не хранятся конфиденциальные данные
                    (например, пароль), а мы инициализируем во время авторизации их при старте
                    приложения, то нам потребуется специальный метод для хранения и восстановления
                    строки подключения или сохранение ранее созданного контекста. Для этого создадим
                    специальный класс, который помимо метода для получения контекста будет также
                    содержать некоторые глобальные переменные уровня приложения, например рабочий
                    период. <programlisting language="csharp">
<![CDATA[                        
static class AppVariables
{
    private static DbModel dbContext = null;

    /// <summary>
    /// Дата начала рабочего периода
    /// </summary>
    public static DateTime StartDate { get; set; }

    /// <summary>
    /// Дата окончания рабочего периода
    /// </summary>
    public static DateTime FinishDate { get; set; }

    /// <summary>
    /// Возвращает экземпляр модели (контекста)
    /// </summary>
    /// <returns>Модель</returns>
    public static DbModel CreateDbContext() {
        dbContext = dbContext ?? new DbModel();
        return dbContext;        
    }
}                    
]]>
                </programlisting>
                </para>
                <para>Сама строка подключения инициализируется при старте приложения, после того как
                    успешно прошла авторизация. Для этого в обработчике события Load главной формы
                    напишем следующий код. <programlisting language="csharp">
<![CDATA[                        
private void MainForm_Load(object sender, EventArgs e) {
    var dialog = new LoginForm();
    if (dialog.ShowDialog() == DialogResult.OK)
    {
        var dbContext = AppVariables.getDbContext();

        try
        {
            string s = dbContext.Database.Connection.ConnectionString;
            var builder = new FbConnectionStringBuilder(s);
            builder.UserID = dialog.UserName;
            builder.Password = dialog.Password;

            dbContext.Database.Connection.ConnectionString = builder.ConnectionString;

            // пробуем подключится
            dbContext.Database.Connection.Open();
        }
        catch (Exception ex)
        {
            // отображаем ошибку
            MessageBox.Show(ex.Message, "Error");
            Application.Exit();
        }
    }
    else
        Application.Exit();
}                  
]]>
                </programlisting>
                </para>
                <para>Теперь для получения контекста мы будем использовать статический метод
                    CreateDbContext.
                    <programlisting language="csharp">
var dbContext = AppVariables.getDbContext();                   
                </programlisting>
                </para>
            </section>

            <section>
                <title>Работа с данными</title>

                <para>Сами по себе сущности модели не содержат никаких данных. Самым простым
                    способом загрузить данные является вызовам метода Load, например вот так: <programlisting language="csharp">
<![CDATA[                        
private void LoadCustomersData()
{
    dbContext.CUSTOMERS.Load(); 
    var customers = dbContext.CUSTOMERS.Local;

    bindingSource.DataSource = customers.ToBindingList();    
}

private void CustomerForm_Load(object sender, EventArgs e)
{
    LoadCustomersData();

    dataGridView.DataSource = bindingSource;
    dataGridView.Columns["CUSTOMER_ID"].Visible = false;
}                 
]]>
                </programlisting>
                </para>

                <para>Однако такой способ имеет ряд недостатков:<orderedlist>
                        <listitem>
                            <para>Метод Load загружает сразу все данные из таблицы CUSTOMER в
                                память.</para>
                        </listitem>
                        <listitem>
                            <para>Ленивые свойства ( INVOICES ) хоть и не загружаются сразу, а лишь
                                по мере обращения к ним, всё равно будут загружены при отображении
                                записей в гриде. Причём ровно столько раз, сколько записей будет
                                выведено.</para>
                        </listitem>
                        <listitem>
                            <para>Порядок записей неопределён.</para>
                        </listitem>
                    </orderedlist></para>

                <para>Для обхода этих недостатком мы будем использовать технологию LINQ (Language
                    Integrated Query), или точнее<emphasis role="bold">LINQ to Entities</emphasis>.
                    LINQ to Entities предлагает простой и интуитивно понятный подход для получения
                    данных с помощью выражений, которые по форме близки выражениям языка SQL. С
                    синтаксисом LINQ вы можете ознакомиться по <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="https://msdn.microsoft.com/ru-ru/library/bb386964(v=vs.110).aspx"
                        >LINQ to Entities</link>.</para>
                <para>Методы расширений LINQ могут возвращать два объекта: <emphasis role="bold"
                        >IEnumerable</emphasis> и <emphasis role="bold">IQueryable</emphasis>.
                    Интерфейс IQueryable наследуется от IEnumerable, поэтому по идее объект
                    IQueryable это и есть также объект IEnumerable. Но между ними есть существенная
                    разница.</para>
                <para>Интерфейс IEnumerable находится в пространстве имён <emphasis role="bold"
                        >System.Collections</emphasis>. Объект IEnumerable представляет набор данных
                    в памяти и может перемещаться по этим данным только вперёд. При выполнении
                    запроса IEnumerable загружает все данные, и если нам надо выполнить их
                    фильтрацию, то сама фильтрация происходит на стороне клиента.</para>
                <para>Интерфейс IQueryable располагается в пространстве имён System.Linq. Объект
                    IQueryable предоставляет удалённый доступ к базе данных и позволяет перемещаться
                    по данным как в прямом порядке от начала до конца, так и в обратном порядке. В
                    процессе создания запроса, возвращаемым объектом которого является IQueryable,
                    происходит оптимизация запроса. В итоге в процессе его выполнения тратится
                    меньше памяти, меньше пропускной способности сети.</para>
                <para>Свойство Local возвращает интерфейс IEnumerable. Поэтому мы можем составлять
                    LINQ запросы к нему. <programlisting language="csharp">
<![CDATA[                        
private void LoadCustomersData()
{
    var dbContext = AppVariables.getDbContext();
    dbContext.CUSTOMERS.Load(); 
    
    var customers = 
        from customer in dbContext.CUSTOMERS.Local
        orderby customer.NAME
        select new customer;

    bindingSource.DataSource = customers.ToBindingList();
}                 
]]>
                </programlisting>
                </para>

                <para>Однако как уже сказано этот запрос будет выполняться над данными в памяти. В
                    принципе для маленьких таблиц, которым не требуется предварительная фильтрация
                    это приемлемо.</para>
                <para>Для того чтобы LINQ запрос был преобразован в SQL и выполнялся на стороне
                    сервера нам необходимо использовать в LINQ запросе вместо обращения к свойству
                        <function>dbContext.CUSTOMERS.Local</function> обращаться сразу к
                        <function>dbContext.CUSTOMERS</function>. В этом случае нам не потребуется
                    предварительный вызов <function>dbContext.CUSTOMERS.Load();</function> для
                    загрузки коллекции в память.</para>
                <para>Однако тут нас подстерегает одна маленькая засада. Объекты IQueryable не умеют
                    возвращать BindingList. BindingList является базовым классом для создания
                    двустороннего механизма привязки данных. Из интерфейса IQueryable мы можем
                    получить обычный список посредством вызова ToList, но в этом случае мы лишаемся
                    приятных бонусов, таких как сортировка в гриде и многих других. Кстати в .NET
                    Framework 5 это уже исправили и создали специальное расширение. Сделаем своё
                    расширение, которое будет делать тоже самое. <programlisting language="csharp">
<![CDATA[                        
public static class DbExtensions
{
    // Внутренний класс для маппинга на него значения генератора
    private class IdResult
    {
        public int Id { get; set; }
    }

    // Преобразование IQueryable в BindingList
    public static BindingList<T> ToBindingList<T>
        (this IQueryable<T> source) where T : class
    {
        return (new ObservableCollection<T>(source)).ToBindingList();
    }

    // Получение следующего значения последовательности
    public static int NextValueFor(this DbModel dbContext, string genName)
    {
        string sql = String.Format(
            "SELECT NEXT VALUE FOR {0} AS Id FROM RDB$DATABASE", genName);
        return dbContext.Database.SqlQuery<IdResult>(sql).First().Id;
    }

    // Отсоединение всех объектов коллекции DbSet от контекста
    // Полезно для обновлении кеша
    public static void DetachAll<T>(this DbModel dbContext, DbSet<T> dbSet) 
        where T : class 
    {         
        foreach (var obj in dbSet.Local.ToList())
        {
            dbContext.Entry(obj).State = EntityState.Detached;
        }
    }

    // Обновление всех изменённых объектов в коллекции
    public static void Refresh(this DbModel dbContext, RefreshMode mode, 
       IEnumerable collection)
    {
        var objectContext = ((IObjectContextAdapter)dbContext).ObjectContext;
        objectContext.Refresh(mode, collection);
    }

    // Обновление объекта
    public static void Refresh(this DbModel dbContext, RefreshMode mode, 
         object entity)
    {
        var objectContext = ((IObjectContextAdapter)dbContext).ObjectContext;
        objectContext.Refresh(mode, entity);
    }
}                
]]>
                </programlisting> В этом же классе присутствует ещё несколько расширений. </para>

                <para>Метод <function>NextValueFor</function> предназначен для получения следующего
                    значения генератора. Метод <function>dbContext.Database.SqlQuery</function>
                    позволяет выполнять SQL запросы напрямую и отображать их результаты на некоторую
                    сущность (проекцию). Вы можете воспользоваться им, если вам потребуется
                    выполнить SQL запрос напрямую.</para>
                <para>Метод <function>DetachAll</function> предназначен для отсоединения всех
                    объектов коллекции DBSet от контекста. Это необходимо для обновления внутреннего
                    кеша. Дело в том, что в рамках контекста все извлекаемые кешируются и не
                    извлекаются из базы данных снова. Однако это не всегда полезно, поскольку
                    затрудняет получение изменённых записей сделанных в другом контексте. </para>

                <note>
                    <para>В Web приложениях контекст обычно живёт очень короткое время, а новый
                        контекст имеет не заполненный кеш.</para>
                </note>

                <para>Метод <function>Refresh</function> предназначен для обновления свойств
                    объекта-сущности. Он полезен для обновления свойств объекта после его
                    редактирования или добавления.</para>

                <para>Таким образом, наш код загрузки данных будет выглядеть так <programlisting language="csharp">
<![CDATA[                        
private void LoadCustomersData()
{
    var dbContext = AppVariables.getDbContext();
    // отсоединяем все загруженные объекты
    // это необходимо чтобы обновился внутренний кеш
    // при второй и последующих вызовах этого метода
    dbContext.DetachAll(dbContext.CUSTOMERS);

    var customers =
          from customer in dbContext.CUSTOMERS
          orderby customer.NAME
          select customer;


    bindingSource.DataSource = customers.ToBindingList();
}

private void CustomerForm_Load(object sender, EventArgs e)
{
    LoadCustomersData();

    dataGridView.DataSource = bindingSource;
    dataGridView.Columns["INVOICES"].Visible = false;
    dataGridView.Columns["CUSTOMER_ID"].Visible = false;
    dataGridView.Columns["NAME"].HeaderText = "Name";
    dataGridView.Columns["ADDRESS"].HeaderText = "Address";
    dataGridView.Columns["ZIPCODE"].HeaderText = "ZipCode";
    dataGridView.Columns["PHONE"].HeaderText = "Phone";
}               
]]>
                </programlisting>
                </para>

                <para>Код обработчика события на нажатие кнопки добавления выглядит следующим
                    образом. <programlisting language="csharp">
<![CDATA[                        
private void btnAdd_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    // создание нового экземпляра сущности        
    var customer = (CUSTOMER)bindingSource.AddNew();
    // создаём форму для редактирования
    using (CustomerEditorForm editor = new CustomerEditorForm()) {
        editor.Text = "Добавление заказчика";
        editor.Customer = customer;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
           if (editor.DialogResult == DialogResult.OK) {
              try {
                 // получаем новое значение генератора
                 // и присваиваем его идентификатору
                 customer.CUSTOMER_ID = dbContext.NextValueFor("GEN_CUSTOMER_ID");
                 // добавляем нового заказчика
                 dbContext.CUSTOMERS.Add(customer);
                 // пытаемся сохранить изменения
                 dbContext.SaveChanges();
                 // и обновить текущую запись
                 dbContext.Refresh(RefreshMode.StoreWins, customer);
              }
              catch (Exception ex) {
                 // отображаем ошибку
                 MessageBox.Show(ex.Message, "Error");
                 // не закрываем форму для возможности исправления ошибки
                 fe.Cancel = true;
              }
           }
           else
               bindingSource.CancelEdit();

        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}               
]]>
                </programlisting>
                </para>
                <para>При добавлении новой записи мы получаем значение следующего идентификатора с
                    помощью генератора. Мы могли бы не инициализировать значение идентификатора, и в
                    этом случае отработал бы BEFORE INSERT триггер, который всё равно дёрнул бы
                    следующее значение генератора. Однако в этом случае мы не смогли бы обновить
                    вновь добавленную запись.</para>

                <para>Код обработчика события на нажатие кнопки редактирования выглядит следующим
                    образом. <programlisting language="csharp">
<![CDATA[                        
private void btnEdit_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    // получаем сущность
    var customer = (CUSTOMER)bindingSource.Current;
    // создаём форму для редактирования
    using (CustomerEditorForm editor = new CustomerEditorForm()) {
        editor.Text = "Редактирование заказчика";
        editor.Customer = customer;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
            if (editor.DialogResult == DialogResult.OK) {
                try {
                    // пытаемся сохранить изменения
                    dbContext.SaveChanges();
                    dbContext.Refresh(RefreshMode.StoreWins, customer);
                    // обновляем все связанные контролы
                    bindingSource.ResetCurrentItem();
                }
                catch (Exception ex) {
                    // отображаем ошибку
                    MessageBox.Show(ex.Message, "Error");
                    // не закрываем форму для возможности исправления ошибки
                    fe.Cancel = true;
                }
            }
            else
                bindingSource.CancelEdit();

        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}             
]]>
                </programlisting>
                </para>
                <para>Форма для редактирования заказчика выглядит следующим образом. <figure>
                        <title>Форма редактирования заказчика</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/dotnet-customer-editor-form.png"/>
                            </imageobject>
                            <textobject>
                                <phrase>Форма редактирования заказчика.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>

                <para>Код привязки к данным очень прост. <programlisting language="csharp">
<![CDATA[                        
public CUSTOMER Customer { get; set; }

private void CustomerEditorForm_Load(object sender, EventArgs e)
{
    edtName.DataBindings.Add("Text", this.Customer, "NAME");
    edtAddress.DataBindings.Add("Text", this.Customer, "ADDRESS");
    edtZipCode.DataBindings.Add("Text", this.Customer, "ZIPCODE");
    edtPhone.DataBindings.Add("Text", this.Customer, "PHONE");
}             
]]>
                </programlisting>
                </para>

                <para>Код обработчика события на нажатие кнопки удаления выглядит следующим образом. <programlisting language="csharp">
<![CDATA[                        
private void btnDelete_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    var result = MessageBox.Show("Вы действительно хотите удалить заказчика?",
                "Подтверждение",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);
    if (result == DialogResult.Yes) {
       // получаем сущность 
       var customer = (CUSTOMER)bindingSource.Current;
       try {
           dbContext.CUSTOMERS.Remove(customer);
           // пытаемся сохранить изменения
           dbContext.SaveChanges();
           // удаляем из связанного списка
           bindingSource.RemoveCurrent();
       }
       catch (Exception ex) {
           // отображаем ошибку
           MessageBox.Show(ex.Message, "Error");
       }
    }
}             
]]>
                </programlisting>
                </para>
            </section>

            <section>
                <title>Журналы</title>

                <para>В нашем приложении будет один журнал «Счёт-фактуры». В отличие от справочников
                    журналы содержат довольно большое количество записей и являются часто
                    пополняемыми.</para>
                <para>Счёт-фактура — состоит из заголовка, где описываются общие атрибуты (номер,
                    дата, заказчик …), и строк счёт-фактуры со списком товаром, их количеством,
                    стоимостью и т.д. Для таких документов удобно иметь два грида: в главном
                    отображаются данные о шапке документа, а в детализирующем — список товаров.
                    Таким образом, на форму документа нам потребуется поместить два компонента
                    DataGridView, к каждому из которых привязать свой BindingSource <figure>
                        <title>Форма журнала счёт-фактур</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/dotnet-invoice-form.png" width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Форма журнала счёт-фактур.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>Большинство журналов содержат поле с датой создания документа. Чтобы уменьшить
                    количество выбираемых данных обычно принято вводить такое понятие как рабочий
                    период для того, чтобы уменьшить объём данных передаваемый на клиента. Рабочий
                    период — это диапазон дат, внутри которого требуются рабочие документы.
                    Поскольку приложение может содержать более одного журнала, то имеет смысл
                    разместить переменные, содержащие дату начала и окончания рабочего периода, в
                    глобальном модуле AppVariables (см. <link linkend="app-dotnet-getcontext"
                        >Получение контекста</link>), который, так или иначе, используется всеми
                    модулями, работающими с БД. При старте приложения рабочий период обычно
                    инициализируется датой начала и окончания текущего квартала (могут быть другие
                    варианты). В ходе работы приложения можно изменить рабочий период по желанию
                    пользователя.</para>
                <para>Поскольку чаще всего требуются именно последние введённые документы, то имеет
                    смысл сортировать их по дате в обратном порядке. Извлекать данные, как и в
                    случае со справочниками будем при помощи LINQ. С учётом вышесказанного, метод
                    для загрузки данных шапок счёт-фактур будет выглядеть следующим образом: <programlisting language="csharp">
<![CDATA[                        
public void LoadInvoicesData() {
    var dbContext = AppVariables.getDbContext();

    // запрос на LINQ преобразуется в SQL
    var invoices =
        from invoice in dbContext.INVOICES
        where (invoice.INVOICE_DATE >= AppVariables.StartDate) &&
              (invoice.INVOICE_DATE <= AppVariables.FinishDate)
        orderby invoice.INVOICE_DATE descending
        select new InvoiceView
        {
            Id = invoice.INVOICE_ID,
            Cusomer_Id = invoice.CUSTOMER_ID,
            Customer = invoice.CUSTOMER.NAME,
            Date = invoice.INVOICE_DATE,
            Amount = invoice.TOTAL_SALE,
            Payed = (invoice.PAYED == 1) ? "Yes" : "No"
        };

    masterBinding.DataSource = invoices.ToBindingList();
}          
]]>
                </programlisting>
                </para>
                <para>В качестве проекции мы использовали не анонимный тип, а класс InvoiceView. Это
                    упрощает приведение типа. Определение класса InvoiceView выглядит следующим
                    образом: <programlisting language="csharp">
<![CDATA[                        
public class InvoiceView {
    public int Id { get; set; }
    public int Cusomer_Id { get; set; }
    public string Customer { get; set; }
    public DateTime? Date { get; set; }
    public decimal? Amount { get; set; }
    public string Payed { get; set; }

    public void Load(int Id) {
        var dbContext = AppVariables.getDbContext();

        var invoices =
            from invoice in dbContext.INVOICES
            where invoice.INVOICE_ID == Id
            select new InvoiceView
            {
                Id = invoice.INVOICE_ID,
                Cusomer_Id = invoice.CUSTOMER_ID,
                Customer = invoice.CUSTOMER.NAME,
                Date = invoice.INVOICE_DATE,
                Amount = invoice.TOTAL_SALE,
                Payed = (invoice.PAYED == 1) ? "Yes" : "No"
            };

        InvoiceView invoiceView = invoices.ToList().First();
        this.Id = invoiceView.Id;
        this.Cusomer_Id = invoiceView.Cusomer_Id;
        this.Customer = invoiceView.Customer;
        this.Date = invoiceView.Date;
        this.Amount = invoiceView.Amount;
        this.Payed = invoiceView.Payed;
    }
}         
]]>
                </programlisting> Метод Load позволяет нам быстро обновить 1 добавленную или
                    обновлённую запись в гриде, вместо того чтобы полностью перезагружать все
                    записи. </para>

                <para>Код обработчика события на нажатие кнопки добавления выглядит следующим
                    образом. <programlisting language="csharp">
<![CDATA[                        
private void btnAddInvoice_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    var invoice = dbContext.INVOICES.Create();

    using (InvoiceEditorForm editor = new InvoiceEditorForm()) {
        editor.Text = "Добавление счёт фактуры";
        editor.Invoice = invoice;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
            if (editor.DialogResult == DialogResult.OK) {
                try {
                    // получаем значение генератора
                    invoice.INVOICE_ID = dbContext.NextValueFor("GEN_INVOICE_ID");
                    // добавляем запись
                    dbContext.INVOICES.Add(invoice);
                    // пытаемся сохранить изменения
                    dbContext.SaveChanges();
                    // добавляем проекцию в список для грида
                    ((InvoiceView)masterBinding.AddNew()).Load(invoice.INVOICE_ID);
                }
                catch (Exception ex) {
                    // отображаем ошибку
                    MessageBox.Show(ex.Message, "Error");
                    // не закрываем форму для возможности исправления ошибки
                    fe.Cancel = true;
                }
            }
        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}      
]]>
                </programlisting>
                </para>
                <para>В отличие от аналогичного метода справочника здесь обновление записи
                    происходит не с помощью вызова <function>dbContext.Refresh</function>, а с
                    помощью метода <function>Load</function> проекции
                        <function>InvoiceView</function>. Дело в том, что
                        <function>dbContext.Refresh</function> предназначен для обновления объектов
                    сущностей, а не произвольных проекций, которые могут получаться сложными LINQ
                    запросами.</para>

                <para>Код обработчика события на нажатие кнопки редактирования выглядит следующим
                    образом. <programlisting language="csharp">
<![CDATA[                        
private void btnEditInvoice_Click(object sender, EventArgs e) {
    // получение контекста
    var dbContext = AppVariables.getDbContext();
    // поиск сущности по идентификатору
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);

    if (invoice.PAYED == 1) {
        MessageBox.Show("Изменение не возможно, счёт фактура уже оплачена.", "Ошибка");
        return;
    }

    using (InvoiceEditorForm editor = new InvoiceEditorForm()) {
        editor.Text = "Edit invoice";
        editor.Invoice = invoice;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
            if (editor.DialogResult == DialogResult.OK) {
                try {
                    // пытаемся сохранить изменения
                    dbContext.SaveChanges();
                    // перезагружаем проекцию
                    CurrentInvoice.Load(invoice.INVOICE_ID);
                    masterBinding.ResetCurrentItem();
                }
                catch (Exception ex) {
                    // отображаем ошибку
                    MessageBox.Show(ex.Message, "Error");
                    // не закрываем форму для возможности исправления ошибки
                    fe.Cancel = true;
                }
            }
        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}    
]]>
                </programlisting>
                </para>
                <para>Здесь нам потребовалось найти сущность по её идентификатору доступному в
                    текущей записи. Свойство CurrentInvoice предназначено для получения выделенной в
                    гриде счёт-фактуры. Оно реализовано так: <programlisting language="csharp">
<![CDATA[                        
public InvoiceView CurrentInvoice {
    get {
        return (InvoiceView)masterBinding.Current;
    }
}  
]]>
                </programlisting>
                </para>
                <para>Удаление шапки счёт фактуры вы можете сделать самостоятельно.</para>

                <para>Помимо добавления, редактирования и удаления для счёт-фактур мы ввели ещё одну
                    операцию оплаты, код метода реализующего эту операцию выглядит следующим
                    образом: <programlisting language="csharp">
<![CDATA[                        
private void btnInvoicePay_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
    try {
        if (invoice.PAYED == 1)
           throw new Exception("Изменение не возможно, счёт фактура уже оплачена.");

        invoice.PAYED = 1;
        // сохраняем изменения
        dbContext.SaveChanges();
        // перезагружаем изменённую запись
        CurrentInvoice.Load(invoice.INVOICE_ID);
        masterBinding.ResetCurrentItem();
    }
    catch (Exception ex) {
        // отображаем ошибку
        MessageBox.Show(ex.Message, "Ошибка");
    }
} 
]]>
                </programlisting>
                </para>
                <para>Для отображения позиций счёт-фактуры существует два метода:<orderedlist>
                        <listitem>
                            <para>Получать данные по каждой счёт-фактуре из навигационного свойства
                                INVOICE _ LINE и отображать содержимое этого сложного свойства
                                (возможно с преобразованиями LINQ ) в детейл гриде.</para>
                        </listitem>
                        <listitem>
                            <para>Получать данные по каждой счёт-фактуре отдельным LINQ запросом,
                                который будет перевыполняться при перемещении в указателя в мастер
                                гриде.</para>
                        </listitem>
                    </orderedlist> Каждый из методов имеет свои преимущества и недостатки. </para>

                <para>Первый метод предполагает, что при открытии формы счёт-фактуры мы должны сразу
                    извлечь все счёт-фактуры за указанный период и связанные данные по их позициям.
                    Это хоть и выполняется одним SQL запросом, но может занять довольно много
                    времени, и требует значительного объёма оперативной памяти. Этот метод лучше
                    подходит для WEB приложений где вывод записей обычно происходит
                    постранично.</para>

                <para>Второй метод несколько более сложен в реализации, но позволяет быстро
                    открывать форму счёт-фактуры и менее требователен к ресурсам, однако при каждом
                    перемещении указателя в мастер гриде будет перевыполняться SQL запрос и
                    загружать сетевой трафик (хотя объём будет невелик).</para>

                <para>В нашем приложении я буду использовать второй подход. Для этого необходимо
                    написать обработчик события изменения текущей записи для компонента
                    BindingSource. <programlisting language="csharp">
<![CDATA[                        
private void masterBinding_CurrentChanged(object sender, EventArgs e) {
   LoadInvoiceLineData(this.CurrentInvoice.Id);
   detailGridView.DataSource = detailBinding;
} 
]]>
                </programlisting>
                </para>
                <para>Метод для загрузки данных о позициях счёт-фактуры выглядит следующим образом: <programlisting language="csharp">
<![CDATA[                        
private void LoadInvoiceLineData(int? id) {
    var dbContext = AppVariables.getDbContext();

    var lines =
        from line in dbContext.INVOICE_LINES
        where line.INVOICE_ID == id
        select new InvoiceLineView
        {
            Id = line.INVOICE_LINE_ID,
            Invoice_Id = line.INVOICE_ID,
            Product_Id = line.PRODUCT_ID,
            Product = line.PRODUCT.NAME,
            Quantity = line.QUANTITY,
            Price = line.SALE_PRICE,
            Total = Math.Round(line.QUANTITY * line.SALE_PRICE, 2)
        };

    detailBinding.DataSource = lines.ToBindingList();
}
]]>
                </programlisting>
                </para>
                <para>В качестве проекции мы использовали класс
                    <function>InvoiceLineView</function>. <programlisting language="csharp">
<![CDATA[                        
public class InvoiceLineView {
   public int Id { get; set; }
   public int Invoice_Id { get; set; }
   public int Product_Id { get; set; }
   public string Product { get; set; }
   public decimal Quantity { get; set; }
   public decimal Price { get; set; }
   public decimal Total { get; set; }
}
]]>
                </programlisting>
                </para>
                <para>Замечу, что в отличие от класса <function>InvoiceView</function> здесь
                    отсутствует метод для загрузки одной текущей записи. Здесь скорость перезагрузки
                    детейл грида не настолько критична, поскольку один документ не содержит тысячи
                    позиций, однако при желании вы можете реализовать такой метод. </para>
                <para>Добавим специальное свойство для получения текущей строки документа выделенной
                    в детейл гриде. <programlisting language="csharp">
<![CDATA[                        
public InvoiceLineView CurrentInvoiceLine {
    get {
        return (InvoiceLineView)detailBinding.Current;
    }
}
]]>
                </programlisting>
                </para>
                <para>В методах для добавления, редактирования и удаления мы покажем, как работать с
                    хранимыми процедурами в Entity Framework. Например, метод для добавления новой
                    записи выглядит так: <programlisting language="csharp">
<![CDATA[                        
private void btnAddInvoiceLine_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    // получаем текущую счёт-фактуру
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
    // проверяем не оплачена ли счёт-фактура
    if (invoice.PAYED == 1) {
        MessageBox.Show("Невозможно изменение, счёт-фактура оплачена.", "Error");
        return;
    }
    // создаём позицию счёт-фактуры
    var invoiceLine = dbContext.INVOICE_LINES.Create();
    invoiceLine.INVOICE_ID = invoice.INVOICE_ID;
    // создаём редактор позиции счёт фактуры
    using (InvoiceLineEditorForm editor = new InvoiceLineEditorForm()) {
        editor.Text = "Add invoice line";
        editor.InvoiceLine = invoiceLine;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
            if (editor.DialogResult == DialogResult.OK) {
              try {
                 // создаём параметры ХП
                 var invoiceIdParam = new FbParameter("INVOICE_ID", FbDbType.Integer);
                 var productIdParam = new FbParameter("PRODUCT_ID", FbDbType.Integer);
                 var quantityParam = new FbParameter("QUANTITY", FbDbType.Integer);
                 // инициализируем параметры значениями
                 invoiceIdParam.Value = invoiceLine.INVOICE_ID;
                 productIdParam.Value = invoiceLine.PRODUCT_ID;
                 quantityParam.Value = invoiceLine.QUANTITY;
                 // выполняем хранимую процедуру
                 dbContext.Database.ExecuteSqlCommand(
                   "EXECUTE PROCEDURE SP_ADD_INVOICE_LINE("
                        + "@INVOICE_ID, @PRODUCT_ID, @QUANTITY)", 
                   invoiceIdParam, 
                   productIdParam, 
                   quantityParam);
                 // обновляем гриды
                 // перезагрузка текущей записи счёт-фактуры
                 CurrentInvoice.Load(invoice.INVOICE_ID);
                 // перезагрузка всех записей детейл грида
                 LoadInvoiceLineData(invoice.INVOICE_ID);
                 // обновляем связанные данные
                 masterBinding.ResetCurrentItem();
              }
              catch (Exception ex) {
                 // отображаем ошибку
                 MessageBox.Show(ex.Message, "Error");
                 // не закрываем форму для возможности исправления ошибки
                 fe.Cancel = true;
              }
            }
        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}
]]>
                </programlisting>
                </para>
                <para>Здесь обновление записи мастер грида требуется потому, что одно из его полей
                    (TotalSale) содержит агрегированную информацию по строкам документа.</para>
                <para>Метод для обновления записи реализован так. <programlisting language="csharp">
<![CDATA[                        
private void btnEditInvoiceLine_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    // получаем текущую счёт-фактуру
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
    // проверяем не оплачена ли счёт-фактура
    if (invoice.PAYED == 1) {
        MessageBox.Show("Изменение не возможно, счёт фактура оплачена.", "Error");
        return;
    }
    // получаем текущую позицию счёт-фактуры
    var invoiceLine = invoice.INVOICE_LINES
        .Where(p => p.INVOICE_LINE_ID == this.CurrentInvoiceLine.Id)
        .First();
    // создаём редактор позиции счёт фактуры
    using (InvoiceLineEditorForm editor = new InvoiceLineEditorForm()) {
        editor.Text = "Edit invoice line";
        editor.InvoiceLine = invoiceLine;

        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
           if (editor.DialogResult == DialogResult.OK) {
               try {
                   // создаём параметры ХП
                   var idParam = new FbParameter("INVOICE_LINE_ID", FbDbType.Integer);
                   var quantityParam = new FbParameter("QUANTITY", FbDbType.Integer);
                   // инициализируем параметры значениями
                   idParam.Value = invoiceLine.INVOICE_LINE_ID;
                   quantityParam.Value = invoiceLine.QUANTITY;
                   // выполняем хранимую процедуру
                   dbContext.Database.ExecuteSqlCommand(
                      "EXECUTE PROCEDURE SP_EDIT_INVOICE_LINE("
                         + "@INVOICE_LINE_ID, @QUANTITY)", 
                      idParam, 
                      quantityParam);
                   // обновляем гриды
                   // перезагрузка текущей записи счёт-фактуры
                   CurrentInvoice.Load(invoice.INVOICE_ID);
                   // перезагрузка всех записей детейл грида
                   LoadInvoiceLineData(invoice.INVOICE_ID);
                   // обновляем связанные контролы
                   masterBinding.ResetCurrentItem();
               }
               catch (Exception ex) {
                   // отображаем ошибку
                   MessageBox.Show(ex.Message, "Error");
                   // не закрываем форму для возможности исправления ошибки
                   fe.Cancel = true;
               }
           }
       };

       // показываем модальную форму
       editor.ShowDialog(this);
    }
}
]]>
                </programlisting>
                </para>
                <para>Метод для удаления записи реализован так. <programlisting language="csharp">
<![CDATA[                        
private void btnDeleteInvoiceLine_Click(object sender, EventArgs e) {
    var result = MessageBox.Show(
                "Вы действительно хотите удалить строку счёт-фактуры?",
                "Подтверждение",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);
    if (result == DialogResult.Yes) {
       var dbContext = AppVariables.getDbContext();
       // получаем текущую счёт-фактуру
       var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
       try {
           // проверяем не оплачена ли счёт-фактура
           if (invoice.PAYED == 1)
              throw new Exception("Не возможно удалить запись, счёт-фактура оплачена.");
           // создаём параметры ХП
           var idParam = new FbParameter("INVOICE_LINE_ID", FbDbType.Integer);
           // инициализируем параметры значениями
           idParam.Value = this.CurrentInvoiceLine.Id;
           // выполняем хранимую процедуру
           dbContext.Database.ExecuteSqlCommand(
              "EXECUTE PROCEDURE SP_DELETE_INVOICE_LINE(@INVOICE_LINE_ID)", 
              idParam);

           // обновляем гриды
           // перезагрузка текущей записи счёт-фактуры
           CurrentInvoice.Load(invoice.INVOICE_ID);
           // перезагрузка всех записей детейл грида
           LoadInvoiceLineData(invoice.INVOICE_ID);
           // обновляем связанные контролы
           masterBinding.ResetCurrentItem();
       }
       catch (Exception ex) {
           // отображаем ошибку
           MessageBox.Show(ex.Message, "Error");
       }
    }
}
]]>
                </programlisting>
                </para>
                <para>В методах для добавления и редактирования позиций счёт-фактуры мы использовали
                    форму для редактирования. <figure>
                        <title>Форма редактора позиций счёт-фактур</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/dotnet-invoiceline-editor-form.png"/>
                            </imageobject>
                            <textobject>
                                <phrase>Форма редактора позиций счёт-фактур.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>

                <para>Для отображения товара мы будем использовать TextBox. По нажатию кнопки,
                    расположенной рядом, будет вызываться модальная форма с гридом для выбора
                    товара. В качестве модальной окна для выбора продукта используем ту же форму,
                    что была создана для их отображения. Код обработчика нажатия кнопки и
                    инициализации формы будет выглядеть следующим образом: <programlisting language="csharp">
<![CDATA[                        
public partial class InvoiceLineEditorForm : Form {
    public InvoiceLineEditorForm() {
        InitializeComponent();
    }


    public INVOICE_LINE InvoiceLine { get; set; }

    private void InvoiceLineEditorForm_Load(object sender, EventArgs e) {
        if (this.InvoiceLine.PRODUCT != null) {
           edtProduct.Text = this.InvoiceLine.PRODUCT.NAME;
           edtPrice.Text = this.InvoiceLine.PRODUCT.PRICE.ToString("F2");
           btnChooseProduct.Click -= this.btnChooseProduct_Click;
        }
        if (this.InvoiceLine.QUANTITY == 0)
           this.InvoiceLine.QUANTITY = 1;
        edtQuantity.DataBindings.Add("Value", this.InvoiceLine, "QUANTITY");
    }

    private void btnChooseProduct_Click(object sender, EventArgs e) {
       GoodsForm goodsForm = new GoodsForm();
       if (goodsForm.ShowDialog() == DialogResult.OK) {
          InvoiceLine.PRODUCT_ID = goodsForm.CurrentProduct.Id;
          edtProduct.Text = goodsForm.CurrentProduct.Name;
          edtPrice.Text = goodsForm.CurrentProduct.Price.ToString("F2");
       }
   }
}
]]>
                </programlisting>
                </para>
            </section>

            <section>
                <title>Работа с транзакциями</title>

                <para>Когда мы вызываем при добавлении, обновлении, удалении метод
                        <function>SaveChanges()</function>, то фактически Entity Framework неявно
                    стартует и завершает транзакцию. Поскольку используется отсоединённая модель, то
                    все операции происходят в рамках одной транзакции. Кроме того EF автоматически
                    стартует и завершает транзакцию при каждом извлечении данных. Рассмотрим работу
                    автоматических транзакций на следующем примере. Допустим нам необходимо сделать
                    скидку на товары, выделенные в гриде. Код без явного использования транзакций
                    будет выглядеть следующим образом: <programlisting language="csharp">
<![CDATA[                        
var dbContext = AppVariables.getDbContext();
foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
    int id = (int)gridRows.Cells["Id"].Value;
    // здесь происходит неявный старт и завершение транзакции
    var product = dbContext.PRODUCTS.Find(id);
    // скидка 10%
    decimal discount = 10.0m;
    product.PRICE = product.PRICE * (100 - discount) /100;
}
// здесь происходит неявный старт и завершение транзакции
// все изменения происходят за одну транзакцию
dbContext.SaveChanges();
]]>
                </programlisting>
                </para>
                <para>Допустим, мы выбрали 10 товаров. В этом случае будет неявно использовано 10
                    транзакций для поиска товара по идентификатору и одиннадцатая для сохранения
                    изменений. В данном случае можно использовать всего одну транзакцию, если
                    использовать явное управление транзакциями. Например, вот так: <programlisting language="csharp">
<![CDATA[                        
var dbContext = AppVariables.getDbContext();
// явный старт транзакции по умолчанию
using (var dbTransaction = dbContext.Database.BeginTransaction()) {
    string sql =
         "UPDATE PRODUCT " +
         "SET PRICE =  PRICE * ROUND((100 - @DISCOUNT)/100, 2) " +
         "WHERE PRODUCT_ID = @PRODUCT_ID";
    try {
        // создаём параметры запроса
        var idParam = new FbParameter("PRODUCT_ID", FbDbType.Integer);
        var discountParam = new FbParameter("DISCOUNT", FbDbType.Decimal);
        // создаём SQL команду для обновления записей
        var sqlCommand = dbContext.Database.Connection.CreateCommand();
        sqlCommand.CommandText = sql;
        // указываем команде, какую транзакцию использовать
        sqlCommand.Transaction = dbTransaction.UnderlyingTransaction;
        sqlCommand.Parameters.Add(discountParam);
        sqlCommand.Parameters.Add(idParam);
        // подготавливаем команду
        sqlCommand.Prepare();
        // для всех выделенных записей в гриде
        foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
            int id = (int)gridRows.Cells["Id"].Value;
            // инициализируем параметры запроса
            idParam.Value = id;
            discountParam.Value = 10.0m; // скидка 10%
            // выполняем sql запрос
            sqlCommand.ExecuteNonQuery();
        }
        dbTransaction.Commit();
    }
    catch (Exception ex) {
        dbTransaction.Rollback();
        MessageBox.Show(ex.Message, "error");                 
    }
}
]]>
                </programlisting>
                </para>
                <para>В данном случае мы стартовали транзакцию с параметрами по умолчанию. Для того
                    чтобы задавать свои параметры транзакции необходимо использовать метод
                    UseTransaction. <programlisting language="csharp">
<![CDATA[                        
private void btnDiscount_Click(object sender, EventArgs e) {         
    DiscountEditorForm editor = new DiscountEditorForm();

    editor.Text = "Enter discount";
    if (editor.ShowDialog() != DialogResult.OK)
        return;


    bool needUpdate = false;

    var dbContext = AppVariables.getDbContext();
    var connection = dbContext.Database.Connection;
    // явный старт транзакции по умолчанию
    using (var dbTransaction = connection.BeginTransaction(IsolationLevel.Snapshot)) {
        dbContext.Database.UseTransaction(dbTransaction);
        string sql =
            "UPDATE PRODUCT " +
            "SET PRICE =  ROUND(PRICE * (100 - @DISCOUNT)/100, 2) " +
            "WHERE PRODUCT_ID = @PRODUCT_ID";
        try {
            // создаём параметры запроса
            var idParam = new FbParameter("PRODUCT_ID", FbDbType.Integer);
            var discountParam = new FbParameter("DISCOUNT", FbDbType.Decimal);
            // создаём SQL комманду для обновления записей
            var sqlCommand = connection.CreateCommand();
            sqlCommand.CommandText = sql;
            // указываем команде какую транзакцию использовать
            sqlCommand.Transaction = dbTransaction;
            sqlCommand.Parameters.Add(discountParam);
            sqlCommand.Parameters.Add(idParam);
            // подготавливаем команду
            sqlCommand.Prepare();
            // для всех выделенных записей в гриде
            foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
                int id = (int)gridRows.Cells["PRODUCT_ID"].Value;
                // инициализируем параметры запроса
                idParam.Value = id;
                discountParam.Value = editor.Discount;
                // выполняем sql запрос                            
                needUpdate = (sqlCommand.ExecuteNonQuery() > 0) || needUpdate;
            }
            dbTransaction.Commit();
        }
        catch (Exception ex) {
            dbTransaction.Rollback();
            MessageBox.Show(ex.Message, "error");
            needUpdate = false;
        }
    }
    // перезагружаем содержимое грида
    if (needUpdate) {
       // для всех выделенных записей в гриде
       foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
            var product = (PRODUCT)bindingSource.List[gridRows.Index];
            dbContext.Refresh(RefreshMode.StoreWins, product);
       }
       bindingSource.ResetBindings(false);
    }

}
]]>
                </programlisting>
                </para>
                <para>Ну вот. Теперь у нас для всего набора обновлений используется всего одна
                    транзакция, и нет лишних команд для поиска данных. Осталось только добавить
                    диалог для ввода значения скидки и обновление данных в гриде. Попробуйте сделать
                    это самостоятельно.</para>
                <para>В заключении приведём скриншот готового приложения. <figure>
                        <title>Скриншот готового приложения</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/dotnet-winform-app.png" width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Скриншот готового приложения</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
            </section>
            <section>
                <title>Заключение</title>

                <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_dot_NET_source.zip"
                        >Исходные коды примера приложения</link></para>
                <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_database.zip"
                        >Готовая БД 2.5 и 3.0</link></para>
                <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.ibase.ru">www.ibase.ru</link>, <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.ibsurgeon.com">www.ibsurgeon.com</link></para>
                <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="mailto:support@ibase.ru">support@ibase.ru</link>, <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="mailto:support@ib-aid.com">support@ib-aid.com</link></para>
            </section>
        </section>
    </section>
    <section>
        <title>Создание Web приложений с использованием Entity Framework</title>

        <para>В данной главе будет описан процесс создания web приложений для СУБД Firebird с
            использованием Entity Framework и среды Visual Studio 2015.</para>

        <para>В данной главе обсуждаются особенности создания именно Web приложений, базовые
            принципы работы с Entity Framework и Firebird описаны в предыдущей главе <link
                linkend="app-ef-winform">«Создание приложений с использованием Entity
                Framework»</link>.</para>
        <para>Платформа .NET предоставляет два основных фреймворка для создания web приложений:
            ASP.NET Web Forms и ASP.NET MVC. Я предпочитаю использовать паттерн MVC, поэтому в
            дальнейшем будет описываться именно эта технология.</para>
        <para>Платформа <emphasis role="bold">ASP.NET MVC</emphasis> представляет собой фреймворк
            для создания сайтов и веб-приложений с помощью реализации паттерна MVC.</para>
        <para>Концепция паттерна (шаблона) MVC (model - view - controller) предполагает разделение
            приложения на три компонента:<itemizedlist>
                <listitem>
                    <para><emphasis role="bold">Контроллер</emphasis> (controller). Контроллеры
                        осуществляют взаимодействие с пользователем, работу с моделью, а также выбор
                        представления, отображающего пользовательский интерфейс. В приложении MVC
                        представления только отображают данные, а контроллер обрабатывает вводимые
                        данные и отвечает на действия пользователя. Например, контроллер может
                        обрабатывать строковые значения запроса и передавать их в модель, которая
                        может использовать эти значения для отправки запроса в базу данных.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Представление</emphasis> (view) — это собственно
                        визуальная часть или пользовательский интерфейс приложения. Пользовательский
                        интерфейс обычно создаётся на основе данных модели.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Модель</emphasis> (model). Объекты моделей являются
                        частями приложения, реализующими логику для работы данными приложения.
                        Объекты моделей часто получают и сохраняют состояние модели в базе
                        данных.</para>
                </listitem>
            </itemizedlist></para>

        <para>Общую схему взаимодействия этих компонентов можно представить следующим образом: <figure>
                <title>Структура MVC паттерна</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/mvc.png"/>
                    </imageobject>
                    <textobject>
                        <phrase>Структура MVC паттерна</phrase>
                    </textobject>
                </mediaobject>
            </figure>
        </para>

        <para>Шаблон MVC позволяет создавать приложения, различные аспекты которых (логика ввода,
            бизнес-логика и логика интерфейса) разделены, но достаточно тесно взаимодействуют друг с
            другом. Эта схема указывает расположение каждого вида логики в приложении.
            Пользовательский интерфейс располагается в представлении. Логика ввода располагается в
            контроллере. Бизнес-логика находится в модели. Это разделение позволяет работать со
            сложными структурами при создании приложения, так как обеспечивает одновременную
            реализацию только одного аспекта. Например, разработчик может сконцентрироваться на
            создании представления отдельно от бизнес-логики.</para>
        <para>Более полную информацию о технологии ASP.NET MVC вы можете найти на сайте <link
                xmlns:xlink="http://www.w3.org/1999/xlink"
                xlink:href="http://www.asp.net/mvc/overview">сообщества ASP.NET</link> .</para>
        <para>Помимо библиотек для работы с Firebird, Entity Framework и MVC.NET нам потребуется
            множество JavaScript библиотек для поддержки отзывчивого интерфейса, таких как jquery,
            jquery-ui, Bootstrap, jqGrid. В этом примере мы постарались приблизить интерфейс
            веб-приложения к настольным приложениям, активно применяя грибы для отображения и
            модальные окна для ввода данных.</para>
        <section>
            <title>Подготовка Visual Studio 2015 для работы с Firebird</title>

            <para>Для работы Visual Studio с СУБД Firebird вам придётся проделать несколько
                дополнительных шагов, которые подробно были описаны в предыдущей главе "Создание
                приложений с использованием Entity Framework" в разделе <link
                    linkend="app-dotnet-vsprepare">Подготовка Visual Studio 2015 для работы с
                    Firebird</link>. </para>
        </section>

        <section>
            <title>Создание проекта</title>

            <para>Посмотрим как создаётся каркас MVC.NET приложения с помощью мастеров Visual
                Studio.</para>

            <para>Итак, откроем Visual Studio 2015 <guimenu>Файл -> Создать -> Проект</guimenu> и
                создадим новый проект. Назовём новый проект FBMVCExample.</para>

            <figure>
                <title>Создание проекта</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/mvcnet-createproject.png" width="680"/>
                    </imageobject>
                    <textobject>
                        <phrase>Создание проекта</phrase>
                    </textobject>
                </mediaobject>
            </figure>

            <figure>
                <title>Создание MVC.NET проекта</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/mvcnet-createaspnet.png" width="680"/>
                    </imageobject>
                    <textobject>
                        <phrase>Создание MVC.NET проекта</phrase>
                    </textobject>
                </mediaobject>
            </figure>

            <para>Изменим способ проверки подлинности. В данный момент создадим веб приложение без
                проверки подлинности. К этому вопросу мы вернёмся чуть позже. <figure>
                    <title>Выбор способа проверки подлинности</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/mvcnet-auth.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Выбор способа проверки подлинности</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>После этого будет создан проект, который практически не обладает никакой
                функциональностью, хотя уже имеет базовую структуру. <table>
                    <?dbfo keep-together='auto'?>
                    <title>Структура папок MVC.NET проекта</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Папка или файл</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>/App_Data</entry>
                                <entry><para>В эту папку помещаются закрытые данные веб приложения,
                                        такие как XML-файлы или файлы базы данных.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/App_Start</entry>
                                <entry><para>Эта папка содержит ряд основных настроек конфигурации
                                        для проекта, в том числе определение маршрутов и
                                        фильтров.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Content</entry>
                                <entry><para>Сюда помещается статическое содержимое, такое как
                                        CSS-файлы и изображения. Это является необязательным
                                        соглашением. Вы можете хранить файлы стилей в любом
                                        подходящем месте.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Controllers</entry>
                                <entry><para>Сюда помещаются классы контроллеров. Это необязательное
                                        соглашение. Вы можете классы контроллеров где
                                    угодно.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Models</entry>
                                <entry><para>Сюда помещаются классы моделей представлений и моделей
                                        предметной области, хотя все кроме простейших приложений
                                        выигрывают от определения модели предметной области в
                                        отдельном проекте. Это необязательное соглашение. Вы можете
                                        размещать классы моделей в любом удобном
                                    месте.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Scripts</entry>
                                <entry><para>Эта папка предназначена для хранения библиотек
                                        JavaScript, используемых в приложении. По умолчанию Visual
                                        Studio добавляет библиотеки jQuery и несколько других
                                        популярных JavaScript-библиотек. Это необязательное
                                        соглашение.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Views</entry>
                                <entry><para>В этой папке хранятся представления и частичные
                                        представления, обычно сгруппированные вместе в папках с
                                        именами контроллеров, с которыми они связаны.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Views/Shared</entry>
                                <entry><para>В этой папке хранятся компоновки и представления, не
                                        являющиеся специфичными для какого-либо
                                    контроллера.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Views/Web.config</entry>
                                <entry><para>Это конфигурационный файл. В нем содержится
                                        конфигурационная информация, которая обеспечивает обработку
                                        представлений с помощью ASP.NET и предотвращает их
                                        обслуживание веб-сервером IIS, а также пространства имён, по
                                        умолчанию импортируемые в представления.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Global.asax</entry>
                                <entry><para>Это глобальный класс приложения ASP.NET. В файле его
                                        кода (Global.asax.cs) регистрируется конфигурация маршрутов,
                                        а также предоставляется любой код, который должен
                                        выполняться при запуске или завершении приложения либо в
                                        случае возникновения необработанного
                                    исключения.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Web.config</entry>
                                <entry><para>Конфигурационный файл для приложения.</para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>Теперь добавим необходимые пакеты с помощью менеджера пакетов NuGet. Нам
                потребуются установить недостающие пакеты:<itemizedlist spacing="compact">
                    <listitem>
                        <para>FirebirdSql.Data.FirebirdClient</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework.Firebird</para>
                    </listitem>
                    <listitem>
                        <para>Bootstrap (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>jQuery (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>jQuery.UI.Combined</para>
                    </listitem>
                    <listitem>
                        <para>Respond (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>Newtonsoft.Json</para>
                    </listitem>
                    <listitem>
                        <para>Moderninzr (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>Trirand.jqGrid</para>
                    </listitem>
                </itemizedlist></para>
            <note>
                <para>Не все пакеты, предоставляемые NuGet, являются библиотеками последних версий.
                    Особенно это касается JavaScript библиотек. Вы можете подключать последние
                    версии JavaScript библиотек, используя CDN или просто скачать их, заменив
                    библиотеки, предоставленные NuGet.</para>
            </note>
            <para>Для этого необходимо щёлкнуть правой клавишей мыши по имени проекта в обозревателе
                решений и в выпадающем меню выбрать пункт «Управление пакетами NuGet». <figure>
                    <title>Контекстное меню обозревателя решений</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/mvcnet-nugetmenu.png"/>
                        </imageobject>
                        <textobject>
                            <phrase>Контекстное меню обозревателя решений</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>В появившемся менеджере пакетов произвести поиск и установку необходимых пакетов. <figure>
                    <title>Менеджер пакетов NuGet</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/mvcnet-nuget.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Менеджер пакетов NuGet</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
        </section>

        <section>
            <title>Создание EDM модели</title>

            <para>Если у вас уже есть Windows Forms приложение, которое использует Entity Framework,
                то вы просто можете перенести кассы моделей в папку <filename>Models</filename>. В
                противном случае вам необходимо будет создать их с нуля. Подробно процесс создания
                EDM модели описан в предыдущей главе «Создание приложений с использованием Entity
                Framework» (см. раздел <link linkend="app-dotnet-createedm">«Создание EDM
                    модели»</link>).</para>

            <para>Существует одно небольшое отличие. В процессе работы мастера создания модели у вас
                спросят, как хранить строку подключения. <figure>
                    <title>Сохранение строки подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-save-connectionstring.png" width="680"
                            />
                        </imageobject>
                        <textobject>
                            <phrase>Сохранение строки подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>Поскольку мы создаём веб приложение, где все пользователи будут работать с базой
                данных под одной и той же учётной записью, то смело выбираем «Да». В качестве имени
                пользователя может быть указан любой пользователь с достаточными привилегиями.
                Желательно не использовать пользователя SYSDBA, поскольку он обладает повышенными
                привилегиями, которые не требуются для функционирования веб приложения. Вы всегда
                можете это изменить в готовом приложении, просто отредактировав строку подключения в
                файле конфигурации приложения
                    <filename><replaceable>AppName</replaceable>.exe.conf</filename>. Строка
                подключения будет сохранена в секции connectionStrings примерно в таком виде <programlisting language="xml">
<![CDATA[
<add name="DbModel" 
     connectionString="character set=UTF8; data source=localhost; 
                       initial catalog=examples; port number=3050; 
                       user id=sysdba; dialect=3; isolationlevel=Snapshot; 
                       pooling=True; password=masterkey;" 
     providerName="FirebirdSql.Data.FirebirdClient" />
]]>                
            </programlisting>
            </para>
        </section>
        <section>
            <title>Создание пользовательского интерфейса справочников</title>

            <section>
                <title>Контроллеры</title>

                <para>Итак, создадим наш первый контроллер. Он будет служить для отображения и ввода
                    данных о поставщиках. <figure>
                        <title>Меню добавления контроллера</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-menu-addcontroller.png"
                                    width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Меню добавления контроллера.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                    <figure>
                        <title>Добавление контроллера</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-addcontroller-wizard1.png"
                                    width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Добавление контроллера.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                    <figure>
                        <title>Мастер создания контроллера</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-addcontroller-wizard2.png"
                                    width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Мастер создания контроллера.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>После этих действий будет создан контроллер
                        <classname>CustomerController</classname> и 5 представлений: для отображения
                    списка поставщиков, детализации поставщика, формы для создания, редактирования и
                    удаления поставщика. Поскольку мы будем активно применять технологию Ajax и
                    библиотеку jqGrid, то нам будет достаточно всего одного представления для
                    отображения списка поставщиков в виде таблицы, остальные действия будут
                    выполняться с помощью jqGrid.</para>
                <para>Список поставщиков может оказаться довольно большим. В отличие от настольных
                    приложений в Web приложениях обычно не принято возвращать весь большой список,
                    потому что это может сильно замедлить загрузку страницы. Вместо этого обычно
                    используют постраничное разбиение данных, или динамическую дозагрузку данных,
                    когда при прокрутке пользователь достигает конца страницы (или грида). В нашем
                    примере мы воспользуемся первым вариантом.</para>
                <para>Ещё одной особенностью при создании веб приложений является то, что в них
                    отсутствует постоянное соединение с базой данных. Это обусловлено тем, что сам
                    скрипт формирования страницы «живёт» не дольше чем время для формирования ответа
                    на запрос пользователя. Само по себе соединение с базой данных – это довольно
                    дорогой ресурс, поэтому его надо экономить. Конечно, для уменьшения времени
                    установления соединения с базой данных придумали пул соединений, но всё равно
                    желательно, чтобы соединение с базой данных происходило только тогда когда это
                    действительно необходимо. Одним из способов снижения количества взаимодействий с
                    базой данных является перенос проверки правильности введённых данных на сторону
                    браузера. К счастью современные HTML5 и JavaScript библиотеки могут это делать.
                    Например, вы можете проверять обязательность поля на форме ввода, или
                    максимальную длину строковых полей.</para>
                <para>Итак давайте изменим контроллер <classname>CustomerController</classname> для
                    того чтобы он работал с jqGrid. В тексте контроллера сделаны поясняющие
                    комментарии. <programlisting language="csharp">
<![CDATA[
public class CustomerController : Controller
{
    private DbModel db = new DbModel();

    // Отображение представления
    public ActionResult Index()
    {
        return View();
    }

    // Получение данных в виде JSON для грида
    public ActionResult GetData(int? rows, int? page, string sidx, string sord, 
        string searchField, string searchString, string searchOper)
    {
        // получаем номер страницы, количество отображаемых данных
        int pageNo = page ?? 1;
        int limit = rows ?? 20;
        // вычисляем смещение
        int offset = (pageNo - 1) * limit;

        // строим запрос для получения поставщиков
        var customersQuery =
            from customer in db.CUSTOMERS             
            select new
            {
                CUSTOMER_ID = customer.CUSTOMER_ID,
                NAME = customer.NAME,
                ADDRESS = customer.ADDRESS,
                ZIPCODE = customer.ZIPCODE,
                PHONE = customer.PHONE
            };
        // добавлением в запрос условия поиска, если он производится
        if (searchField != null)
        {
            switch (searchOper)
            {
                case "eq":
                    customersQuery = customersQuery.Where(
                        c => c.NAME == searchString);
                    break;
                case "bw":
                    customersQuery = customersQuery.Where(
                        c => c.NAME.StartsWith(searchString));
                    break;
                case "cn":
                    customersQuery = customersQuery.Where(
                        c => c.NAME.Contains(searchString));
                    break;
            }
        }
        // получаем общее количество поставщиков
        int totalRows = customersQuery.Count();
        // добавляем сортировку
        switch (sord) {
            case "asc":
                customersQuery = customersQuery.OrderBy(
                    customer => customer.NAME);
                break;
            case "desc":
                customersQuery = customersQuery.OrderByDescending(
                    customer => customer.NAME);
                break;
        }

        // получаем список поставщиков
        var customers = customersQuery
             .Skip(offset)
             .Take(limit)
             .ToList();

        // вычисляем общее количество страниц
        int totalPages = totalRows / limit + 1;

        // создаём результат для jqGrid
        var result = new
        {
            page = pageNo,
            total = totalPages,
            records = totalRows,
            rows = customers
        };
        // преобразуем результат в JSON
        return Json(result, JsonRequestBehavior.AllowGet);
    }

    // Добавление нового поставщика
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Create(
      [Bind(Include = "NAME,ADDRESS,ZIPCODE,PHONE")] CUSTOMER customer)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            // получаем новый идентификатор с помощью генератора
            customer.CUSTOMER_ID = db.NextValueFor("GEN_CUSTOMER_ID");
            // добавляем модель в список
            db.CUSTOMERS.Add(customer);
            // сохраняем модель
            db.SaveChanges();
            // возвращаем успех в формате JSON
            return Json(true);
        }
        else {
            // соединяем ошибки модели в одну строку
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }

    // Редактирование поставщика
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Edit(
      [Bind(Include = "CUSTOMER_ID,NAME,ADDRESS,ZIPCODE,PHONE")] CUSTOMER customer)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            // помечаем модель как изменённую
            db.Entry(customer).State = EntityState.Modified;
            // сохраняем модель
            db.SaveChanges();
            // возвращаем успех в формате JSON
            return Json(true);
         }
         else {
            // соединяем ошибки модели в одну строку
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
         }
    }

    // Удаление поставщика
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Delete(int id)
    {
        // ищем поставщика по идентификатору
        CUSTOMER customer = db.CUSTOMERS.Find(id);
        // удаляем поставщика
        db.CUSTOMERS.Remove(customer);
        // сохраняем модель
        db.SaveChanges();
        // возвращаем успех в формате JSON
        return Json(true);
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            db.Dispose();
        }
        base.Dispose(disposing);
    }
}
]]>                    
                </programlisting>
                </para>

                <para>Метод <function>Index</function> служит для отображения представления
                    Views/Cusomter/Index.cshtml. Само представление будет представлено чуть позже. В
                    общем, это представление представляет собой шаблон html страницы с разметкой и
                    JavaScript для инициализации jqGrid. Сами данные будут получены в асинхронном
                    режиме в формате JSON с помощью технологии Ajax. В зависимости от выбранной
                    сортировки, номера страницы и параметров поиска формируется HTTP запрос, который
                    будет обработан действием <function>GetData</function>. Параметры http запроса
                    отображаются на входные аргументы метода <function>GetData</function>. В
                    соответствии с этими параметры мы формируем LINQ запрос, и отправляем полученный
                    результат в формате JSON.</para>

                <note>
                    <para>Для разбора параметров запроса формируемого jqGrid и упрощения построения
                        модели существуют различные библиотеки. Мы не использовали их в наших
                        примерах, и поэтому код может быть несколько громоздким. Однако вы всегда
                        можете улучшить его.</para>
                </note>

                <para>Метод <function>Create</function> предназначен для добавления новой записи о
                    поставщике. Параметры HTTP запроса с типом POST (у метода указан атрибут
                    [HttpPost]) будут отображены на модель <classname>Cusotmer</classname>. Обратите
                    внимание на строку
                    <programlisting language="csharp">
[Bind(Include = "NAME,ADDRESS,ZIPCODE,PHONE")] CUSTOMER customer                
                </programlisting>
                    Здесь Bind указывает, какие параметры HTTP запроса отображать на свойства
                    модели. </para>
                <para>Обратите внимание на атрибут <emphasis role="bold"
                        >ValidateAntiforgeryToken</emphasis>, он предназначен для противодействия
                    подделке межсайтовых запросов, производя верификацию токенов при обращении к
                    методу действия. Наличие этого атрибута требует чтобы в HTTP запросе
                    присутствовал дополнительный параметр
                        <property>__RequestVerificationToken</property>. Этот параметр автоматически
                    добавляется в каждую форму в которой указан хелпер
                        <function>@Html.AntiForgeryToken()</function>. Однако библиотека jqGrid
                    использует динамически формируемые Ajax запросы, а не заранее созданные веб
                    формы. Давайте исправим это. Для этого изменим обобщённое представлении
                        <filename>Views/Shared/_Layout.cshtml</filename> следующим образом <programlisting language="javascript">
<![CDATA[
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewBag.Title – приложение ASP.NET</title>
    @Styles.Render("~/Content/css")
    @Scripts.Render("~/bundles/modernizr")
    @Scripts.Render("~/bundles/jquery")
    @Scripts.Render("~/bundles/jquery-ui")

    <link href="~/Content/jquery.jqGrid/ui.jqgrid.css" 
          rel="stylesheet" type="text/css" />
    <link href="~/Content/jquery.jqGrid/ui.jqgrid-bootstrap.css" 
          rel="stylesheet" type="text/css" />
    <link href="~/Content/jquery.jqGrid/ui.jqgrid-bootstrap-ui.css" 
          rel="stylesheet" type="text/css" />

    <script src="~/Scripts/jquery.jqGrid.min.js" type="text/javascript"></script>
    <script src="~/Scripts/i18n/grid.locale-ru.js" type="text/javascript"></script>
</head>
<body>
    @Html.AntiForgeryToken()
    <script>
      // получение AntiForgery токена
      function GetAntiForgeryToken() {
        var tokenField = 
          $("input[type='hidden'][name$='RequestVerificationToken']");
        if (tokenField.length == 0) {
            return null;
        } else {
            return {
                name: tokenField[0].name,
                value: tokenField[0].value
            };
        }
      }

      // добавляем префильтр на все ajax запросы
      // он будет добавлять к любому POST ajax запросу
      // AntiForgery токен
      $.ajaxPrefilter(
          function (options, localOptions, jqXHR) {
              if (options.type !== "GET") {
                  var token = GetAntiForgeryToken();
                  if (token !== null) {
                      if (options.data.indexOf("X-Requested-With") === -1) {
                          options.data = "X-Requested-With=XMLHttpRequest" 
                              + ((options.data === "") ? "" : "&" + options.data);
                      }
                      options.data = options.data + "&" + token.name + '=' 
                                   + token.value;
                  }
              }
          }
      );
      // инициализируем общие свойства модуля jqGrid
      $.jgrid.defaults.width = 780;
      $.jgrid.defaults.responsive = true;
      $.jgrid.defaults.styleUI = 'Bootstrap';
    </script>
    <!-- Навигационное меню -->
    <div class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" 
                        data-target=".navbar-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="navbar-collapse collapse">
                <ul class="nav navbar-nav">                    
                    <li>@Html.ActionLink("Поставщики", "Index", "Customer")</li>
                    <li>@Html.ActionLink("Товары", "Index", "Product")</li>
                    <li>@Html.ActionLink("Накладные", "Index", "Invoice")</li>                                       
                </ul>
            </div>
        </div>
    </div>
    <div class="container body-content">
        @RenderBody()
        <hr />
        <footer>
            <p>&copy; @DateTime.Now.Year – приложение ASP.NET</p>
        </footer>
    </div>
    
    @Scripts.Render("~/bundles/bootstrap")
    @RenderSection("scripts", required: false)
</body>
</html>
]]>                    
                </programlisting>
                </para>
            </section>

            <section>
                <title>Бандлы</title>

                <para>Бандлы предназначены для упрощения подключения JavaScript скриптов и файлов
                    стилей. С помощью хелпера Styles.Render подключаются бандлы стилей, а с помощью
                    хелпера Scripts.Render — бандлы скриптов.</para>

                <para>Регистрация бандлов осуществляется в файле
                        <filename>BundleConfig.cs</filename>, который находится в папке
                        <filename>App_Start</filename>:
                    <programlisting language="csharp">
public static void RegisterBundles(BundleCollection bundles)
{
    bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
                        "~/Scripts/jquery-{version}.js"));

    bundles.Add(new ScriptBundle("~/bundles/jqueryval").Include(
                        "~/Scripts/jquery.validate*"));

    bundles.Add(new ScriptBundle("~/bundles/jquery-ui").Include(
                        "~/Scripts/jquery-ui-{version}.js"));

    bundles.Add(new ScriptBundle("~/bundles/modernizr").Include(
                        "~/Scripts/modernizr-*"));

    bundles.Add(new ScriptBundle("~/bundles/bootstrap").Include(
                      "~/Scripts/bootstrap.js",
                      "~/Scripts/respond.js"));

    bundles.Add(new StyleBundle("~/Content/css").Include(
                      "~/Content/jquery-ui.min.css",
                      "~/Content/themes/ui-darkness/jquery-ui.min.css",
                      "~/Content/themes/ui-darkness/theme.css",
                      "~/Content/bootstrap.min.css",                     
                      "~/Content/Site.css"
                ));
}                   
                </programlisting>
                </para>
                <para> Здесь метод RegisterBundles добавляет все создаваемые бандлы в коллекцию
                    bundles. Объявление бандла выглядит следующим образом:
                    <programlisting language="csharp">
new ScriptBundle("~/bundles/jquery").Include("~/Scripts/jquery-{version}.js")
                    </programlisting>
                </para>
                <para>В конструктор <function>ScriptBundle</function> передаётся виртуальный путь
                    бандла. А с помощью метода <function>Include</function> в данный бандл
                    включаются конкретные файлы скриптов.</para>
                <para>В выражении "~/Scripts/jquery-{version}.js" параметр {version} является
                    заменителем для любого символьного обозначения версии скрипта. Это очень удобно,
                    поскольку через некоторое время мы можем поменять версию библиотеки, но при этом
                    в коде нам ничего не придётся менять, так как система уже автоматически примет
                    новую версию.</para>
                <para>Выражение "~/Scripts/jquery.validate*" с помощью знака звёздочки заменяет
                    остальную часть строки. Например, это выражение подключит в бандл сразу два
                    файла: <filename>jquery.validate.js</filename> и
                        <filename>jquery.validate.unobtrusive.js</filename> (и их минимизированные
                    версии), так как их названия начинаются с jquery.validate*".</para>
                <para>То же самое касается и создания бандлов стилей, только в этом случае
                    используется класс <classname>StyleBundle</classname>.</para>
                <para>Во время отладки желательно иметь полные версии скриптов и стилей, а при
                    развёртывании приложения – минифицированные. Бандлы позволяют решить эту задачу.
                    Когда приложение находится в режиме отладки, то файле
                        <filename>web.config</filename> параметр &lt;compilation debug="true"&gt;.
                    При изменении этого параметра на значение <literal>false</literal> (режим
                    компиляции Release ) вместо полных версий JavaScript модулей и файлов CSS стилей
                    будут использоваться минифицированные.</para>
            </section>

            <section>
                <title>Представления</title>

                <para>Из всех автоматически созданных представлений для контроллера Customer нам
                    потребуется только один View/Customer/Index.cshtml, остальные можно удалить из
                    этой папки.</para>

                <para>
                    <programlisting language="javascript">
<![CDATA[
@{
    ViewBag.Title = "Index";
}

<h2>Customers</h2>

<table id="jqg"></table>
<div id="jqg-pager"></div>

<script type="text/javascript">
    $(document).ready(function () {

        var dbGrid = $("#jqg").jqGrid({
            url: '@Url.Action("GetData")', // url для получения данных
            datatype: "json", // формат получения данных 
            mtype: "GET",     // тип http запроса
            // описание модели
            colModel: [
                {
                    label: 'Id',          // подпись
                    name: 'CUSTOMER_ID',  // имя поля
                    key: true,            // признак ключевого поля
                    hidden: true          // скрыт 
                },
                {
                    label: 'Name',
                    name: 'NAME',
                    width: 250,           // ширина
                    sortable: true,       // разрешена сортировка
                    editable: true,       // разрешено редактирование
                    edittype: "text",     // тип поля в редакторе
                    search: true,         // разрешён поиск
                    searchoptions: {
                        sopt: ['eq', 'bw', 'cn'] // разрешённые операторы поиска
                    },
                    // размер и максимальная длина для поля ввода
                    editoptions: { size: 30, maxlength: 60 }, 
                    // говорит о том что поле обязательное
                    editrules: { required: true } 
                },
                {
                    label: 'Address',
                    name: 'ADDRESS',
                    width: 300,
                    sortable: false,    // запрещаем сортировку
                    editable: true,     // редактируемое
                    search: false,      // запрещаем поиск
                    edittype: "textarea",
                    editoptions: { maxlength: 250, cols: 30, rows: 4 }
                },
                {
                    label: 'Zip Code',
                    name: 'ZIPCODE',
                    width: 30,
                    sortable: false,
                    editable: true,
                    search: false,
                    edittype: "text",
                    editoptions: { size: 30, maxlength: 10 },
                },
                {
                    label: 'Phone',
                    name: 'PHONE',
                    width: 80,
                    sortable: false,
                    editable: true,
                    search: false,
                    edittype: "text",
                    editoptions: { size: 30, maxlength: 14 },
                }
            ],
            rowNum: 500, // число отображаемых строк
            loadonce: false, // загрузка только один раз
            sortname: 'NAME', // сортировка по умолчанию по столбцу NAME
            sortorder: "asc", // порядок сортировки
            width: window.innerWidth - 80, // ширина грида
            height: 500,      // высота грида
            viewrecords: true, // отображать количество записей
            caption: "Customers", // подпись к гриду
            pager: 'jqg-pager'  // элемент для отображения навигации
        });

        dbGrid.jqGrid('navGrid', '#jqg-pager', {
            search: true,  // поиск
            add: true,     // добавление
            edit: true,    // редактирование
            del: true,     // удаление
            view: true,    // просмотр записи
            refresh: true, // обновление
            // подписи кнопок
            searchtext: "Поиск",
            addtext: "Добавить",
            edittext: "Изменить",
            deltext: "Удалить",
            viewtext: "Смотреть",
            viewtitle: "Выбранная запись",
            refreshtext: "Обновить"
        },
        update("edit"), // обновление
        update("add"), // добавление    
        update("del") // удаление
        );

        // функция возвращающая настройки редактора
        function update(act) {
            return {
                closeAfterAdd: true, // закрыть после добавления
                closeAfterEdit: true, // закрыть после редактирования
                width: 400,           // ширина редактора
                reloadAfterSubmit: true, // обновление
                drag: true,              // перетаскиваемый
                // обработчик отправки формы редактирования/удаления/добавления
                onclickSubmit: function (params, postdata) {
                    // получаем идентификатор строки
                    var selectedRow = dbGrid.getGridParam("selrow");
                    // устанавливаем url в зависимости от операции
                    switch (act) {
                        case "add":
                            params.url = '@Url.Action("Create")';
                            break;

                        case "edit":
                            params.url = '@Url.Action("Edit")';
                            postdata.CUSTOMER_ID = selectedRow;
                            break;

                        case "del":
                            params.url = '@Url.Action("Delete")';
                            postdata.CUSTOMER_ID = selectedRow;
                            break;
                    }
                },
                // обработчик результатов обработки форм (операций)
                afterSubmit: function (response, postdata) {
                    var responseData = response.responseJSON;
                    // проверяем результат на наличие сообщений об ошибках
                    if (responseData.hasOwnProperty("error")) {
                        if (responseData.error.length) {
                            return [false, responseData.error];
                        }
                    }
                    else {
                        // обновление грида
                        $(this).jqGrid(
                            'setGridParam',
                            {
                                datatype: 'json'
                            }
                        ).trigger('reloadGrid');
                    }
                    return [true, "", 0];
                }
            };
        };

    });
</script>
]]>                        
                    </programlisting>
                </para>

                <para>Как видите всё представление состоит из заголовка, таблицы jqg и блока
                    jqg-pager для отображения панели навигации, остальное занимает скрипт по
                    инициализации грида, панели навигации и диалога редактирования. Для правильного
                    отображения грида, размещения элементов ввода в форме редактирования, настройки
                    валидации форм ввода, настройки возможностей сортировки и поиска важно правильно
                    настроить свойства модели. Эта настройка довольно нетривиальна и содержит
                    множество параметров. Я постарался описать используемые параметры в
                    комментариях. Полное описание параметров модели вы можете найти в документации
                    по библиотеки jqGrid в разделе <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.trirand.com/jqgridwiki/doku.php?id=wiki:colmodel_options"
                        >ColModel API</link>.</para>
                <para>Обратите внимание, что для параметров редактирования и удаления нам пришлось
                    добавить в параметры запроса идентификатор заказчика <programlisting language="javascript">
<![CDATA[
    case "edit":
        params.url = '@Url.Action("Edit")';
        postdata.CUSTOMER_ID = selectedRow;
        break;

    case "del":
        params.url = '@Url.Action("Delete")';
        postdata.CUSTOMER_ID = selectedRow;
        break;
]]>                        
                    </programlisting> Это сделано потому, что jqGrid
                    автоматически не добавляет в форму ввода скрытые колонки грида, хотя, на мой
                    взгляд, это было бы логично, хотя бы для ключевых полей. </para>
                <para>Работающая страница справочника поставщиков будет выглядеть следующим образом: <figure>
                        <title>Справочник заказчиков</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-customers-screen.png" width="680"
                                />
                            </imageobject>
                            <textobject>
                                <phrase>Справочник заказчиков.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                    <figure>
                        <title>Редактирование заказчика</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-customers-edit-screen.png"
                                    width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Редактирование заказчика.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>Контроллер и представление для справочника товаров делаются по аналогии. Здесь
                    мы не будем описывать их подробно, вы можете написать их самостоятельно или
                    найти в исходных кодах, которые прилагаются к данной статье.</para>
            </section>
        </section>
        <section>
            <title>Создание пользовательского интерфейса журналов</title>

            <para>В нашем приложении будет один журнал «Счёт-фактуры». В отличие от справочников
                журналы содержат довольно большое количество записей и являются часто
                пополняемыми.</para>
            <para>Счёт-фактура – состоит из заголовка, где описываются общие атрибуты (номер, дата,
                заказчик …), и строк счёт-фактуры со списком товаром, их количеством, стоимостью и
                т.д. Для экономии пространства страницы мы сделаем детализирующий грид скрытым. Он
                будет отображён лишь при клике по иконке со знаком «+», таким образом, у нас
                получается, что детализирующий грид вложен в главный. </para>

            <section>
                <title>Контроллеры</title>

                <para>Контроллер журнала счёт фактуры должен уметь отдавать данные как по шапкам
                    счёт-фактуры, так и по её позициям. То же самое касается методов для добавления,
                    редактирования и удаления. <programlisting language="csharp">
<![CDATA[
[Authorize(Roles = "manager")]
public class InvoiceController : Controller
{
    private DbModel db = new DbModel();

    // Отображение представления
    public ActionResult Index()
    {
        return View();
    }

    // Получение данных в виде JSON для главного грида
    public ActionResult GetData(int? rows, int? page, string sidx, string sord,
        string searchField, string searchString, string searchOper)
    {
        // получаем номер страницы, количество отображаемых данных
        int pageNo = page ?? 1;
        int limit = rows ?? 20;
        // вычисляем смещение
        int offset = (pageNo - 1) * limit;

        // строим запрос для получения счёт-фактур
        var invoicesQuery =
            from invoice in db.INVOICES
            where (invoice.INVOICE_DATE >= AppVariables.StartDate) &&
                  (invoice.INVOICE_DATE <= AppVariables.FinishDate)
            select new
            {
                INVOICE_ID = invoice.INVOICE_ID,
                CUSTOMER_ID = invoice.CUSTOMER_ID,
                CUSTOMER_NAME = invoice.CUSTOMER.NAME,
                INVOICE_DATE = invoice.INVOICE_DATE,
                TOTAL_SALE = invoice.TOTAL_SALE,
                PAID = invoice.PAID
            };

        // добавлением в запрос условия поиска, если он производится
        // для разных полей доступны разные операторы
        // сравнения при поиске
        if (searchField == "CUSTOMER_NAME")
        {
             switch (searchOper)
             {
                 case "eq": // equal
                     invoicesQuery = invoicesQuery.Where(
                        c => c.CUSTOMER_NAME == searchString);
                     break;
                 case "bw": // starting with
                     invoicesQuery = invoicesQuery.Where(
                        c => c.CUSTOMER_NAME.StartsWith(searchString));
                     break;
                 case "cn": // containing
                     invoicesQuery = invoicesQuery.Where(
                        c => c.CUSTOMER_NAME.Contains(searchString));
                     break;
             }
        }
        if (searchField == "INVOICE_DATE")
        {
            var dateValue = DateTime.Parse(searchString);
            switch (searchOper)
            {
                case "eq": // =
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE == dateValue);
                    break;
                case "lt": // <
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE < dateValue);
                    break;
                case "le": // <=
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE <= dateValue);
                    break;
                case "gt": // >
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE > dateValue);
                    break;
                case "ge": // >=
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE >= dateValue);
                    break;

            }
        }
        if (searchField == "PAID")
        {
            int iVal = (searchString == "on") ? 1 : 0;
            invoicesQuery = invoicesQuery.Where(c => c.PAID == iVal);
        }

        // получаем общее количество счёт-фактур
        int totalRows = invoicesQuery.Count();

        // добавляем сортировку
        switch (sord)
        {
            case "asc":
                invoicesQuery = invoicesQuery.OrderBy(
                    invoice => invoice.INVOICE_DATE);
                break;
            case "desc":
                invoicesQuery = invoicesQuery.OrderByDescending(
                    invoice => invoice.INVOICE_DATE);
                break;
        }

        // получаем список счёт-фактур
        var invoices = invoicesQuery
             .Skip(offset)
             .Take(limit)
             .ToList();

        // вычисляем общее количество страниц
        int totalPages = totalRows / limit + 1;

        // создаём результат для jqGrid
        var result = new
        {
            page = pageNo,
            total = totalPages,
            records = totalRows,
            rows = invoices
        };

        // преобразуем результат в JSON
        return Json(result, JsonRequestBehavior.AllowGet);
    }

    // Получение данных в виде JSON для детализирующего грида
    public ActionResult GetDetailData(int? invoice_id)
    {
        // строим запрос для получения позиций счёт-фактуры
        // отфильтрованный по коду счёт-фактуры
        var lines =
            from line in db.INVOICE_LINES
            where line.INVOICE_ID == invoice_id
            select new
            {
                INVOICE_LINE_ID = line.INVOICE_LINE_ID,
                INVOICE_ID = line.INVOICE_ID,
                PRODUCT_ID = line.PRODUCT_ID,
                Product = line.PRODUCT.NAME,
                Quantity = line.QUANTITY,
                Price = line.SALE_PRICE,
                Total = line.QUANTITY * line.SALE_PRICE
            };

        // получаем список позиций 
        var invoices = lines
             .ToList();

        // создаём результат для jqGrid
        var result = new
        {
            rows = invoices
        };

        // преобразуем результат в JSON
        return Json(result, JsonRequestBehavior.AllowGet);
    }


    // Добавление новой шапки счёт-фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Create(
       [Bind(Include = "CUSTOMER_ID,INVOICE_DATE")] INVOICE invoice)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            try
            {
                var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
                var CUSTOMER_ID = new FbParameter("CUSTOMER_ID", FbDbType.Integer);
                var INVOICE_DATE = new FbParameter("INVOICE_DATE", 
                                           FbDbType.TimeStamp);
                // инициализируем параметры значениями
                INVOICE_ID.Value = db.NextValueFor("GEN_INVOICE_ID");
                CUSTOMER_ID.Value = invoice.CUSTOMER_ID;
                INVOICE_DATE.Value = invoice.INVOICE_DATE;
                // выполняем ХП
                db.Database.ExecuteSqlCommand(
    "EXECUTE PROCEDURE SP_ADD_INVOICE(@INVOICE_ID, @CUSTOMER_ID, @INVOICE_DATE)",
                    INVOICE_ID,
                    CUSTOMER_ID,
                    INVOICE_DATE);
                    // возвращаем успех в формате JSON
                return Json(true);
            }
            catch (Exception ex)
            {
                // возвращаем ошибку в формате JSON
                return Json(new { error = ex.Message });
            }

        }
        else {
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }


    // Редактирование шапки счёт-фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Edit(
       [Bind(Include = "INVOICE_ID,CUSTOMER_ID,INVOICE_DATE")] INVOICE invoice)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            try
            {
                var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
                var CUSTOMER_ID = new FbParameter("CUSTOMER_ID", FbDbType.Integer);
                var INVOICE_DATE = new FbParameter("INVOICE_DATE", 
                                                   FbDbType.TimeStamp);
                // инициализируем параметры значениями
                INVOICE_ID.Value = invoice.INVOICE_ID;
                CUSTOMER_ID.Value = invoice.CUSTOMER_ID;
                INVOICE_DATE.Value = invoice.INVOICE_DATE;
                // выполняем ХП
                db.Database.ExecuteSqlCommand(
    "EXECUTE PROCEDURE SP_EDIT_INVOICE(@INVOICE_ID, @CUSTOMER_ID, @INVOICE_DATE)",
                    INVOICE_ID,
                    CUSTOMER_ID,
                    INVOICE_DATE);
                // возвращаем успех в формате JSON
                return Json(true);
            }
            catch (Exception ex)
            {
                // возвращаем ошибку в формате JSON
                return Json(new { error = ex.Message });
            }
        }
        else {
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }


    // Удаление шапки счёт-фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Delete(int id)
    {
        try
        {
            var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
            // инициализируем параметры значениями
            INVOICE_ID.Value = id;
            // выполняем ХП
            db.Database.ExecuteSqlCommand(
                "EXECUTE PROCEDURE SP_DELETE_INVOICE(@INVOICE_ID)",
                INVOICE_ID);
            // возвращаем успех в формате JSON
            return Json(true);
        }
        catch (Exception ex)
        {
            // возвращаем ошибку в формате JSON
            return Json(new { error = ex.Message });
        }
    }

    // Оплата счёт фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Pay(int id)
    {
        try
        {
            var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
            // инициализируем параметры значениями
            INVOICE_ID.Value = id;
            // выполняем ХП
            db.Database.ExecuteSqlCommand(
                "EXECUTE PROCEDURE SP_PAY_FOR_INOVICE(@INVOICE_ID)",
                INVOICE_ID);
            // возвращаем успех в формате JSON
            return Json(true);
        }
        catch (Exception ex)
        {
            // возвращаем ошибку в формате JSON
            return Json(new { error = ex.Message });
        }
    }

    // Добавление позиции счёт фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult CreateDetail(
       [Bind(Include = "INVOICE_ID,PRODUCT_ID,QUANTITY")] INVOICE_LINE invoiceLine)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            try
            {
                var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
                var PRODUCT_ID = new FbParameter("PRODUCT_ID", FbDbType.Integer);
                var QUANTITY = new FbParameter("QUANTITY", FbDbType.Integer);
                // инициализируем параметры значениями
                INVOICE_ID.Value = invoiceLine.INVOICE_ID;
                PRODUCT_ID.Value = invoiceLine.PRODUCT_ID;
                QUANTITY.Value = invoiceLine.QUANTITY;
                // выполняем ХП
                db.Database.ExecuteSqlCommand(
    "EXECUTE PROCEDURE SP_ADD_INVOICE_LINE(@INVOICE_ID, @PRODUCT_ID, @QUANTITY)",
                    INVOICE_ID,
                    PRODUCT_ID,
                    QUANTITY);
                // возвращаем успех в формате JSON
                return Json(true);
            }
            catch (Exception ex)
            {
                // возвращаем ошибку в формате JSON
                return Json(new { error = ex.Message });
            }
        }
        else {
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }

    // редактирование позиции счёт фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult EditDetail(
      [Bind(Include = "INVOICE_LINE_ID,INVOICE_ID,PRODUCT_ID,QUANTITY")] 
      INVOICE_LINE invoiceLine)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            try
            {
                // Создание параметров
                var INVOICE_LINE_ID = new FbParameter("INVOICE_LINE_ID", 
                                             FbDbType.Integer);
                var QUANTITY = new FbParameter("QUANTITY", FbDbType.Integer);
                // инициализируем параметры значениями
                INVOICE_LINE_ID.Value = invoiceLine.INVOICE_LINE_ID;
                QUANTITY.Value = invoiceLine.QUANTITY;
                // выполняем ХП
                db.Database.ExecuteSqlCommand(
    "EXECUTE PROCEDURE SP_EDIT_INVOICE_LINE(@INVOICE_LINE_ID, @QUANTITY)",
                    INVOICE_LINE_ID,
                    QUANTITY);
                // возвращаем успех в формате JSON
                return Json(true);
            }
            catch (Exception ex)
            {
                // возвращаем ошибку в формате JSON
                return Json(new { error = ex.Message });
            }
        }
        else {
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }

    // Удаление позиции счёт фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult DeleteDetail(int id)
    {
        try
        {
            // Создание параметров
            var INVOICE_LINE_ID = new FbParameter("INVOICE_LINE_ID", 
                                          FbDbType.Integer);
            // инициализируем параметры значениями
            INVOICE_LINE_ID.Value = id;
            // выполняем ХП
            db.Database.ExecuteSqlCommand(
                 "EXECUTE PROCEDURE SP_DELETE_INVOICE_LINE(@INVOICE_LINE_ID)",
                 INVOICE_LINE_ID);
            // возвращаем успех в формате JSON
            return Json(true);
        }
        catch (Exception ex)
        {
            // возвращаем ошибку в формате JSON
            return Json(new { error = ex.Message });
        }
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            db.Dispose();
        }
        base.Dispose(disposing);
    }
}
]]>                    
                </programlisting>
                </para>
                <para>В методе <function>GetDetailData</function> для получения списка позиций
                    счёт-фактуры нет кода для постраничной навигации. Дело в том, что у конкретной
                    счёт-фактуры не очень много позиций для того чтобы применять к ним постраничную
                    навигацию. Это упрощает код, и делает его быстрее.</para>
                <para>На этот раз все действия по модификации данных выполняются в хранимых
                    процедурах, однако вы можете выполнить те же действия с помощью Entity
                    Framework. Тексты хранимых процедур вы можете посмотреть в скрипте создания
                    БД.</para>
            </section>
            <section>
                <title>Представления</title>

                <para>Как и для контроллера Customer нам потребуется только одно представление
                        <filename>View/Invoice/Index.cshtml</filename>, остальные можно удалить из
                    этой папки. Сама разметка представления очень проста, а вот JavaScript кода
                    довольно много. Будем описывать js код по частям. <programlisting language="javascript">
<![CDATA[
@{
    ViewBag.Title = "Index";
}

<h2>Invoices</h2>

<table id="jqg"></table>
<div id="jpager"></div>

<script type="text/javascript">

    /**
     * Код для работы с jqGrid
     */
</script>
]]>                    
                </programlisting>
                </para>
                <para>Для начала рассмотрим код для работы с главным гридом. По сути, в нём
                    необходимо только прописать свойства модели (типы и размеры полей, параметры
                    поиска, сортировки, видимости и т.д.). <programlisting language="javascript">
<![CDATA[
// Грид с инвойсами
var dbGrid = $("#jqg").jqGrid({
    url: '@Url.Action("GetData")', // url для получения данных
    datatype: "json", // формат получения данных
    mtype: "GET",     // тип http запроса
    // описание модели
    colModel: [
        {
            label: 'Id',         // подпись
            name: 'INVOICE_ID',  // имя поля
            key: true,           // признак ключевого поля   
            hidden: true         // скрыт 
        },
        {
            label: 'CUSTOMER_ID', // подпись
            name: 'CUSTOMER_ID',  // имя поля
            hidden: true,         // скрыт 
            editrules: { edithidden: true, required: true }, // скрытое и требуемое
            editable: true,       // редактируемое
            edittype:'custom',    // собственный тип
            editoptions: {
                custom_element: function (value, options) {
                     // добавляем скрытый input
                     return $("<input>")
                             .attr('type', 'hidden')
                             .attr('rowid', options.rowId)
                             .addClass("FormElement")
                             .addClass("form-control")
                             .val(value)
                             .get(0);
                }
            }
        },
        {
            label: 'Date',
            name: 'INVOICE_DATE',
            width: 60,             // ширина
            sortable: true,        // позволять сортировку
            editable: true,        // редактируемое
            search: true,          // разрешён поиск
            edittype: "text",      // тип поля ввода
            align: "right",        // выравнено по правому краю
            formatter: 'date',     // отформатировано как дата
            sorttype: 'date',      // сортируем как дату
            formatoptions: {       // формат даты
                srcformat: 'd.m.Y H:i:s',
                newformat: 'd.m.Y H:i:s'
            },
            editoptions: {
                // иницивлизация элемента формы для редактирования
                dataInit: function (element) {
                    // создаём datepicker
                    $(element).datepicker({
                        id: 'invoiceDate_datePicker',
                        dateFormat: 'dd.mm.yy',
                        minDate: new Date(2000, 0, 1),
                        maxDate: new Date(2030, 0, 1)
                    });
                }
            },
            searchoptions: {
                // иницивлизация элемента формы для поиска
                dataInit: function (element) {
                    // создаём datepicker
                    $(element).datepicker({
                        id: 'invoiceDate_datePicker',
                        dateFormat: 'dd.mm.yy',
                        minDate: new Date(2000, 0, 1),
                        maxDate: new Date(2030, 0, 1)
                    });
                },
                searchoptions: { // типы поиска
                    sopt: ['eq', 'lt', 'le', 'gt', 'ge']
                },
            }
        },
        {
            label: 'Customer',
            name: 'CUSTOMER_NAME',
            width: 250,
            editable: true,
            edittype: "text",
            editoptions: {
                size: 50,
                maxlength: 60,
                readonly: true    // только чтение
            },
            editrules: { required: true },
            search: true,
            searchoptions: {
                        sopt: ['eq', 'bw', 'cn']
            },
        },
        {
            label: 'Amount',
            name: 'TOTAL_SALE',
            width: 60,
            sortable: false,
            editable: false,
            search: false,
            align: "right",
            formatter: 'currency', // форматировать как валюту
            sorttype: 'number',
            searchrules: {
                 "required": true,
                 "number": true,
                 "minValue": 0
            }
        },
        {
            label: 'Paid',
            name: 'PAID',
            width: 30,
            sortable: false,
            editable: true,
            search: true,
            searchoptions: {
                sopt: ['eq']
            },
            edittype: "checkbox", // галочка
            formatter: "checkbox",
            stype: "checkbox",
            align: "center",
            editoptions: {
                value: "1",
                offval: "0"
            }
        }
    ],
    rowNum: 500, // число отображаемых строк
    loadonce: false, // загрузка только один раз
    sortname: 'INVOICE_DATE', // сортировка по умолчанию по столбцу NAME
    sortorder: "desc", // порядок сортировки
    width: window.innerWidth - 80, // ширина грида
    height: 500, // высота грида
    viewrecords: true, // отображать количество записей
    caption: "Invoices", // подпись к гриду
    pager: '#jpager', // элемент для отображения постраничной навигации
    subGrid: true, // показывать вложенный грид
    // javascript функция для отображения родительского грида
    subGridRowExpanded: showChildGrid, 
    subGridOptions: { // опции вложенного грида
         // загружать данные только один раз
         reloadOnExpand: false,
         // загружать строки подгрида только при щелчке по иконке "+"
         selectOnExpand: true
    },
});

// отображение панели навигации
dbGrid.jqGrid('navGrid', '#jpager',
    {
         search: true,  // поиск
         add: true,     // добавление
         edit: true,    // редактирование
         del: true,     // удаление
         view: false,    // просмотр записи
         refresh: true, // обновление

         searchtext: "Поиск",
         addtext: "Добавить",
         edittext: "Изменить",
         deltext: "Удалить",
         viewtext: "Смотреть",
         viewtitle: "Выбранная запись",
         refreshtext: "Обновить"
    },
    update("edit"), // обновление
    update("add"), // добавление
    update("del") // удаление
);
]]>                    
                </programlisting>
                </para>
                <para>Добавим в главный грид ещё «пользовательскую» одну кнопку для оплаты
                    счёт-фактуры. <programlisting language="javascript">
<![CDATA[
// добавление кнопки для оплаты счёт фактуры
dbGrid.navButtonAdd('#jpager',
    {
        buttonicon: "glyphicon-usd",
        title: "Оплатить",
        caption: "Оплатить",
        position: "last",
        onClickButton: function () {
            // получаем идентификатор текущей записи
            var id = dbGrid.getGridParam("selrow");
            if (id) {
                var url = '@Url.Action("Pay")';
                $.ajax({
                     url: url,
                     type: 'POST',
                     data: { id: id },
                     success: function (data) {
                         // проверяем, не произошла ли ошибка
                         if (data.hasOwnProperty("error")) {
                             alertDialog('Ошибка', data.error);
                         }
                         else {
                             // обновление грида
                             $("#jqg").jqGrid(
                                 'setGridParam',
                                 {
                                     datatype: 'json'
                                 }
                             ).trigger('reloadGrid');
                         }
                     }
                });
            }
        }
    });
]]>                  
                </programlisting>
                </para>
                <para>В отличие от справочников диалоги редактирования для журналов намного сложнее.
                    Зачастую они используют выбор из других справочников. Поэтому такие диалоги
                    редактирования не получится построить стандартными способами jqGrid, однако в
                    этой библиотеки существует возможность построение диалогов по шаблону, которой
                    мы и воспользуемся.</para>
                <para>Для выбора заказчика сделаем поле только для чтения и разместим справа от него
                    кнопку для вызова формы с гридом для отображения списка заказчиков. <programlisting language="javascript">
<![CDATA[
// возвращает свойства для создания диалогов редактирования
function update(act) {
    // шаблон диалога редактирования
    var template = "<div style='margin-left:15px;' id='dlgEditInvoice'>";
    template += "<div>{CUSTOMER_ID} </div>";
    template += "<div> Date: </div><div>{INVOICE_DATE} </div>";
    // поле ввода заказчика с кнопкой
    template += "<div> Customer <sup>*</sup>:</div>";
    template += "<div>";
    template += "<div style='float: left;'>{CUSTOMER_NAME}</div> ";
    template += "<a style='margin-left: 0.2em;' class='btn'";
    template += " onclick='showCustomerWindow(); return false;'>";
    template += "<span class='glyphicon glyphicon-folder-open'></span>";
    template += " Выбрать</a> ";
    template += "<div style='clear: both;'></div>";
    template += "</div>";
    template += "<div> {PAID} Paid </div>";
    template += "<hr style='width: 100%;'/>";
    template += "<div> {sData} {cData}  </div>";
    template += "</div>";

    return {
        top: $(".container.body-content").position().top + 150,
        left: $(".container.body-content").position().left + 150,
        modal: true,
        drag: true,
        closeOnEscape: true,
        closeAfterAdd: true, // закрыть после добавления
        closeAfterEdit: true, // закрыть после редактирования
        reloadAfterSubmit: true, // обновление
        template: (act != "del") ? template : null,
        onclickSubmit: function (params, postdata) {
                    // получаем идентификатор строки
                    var selectedRow = dbGrid.getGridParam("selrow");
                    switch (act) {
                        case "add":
                            params.url = '@Url.Action("Create")';
                            // получаем идентификатор заказчика для текущей строки
                            postdata.CUSTOMER_ID = 
                                $('#dlgEditInvoice input[name=CUSTOMER_ID]').val();
                            break;

                        case "edit":
                            params.url = '@Url.Action("Edit")';
                            postdata.INVOICE_ID = selectedRow;
                            // получаем идентификатор заказчика для текущей строки
                            postdata.CUSTOMER_ID = 
                                $('#dlgEditInvoice input[name=CUSTOMER_ID]').val();
                            break;

                        case "del":
                            params.url = '@Url.Action("Delete")';
                            postdata.INVOICE_ID = selectedRow;
                            break;
                    }
                },
                afterSubmit: function (response, postdata) {
                    var responseData = response.responseJSON;
                    // проверяем результат на наличие сообщений об ошибках
                    if (responseData.hasOwnProperty("error")) {
                        if (responseData.error.length) {
                            return [false, responseData.error];
                        }
                    }
                    else {
                        // обновление грида
                        $(this).jqGrid(
                            'setGridParam',
                            {
                                datatype: 'json'
                            }
                        ).trigger('reloadGrid');
                    }
                    return [true, "", 0];
                }
        };
    };
}    
]]>                    
                </programlisting>
                </para>
                <para>Теперь напишем функцию для открытия справочника заказчиков. В этой функции мы
                    будем создавать диалог с помощью библиотеки Bootstrap, в котором будет размещён
                    грид для выбора заказчика. По сути, это тот же самый грид, который мы
                    использовали выше, но размещённый внутри диалогового окна. При нажатии кнопки
                    «OK» идентификатор заказчика и его имя будут записаны в элементы ввода
                    родительского диалога для редактирования счёт-фактуры. <programlisting language="javascript">
<![CDATA[
/**
  * Отображение окна для выбора справочника заказчиков
  */
function showCustomerWindow() {
    // основной блок диалога
    var dlg = $('<div>')
        .attr('id', 'dlgChooseCustomer')
        .attr('aria-hidden', 'true')
        .attr('role', 'dialog')
        .attr('data-backdrop', 'static')
        .css("z-index", '2000')
        .addClass('modal')
        .appendTo($('body'));

    // блок с содержимым диалога
    var dlgContent = $("<div>")
        .addClass("modal-content")
        .css('width', '730px')
        .appendTo($('<div>')
        .addClass('modal-dialog')
        .appendTo(dlg));

    // блок с шапкой диалога
    var dlgHeader = $('<div>').addClass("modal-header").appendTo(dlgContent);
    // кнопка "X" для закрытия
    $("<button>")
        .addClass("close")
        .attr('type', 'button')
        .attr('aria-hidden', 'true')
        .attr('data-dismiss', 'modal')
        .html("&times;")
        .appendTo(dlgHeader);
    // подпись
    $("<h5>").addClass("modal-title").html("Выбор заказчика").appendTo(dlgHeader);

    // тело диалога
    var dlgBody = $('<div>')
        .addClass("modal-body")
        .appendTo(dlgContent);

    // подвал диалога
    var dlgFooter = $('<div>').addClass("modal-footer").appendTo(dlgContent);
    // Кнопка "OK"
    $("<button>")
        .attr('type', 'button')
        .addClass('btn')
        .html('OK')
        .on('click', function () {
            var rowId = $("#jqgCustomer").jqGrid("getGridParam", "selrow");
            var row = $("#jqgCustomer").jqGrid("getRowData", rowId);
            // сохраняем идентификатор и имя заказчика
            // в элементы ввода родительской формы
            $('#dlgEditInvoice input[name=CUSTOMER_ID]').val(rowId);
            $('#dlgEditInvoice input[name=CUSTOMER_NAME]').val(row["NAME"]);
            dlg.modal('hide');
        })
        .appendTo(dlgFooter);
    // Кнопка "Cancel"
    $("<button>")
        .attr('type', 'button')
        .addClass('btn')
        .html('Cancel')
        .on('click', function () { dlg.modal('hide'); })
        .appendTo(dlgFooter);
    // добавляем таблицу для отображения заказчиков в тело диалога
    $('<table>')
        .attr('id', 'jqgCustomer')
        .appendTo(dlgBody);
    // добавляем панель навигации
    $('<div>')
        .attr('id', 'jqgCustomerPager')
        .appendTo(dlgBody);

    dlg.on('hidden.bs.modal', function () {
        dlg.remove();
    });

    // отображаем диалог
    dlg.modal();

    // создание и инициализация jqGrid
    var dbGrid = $("#jqgCustomer").jqGrid({
        url: '@Url.Action("GetData", "Customer")', // url для получения данных
        mtype: "GET", // тип http запроса 
        datatype: "json", // формат получения данных 
        page: 1,
        width: '100%',
        // описание модели
        colModel: [
            {
                 label: 'Id',          // подпись
                 name: 'CUSTOMER_ID',  // имя поля
                 key: true,            // признак ключевого поля
                 hidden: true          // скрытое 
            },
            {
                 label: 'Name',
                 name: 'NAME',
                 width: 250,           // ширина
                 sortable: true,       // разрешена сортировка
                 editable: true,       // разрешено редактирование
                 edittype: "text",     // тип поля в редакторе
                 search: true,         // разрешён поиск
                 searchoptions: {
                     sopt: ['eq', 'bw', 'cn'] // разрешённые операторы поиска
                 },
                 // размер и максимальная длина для поля ввода
                 editoptions: { size: 30, maxlength: 60 },
                 // говорит о том что поле обязательное
                 editrules: { required: true }
            },
            {
                 label: 'Address',
                 name: 'ADDRESS',
                 width: 300,
                 sortable: false,      // запрещаем сортировку
                 editable: true,       // редактируемое
                 search: false,        // запрещаем поиск
                 edittype: "textarea",
                 editoptions: { maxlength: 250, cols: 30, rows: 4 }
            },
            {
                 label: 'Zip Code',
                 name: 'ZIPCODE',
                 width: 60,
                 sortable: false,
                 editable: true,
                 search: false,
                 edittype: "text",
                 editoptions: { size: 30, maxlength: 10 },
            },
            {
                 label: 'Phone',
                 name: 'PHONE',
                 width: 85,
                 sortable: false,
                 editable: true,
                 search: false,
                 edittype: "text",
                 editoptions: { size: 30, maxlength: 14 },
            }
        ],
        loadonce: false,
        pager: '#jqgCustomerPager',
        rowNum: 500, // число отображаемых строк
        sortname: 'NAME', // сортировка по умолчанию по столбцу NAME
        sortorder: "asc", // порядок сортировки
        height: 500
    });

    dbGrid.jqGrid('navGrid', '#jqgCustomerPager',
        {
            search: true,  // поиск
            add: false,     // добавление
            edit: false,    // редактирование
            del: false,     // удаление
            view: false,    // просмотр записи
            refresh: true, // обновление

            searchtext: "Поиск",
            viewtext: "Смотреть",
            viewtitle: "Выбранная запись",
            refreshtext: "Обновить"
        }
    );
}
]]>                        
                    </programlisting>
                </para>
                <para>Для этого журнала нам осталось написать функцию
                        <function>showChildGrid</function>, которая позволяет просматривать и
                    редактировать информацию о позициях накладной. Эта функция будет динамически
                    создавать грид с позициями счёт-фактуры при нажатии на кнопку «+» (для раскрытия
                    деталей). Для загрузки данных о позиции нам будет необходимо передавать
                    первичный ключ выбранной шапки счёт фактуры. <programlisting language="javascript">
<![CDATA[
// обработчик события раскрытия родительского грида
// принимает два параметра идентификатор родительской записи
// и первичный ключ записи
function showChildGrid(parentRowID, parentRowKey) {
    var childGridID = parentRowID + "_table";
    var childGridPagerID = parentRowID + "_pager";

    // отправляем первичный ключ родительской записи
    // чтобы отфильтровать записи позиций накладной
    var childGridURL = '@Url.Action("GetDetailData")';
    childGridURL = childGridURL + "?invoice_id=" 
                 + encodeURIComponent(parentRowKey)

    // добавляем HTML элементы для отображения таблицы и постраничной навигации
    // как дочерние для выбранной строки в мастер гриде
    $('<table>')
        .attr('id', childGridID)
        .appendTo($('#' + parentRowID));
    $('<div>')
        .attr('id', childGridPagerID)
        .addClass('scroll')
        .appendTo($('#' + parentRowID));

    // создаём и инициализируем дочерний грид
    var detailGrid = $("#" + childGridID).jqGrid({
        url: childGridURL,
        mtype: "GET",
        datatype: "json",
        page: 1,
        colModel: [
            {
                 label: 'Invoice Line ID',
                 name: 'INVOICE_LINE_ID',
                 key: true,
                 hidden: true
            },
            {
                 label: 'Invoice ID',
                 name: 'INVOICE_ID',
                 hidden: true,
                 editrules: { edithidden: true, required: true },
                 editable: true,
                 edittype: 'custom',
                 editoptions: {
                     custom_element: function (value, options) {
                          // создаём скрытый эелемент ввода
                          return $("<input>")
                                .attr('type', 'hidden')
                                .attr('rowid', options.rowId)
                                .addClass("FormElement")
                                .addClass("form-control")
                                .val(parentRowKey)
                                .get(0);
                     }
                 }
            },
            {
                 label: 'Product ID',
                 name: 'PRODUCT_ID',
                 hidden: true,
                 editrules: { edithidden: true, required: true },
                 editable: true,
                 edittype: 'custom',
                 editoptions: {
                     custom_element: function (value, options) {
                         // создаём скрытый эелемент ввода
                         return $("<input>")
                              .attr('type', 'hidden')
                              .attr('rowid', options.rowId)
                              .addClass("FormElement")
                              .addClass("form-control")
                              .val(value)
                              .get(0);
                     }
                 }
            },
            {
                 label: 'Product',
                 name: 'Product',
                 width: 300,
                 editable: true,
                 edittype: "text",
                 editoptions: {
                     size: 50,
                     maxlength: 60,
                     readonly: true
                 },
                 editrules: { required: true }
            },
            {
                 label: 'Price',
                 name: 'Price',
                 formatter: 'currency',
                 editable: true,
                 editoptions: {
                     readonly: true
                 },
                 align: "right",
                 width: 100
            },
            {
                 label: 'Quantity',
                 name: 'Quantity',
                 align: "right",
                 width: 100,
                 editable: true,
                 editrules: { required: true, number: true, minValue: 1 },
                 editoptions: {
                   dataEvents: [
                     {
                        type: 'change',
                        fn: function (e) {
                          var quantity = $(this).val() - 0;
                          var price = 
                            $('#dlgEditInvoiceLine input[name=Price]').val() - 0;
                $('#dlgEditInvoiceLine input[name=Total]').val(quantity * price);
                        }
                     }
                   ],
                   defaultValue: 1
                 }
            },
            {
                 label: 'Total',
                 name: 'Total',
                 formatter: 'currency',
                 align: "right",
                 width: 100,
                 editable: true,
                 editoptions: {
                     readonly: true
                 }
            }
        ],
        loadonce: false,
        width: '100%',
        height: '100%',
        pager: "#" + childGridPagerID
    });

    // отображение панели инструментов
    $("#" + childGridID).jqGrid('navGrid', '#' + childGridPagerID,
        {
            search: false,  // поиск
            add: true,     // добавление
            edit: true,    // редактирование
            del: true,     // удаление
            refresh: true // обновление
        },
        updateDetail("edit"), // обновление
        updateDetail("add"), // добавление
        updateDetail("del") // удаление
    );

    // функция возвращающая настройки для диалога редактирования
    function updateDetail(act) {
        // шаблон диалога редактирования
        var template = "<div style='margin-left:15px;' id='dlgEditInvoiceLine'>";
        template += "<div>{INVOICE_ID} </div>";
        template += "<div>{PRODUCT_ID} </div>";
        // поле ввода товара с кнопкой
        template += "<div> Product <sup>*</sup>:</div>";
        template += "<div>";
        template += "<div style='float: left;'>{Product}</div> ";        
        template += "<a style='margin-left: 0.2em;' class='btn' ";
        template += "onclick='showProductWindow(); return false;'>";
        template += "<span class='glyphicon glyphicon-folder-open'></span>";
        template += " Выбрать</a> ";
        template += "<div style='clear: both;'></div>";
        template += "</div>";
        template += "<div> Quantity: </div><div>{Quantity} </div>";
        template += "<div> Price: </div><div>{Price} </div>";
        template += "<div> Total: </div><div>{Total} </div>";
        template += "<hr style='width: 100%;'/>";
        template += "<div> {sData} {cData}  </div>";
        template += "</div>";

        return {
            top: $(".container.body-content").position().top + 150,
            left: $(".container.body-content").position().left + 150,
            modal: true,
            drag: true,
            closeOnEscape: true,
            closeAfterAdd: true, // закрыть после добавления
            closeAfterEdit: true, // закрыть после редактирования
            reloadAfterSubmit: true, // обновление
            template: (act != "del") ? template : null,
            onclickSubmit: function (params, postdata) {
                 var selectedRow = detailGrid.getGridParam("selrow");
                 switch (act) {
                     case "add":
                         params.url = '@Url.Action("CreateDetail")';
                         // получаем идентификатор счёт-фактуры
                         postdata.INVOICE_ID = 
                            $('#dlgEditInvoiceLine input[name=INVOICE_ID]').val();
                         // получаем идентификатор товара для текущей записи
                         postdata.PRODUCT_ID = 
                            $('#dlgEditInvoiceLine input[name=PRODUCT_ID]').val();
                         break;

                     case "edit":
                         params.url = '@Url.Action("EditDetail")';
                         // получаем идентификатор текущей записи
                         postdata.INVOICE_LINE_ID = selectedRow;
                         break;

                     case "del":
                         params.url = '@Url.Action("DeleteDetail")';
                         // получаем идентификатор текущей записи
                         postdata.INVOICE_LINE_ID = selectedRow;
                         break;
                 }
            },
            afterSubmit: function (response, postdata) {
                var responseData = response.responseJSON;
                // проверяем результат на наличие сообщений об ошибках
                if (responseData.hasOwnProperty("error")) {
                    if (responseData.error.length) {
                        return [false, responseData.error];
                    }
                }
                else {
                    // обновление грида
                    $(this).jqGrid(
                       'setGridParam',
                       {
                           datatype: 'json'
                       }
                    ).trigger('reloadGrid');
                }
                return [true, "", 0];
            }
        };
    };
}    
]]>                   
                </programlisting>
                </para>
                <para>Вот теперь создание журнала счёт-фактур закончено. Здесь мы не рассмотрели
                    функцию <function>showProductWindow</function>, которая предназначена для выбора
                    товара из справочника при заполнении позиций счёт-фактуры. Эта функция полностью
                    аналогична ранее описанной функции <function>showCustomerWindow</function>,
                    предназначенной для выбора из справочника заказчиков.</para>
                <para>Внимательный читатель мог заметить, что функции для отображения выбора из
                    справочника и отображения справочника почти идентичные. Это можно улучшить
                    выносив эти функции в отдельные файлы скриптов с расширением js. Попробуйте
                    сделать это самостоятельно.</para>
            </section>
        </section>
        <section>
            <title>Аутентификация и авторизация</title>

            <para>Технология ASP.NET имеет мощный механизм для организации авторизации и
                аутентификации в .NET приложениях под названием ASP.NET Identity. Инфраструктура
                OWIN и AspNet Identity позволяют производить как стандартную авторизацию, так и
                авторизацию через внешние сервисы с помощью аккаунтов в Google, Twitter, Facebook и
                т.д. Описание технологии ASP.NET Identity является достаточно объёмным и выходит за
                рамки данной статьи. Вы можете почитать об этой технологии на сайте <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.asp.net/identity"
                >http://www.asp.net/identity</link>.</para>
            <para> А в нашем приложении мы будем использовать чуть более простую модель, основанную
                на аутентификации форм. Для включения аутентификации форм необходимо сделать
                изменения в файле конфигурации <filename>web.config</filename>. Находим секцию
                <!--CDATA[<system.web>]--> и внутри этой секции поместим следующую подсекцию: <programlisting language="xml">
<![CDATA[
<authentication mode="Forms">
  <forms name="cookies" timeout="2880" loginUrl="~/Account/Login" 
         defaultUrl="~/Invoice/Index"/>
</authentication>
]]>                    
                </programlisting>
            </para>
            <para>Установив mode="Forms", мы тем самым подключаем аутентификацию форм. Далее мы
                задаём ряд параметров. Нам доступен следующий список параметров:<itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">coockieless</emphasis>: определяет, применяются
                            ли куки-наборы и как они используются. Может принимать следующие
                            значения: <emphasis role="bold">UseCookies</emphasis>(определяет, что
                            куки-наборы будут использоваться всегда вне зависимости от устройства),
                                <emphasis role="bold">UseUri</emphasis> (куки-наборы никогда не
                            используются), <emphasis role="bold">AutoDetect</emphasis> (если
                            устройство поддерживает куки-наборы, то они используются, в противном
                            случае они не применяются, при этом проводится тестирование,
                            определяющее, включена ли поддержка), <emphasis role="bold"
                                >UseDeviceProfile</emphasis> (если устройство поддерживает
                            куки-наборы, то они используются, в противном случае они не применяются,
                            в отличие от предыдущего случая тестирование не проводится. Используется
                            по умолчанию).</para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis role="bold">defaultUrl</emphasis>: определяет путь, по
                            которому осуществляется переход после авторизации</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">domain</emphasis>: определяет куки-наборы для
                            всего домена. Благодаря этому мы можем использовать одни и те же
                            куки-наборы для главного домена и его субдоменов. По умолчанию имеет
                            значение в качестве пустой строки</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">loginUrl</emphasis>: адрес для аутентификации
                            пользователя. Значение по умолчанию — "~/Account/Login"</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">name</emphasis>: задаёт имя для куки-набора.
                            Значение по умолчанию — ".ASPXAUTH"</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">path</emphasis>: задаёт путь для куки-наборов.
                            Значение по умолчанию — "/"</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">requireSSL</emphasis>: определяет, требуется ли
                            SSL-соединение для передачи куки-наборов. Значение по умолчанию
                            false</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">timeout</emphasis>: определяет срок действия
                            куков в минутах</para>
                    </listitem>
                </itemizedlist></para>
            <para>В нашем приложении мы будем хранить данные аутентификации в той же базе данных,
                что и другие данные, поэтому настройка дополнительной строки подключения нам не
                потребуется.</para>
            <para>Теперь надо создать всю необходимую инфраструктуру для аутентификации — модели,
                контроллеры и представления. Создадим модель <classname>WebUser</classname>, которая
                будет описывать пользователя: <programlisting language="csharp">
<![CDATA[
[Table("Firebird.WEBUSER")]
public partial class WEBUSER
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", 
       "CA2214:DoNotCallOverridableMethodsInConstructors")]
    public WEBUSER()
    {
        WEBUSERINROLES = new HashSet<WEBUSERINROLE>();
    }

    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.None)]
    public int WEBUSER_ID { get; set; }

    [Required]
    [StringLength(63)]
    public string EMAIL { get; set; }

    [Required]
    [StringLength(63)]
    public string PASSWD { get; set; }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", 
       "CA2227:CollectionPropertiesShouldBeReadOnly")]
    public virtual ICollection<WEBUSERINROLE> WEBUSERINROLES { get; set; }
}
]]>    
</programlisting>
            </para>
            <para>Добавим ещё две модели: одну для описания ролей WEBROLE, и одну для связи ролей с
                пользователями WEBUSERINROLE. <programlisting language="csharp">
<![CDATA[
    [Table("Firebird.WEBROLE")]
    public partial class WEBROLE
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.None)]
        public int WEBROLE_ID { get; set; }

        [Required]
        [StringLength(63)]
        public string NAME { get; set; }

    }

    [Table("Firebird.WEBUSERINROLE")]
    public partial class WEBUSERINROLE
    {

        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.None)]
        public int ID { get; set; }

        [Required]
        public int WEBUSER_ID { get; set; }

        [Required]
        public int WEBROLE_ID { get; set; }

        public virtual WEBUSER WEBUSER { get; set; }

        public virtual WEBROLE WEBROLE { get; set; }
    }
]]>    
</programlisting>
            </para>
            <para>В классе DbModel с помощью Fluent API укажем связи между WEBUSER и WEBUSERINROLE. <programlisting language="csharp">
<![CDATA[
…
        public virtual DbSet<WEBUSER> WEBUSERS { get; set; }
        public virtual DbSet<WEBROLE> WEBROLES { get; set; }
        public virtual DbSet<WEBUSERINROLE> WEBUSERINROLES { get; set; }
…
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<WEBUSER>()
                .HasMany(e => e.WEBUSERINROLES)
                .WithRequired(e => e.WEBUSER)
                .WillCascadeOnDelete(false);

…
        }
…
]]>    
</programlisting>
            </para>
            <para>Поскольку мы используем технологию Database First, то таблицы в БД могут быть
                созданы автоматически, но я предпочитаю сам контролировать этот процесс, поэтому
                приведу здесь скрипт создания дополнительных таблиц. <programlisting language="sql">
<![CDATA[
RECREATE TABLE WEBUSER (
  WEBUSER_ID INT NOT NULL,
  EMAIL VARCHAR(63) NOT NULL,
  PASSWD VARCHAR(63) NOT NULL,
  CONSTRAINT PK_WEBUSER PRIMARY KEY(WEBUSER_ID),
  CONSTRAINT UNQ_WEBUSER UNIQUE(EMAIL)
);

RECREATE TABLE WEBROLE (
  WEBROLE_ID INT NOT NULL,
  NAME VARCHAR(63) NOT NULL,
  CONSTRAINT PK_WEBROLE PRIMARY KEY(WEBROLE_ID),
  CONSTRAINT UNQ_WEBROLE UNIQUE(NAME)
);

RECREATE TABLE WEBUSERINROLE (
  ID INT NOT NULL,
  WEBUSER_ID INT NOT NULL,
  WEBROLE_ID INT NOT NULL,
  CONSTRAINT PK_WEBUSERINROLE PRIMARY KEY(ID)
);


ALTER TABLE WEBUSERINROLE
ADD CONSTRAINT FK_WEBUSERINROLE_USER FOREIGN KEY (WEBUSER_ID) REFERENCES WEBUSER (WEBUSER_ID);

ALTER TABLE WEBUSERINROLE
ADD CONSTRAINT FK_WEBUSERINROLE_ROLE FOREIGN KEY (WEBROLE_ID) REFERENCES WEBROLE (WEBROLE_ID);


RECREATE SEQUENCE SEQ_WEBUSER;
RECREATE SEQUENCE SEQ_WEBROLE;
RECREATE SEQUENCE SEQ_WEBUSERINROLE;

SET TERM ^;

RECREATE TRIGGER TBI_WEBUSER
FOR WEBUSER
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (NEW.WEBUSER_ID IS NULL) THEN
    NEW.WEBUSER_ID = NEXT VALUE FOR SEQ_WEBUSER;
END^

RECREATE TRIGGER TBI_WEBROLE
FOR WEBROLE
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (NEW.WEBROLE_ID IS NULL) THEN
    NEW.WEBROLE_ID = NEXT VALUE FOR SEQ_WEBROLE;
END^

RECREATE TRIGGER TBI_WEBUSERINROLE
FOR WEBUSERINROLE
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = NEXT VALUE FOR SEQ_WEBUSERINROLE;
END^

SET TERM ;^
]]>    
</programlisting>
            </para>
            <para>Добавим два пользователя и две роли для проверки. <programlisting language="sql">
<![CDATA[
INSERT INTO WEBUSER (EMAIL, PASSWD) VALUES ('john', '12345');
INSERT INTO WEBUSER (EMAIL, PASSWD) VALUES ('alex', '123');

COMMIT;

INSERT INTO WEBROLE (NAME) VALUES ('admin');
INSERT INTO WEBROLE (NAME) VALUES ('manager');

COMMIT;

-- Связываем пользователей и роли
INSERT INTO WEBUSERINROLE(WEBUSER_ID, WEBROLE_ID) VALUES(1, 1);
INSERT INTO WEBUSERINROLE(WEBUSER_ID, WEBROLE_ID) VALUES(1, 2);
INSERT INTO WEBUSERINROLE(WEBUSER_ID, WEBROLE_ID) VALUES(2, 2);

COMMIT;
]]>                
            </programlisting>
            </para>
            <note>
                <title>Замечание о паролях</title>

                <para>Обычно вместо пароля в открытом виде хранят некий хэш от него, например, по
                    алгоритму md5. В нашем примере мы немного упростили аутентификацию.</para>
            </note>
            <para>При регистрации и логине мы не будем напрямую взаимодействовать с моделью WebUser.
                Вместо этого мы будем использовать специальные модели, которые также добавим в
                проект: <programlisting language="csharp">
<![CDATA[
namespace FBMVCExample.Models
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.ComponentModel.DataAnnotations.Schema;
    using System.Data.Entity.Spatial;

    // Модель для входа в систему
    public class LoginModel
    {
        [Required]
        public string Name { get; set; }

        [Required]
        [DataType(DataType.Password)]
        public string Password { get; set; }
    }

    // Модель для регистрации нового пользователя
    public class RegisterModel
    {
        [Required]
        public string Name { get; set; }

        [Required]
        [DataType(DataType.Password)]
        public string Password { get; set; }

        [Required]
        [DataType(DataType.Password)]
        [Compare("Password", ErrorMessage = "Пароли не совпадают")]
        public string ConfirmPassword { get; set; }
    }
}
]]>                
            </programlisting>
            </para>
            <para>Эти модели будет использоваться соответственно для представлений логина и
                регистрации. Эти представление для входа будет выглядеть следующим образом: <programlisting language="javascript">
<![CDATA[
@model FBMVCExample.Models.LoginModel

@{
    ViewBag.Title = "Вход";
}

<h2>Вход</h2>

@using (Html.BeginForm())
{
    @Html.AntiForgeryToken()

    <div class="form-horizontal">
        @Html.ValidationSummary(true)

        <div class="form-group">
            @Html.LabelFor(model => model.Name, 
                new { @class = "control-label col-md-2" })
            <div class="col-md-10">
                @Html.EditorFor(model => model.Name)
                @Html.ValidationMessageFor(model => model.Name)
            </div>
        </div>

        <div class="form-group">
            @Html.LabelFor(model => model.Password, 
                new { @class = "control-label col-md-2" })
            <div class="col-md-10">
                @Html.EditorFor(model => model.Password)
                @Html.ValidationMessageFor(model => model.Password)
            </div>
        </div>

        <div class="form-group">
            <div class="col-md-offset-2 col-md-10">
                <input type="submit" value="Вход" class="btn btn-default" />
            </div>
        </div>
    </div>
}

@section Scripts {
    @Scripts.Render("~/bundles/jqueryval")
}
]]>                
            </programlisting>
            </para>
            <para>Соответственно, представление для регистрации будет выглядеть так: <programlisting language="javascript">
<![CDATA[
@model FBMVCExample.Models.RegisterModel

@{
    ViewBag.Title = "Регистрация";
}

<h2>Регистрация</h2>


@using (Html.BeginForm())
{
    @Html.AntiForgeryToken()

    <div class="form-horizontal">
        @Html.ValidationSummary(true)

        <div class="form-group">
            @Html.LabelFor(model => model.Name, 
                new { @class = "control-label col-md-2" })
            <div class="col-md-10">
                @Html.EditorFor(model => model.Name)
                @Html.ValidationMessageFor(model => model.Name)
            </div>
        </div>

        <div class="form-group">
            @Html.LabelFor(model => model.Password, 
                new { @class = "control-label col-md-2" })
            <div class="col-md-10">
                @Html.EditorFor(model => model.Password)
                @Html.ValidationMessageFor(model => model.Password)
            </div>
        </div>

        <div class="form-group">
            @Html.LabelFor(model => model.ConfirmPassword, 
                new { @class = "control-label col-md-2" })
            <div class="col-md-10">
                @Html.EditorFor(model => model.ConfirmPassword)
                @Html.ValidationMessageFor(model => model.ConfirmPassword)
            </div>
        </div>


        <div class="form-group">
            <div class="col-md-offset-2 col-md-10">
                <input type="submit" value="Зарегистрировать" 
                       class="btn btn-default" />
            </div>
        </div>
    </div>
}

@section Scripts {
    @Scripts.Render("~/bundles/jqueryval")
}
]]>                
            </programlisting>
            </para>
            <note>
                <title>Замечание о пользователях</title>

                <para>В данном примере модель, представление и контроллеры для входа и регистрации
                    пользователей предельно упрощены, т.к. обычно пользователь имеет существенно
                    больше атрибутов, чем логин и пароль.</para>
            </note>
            <para>Теперь добавим новый контроллер AccountController со следующим содержанием: <programlisting language="csharp">
<![CDATA[
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Web.Security;
using FBMVCExample.Models;

namespace FBMVCExample.Controllers
{
    public class AccountController : Controller
    {
        public ActionResult Login()
        {
            return View();
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Login(LoginModel model)
        {
            if (ModelState.IsValid)
            {
                // поиск пользователя в бд
                WEBUSER user = null;
                using (DbModel db = new DbModel())
                {
                    user = db.WEBUSERS.FirstOrDefault(
                        u => u.EMAIL == model.Name && 
                             u.PASSWD == model.Password);

                }
                // если нашли пользователя с введённым логином и паролем, то 
                // запоминаем его и делаем переадресацию на стартовую страницу
                if (user != null)
                {
                    FormsAuthentication.SetAuthCookie(model.Name, true);
                    return RedirectToAction("Index", "Invoice");
                }
                else
                {
                    ModelState.AddModelError("", 
                        "Пользователя с таким логином и паролем не существует");
                }
            }

            return View(model);
        }

        [Authorize(Roles = "admin")]
        public ActionResult Register()
        {
            return View();
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Register(RegisterModel model)
        {
            if (ModelState.IsValid)
            {
                WEBUSER user = null;
                using (DbModel db = new DbModel())
                {
                    user = db.WEBUSERS.FirstOrDefault(u => u.EMAIL == model.Name);
                }
                if (user == null)
                {
                    // создаём нового пользователя
                    using (DbModel db = new DbModel())
                    {

                        // получаем новый идентификатор с помощью генератора
                        int userId = db.NextValueFor("SEQ_WEBUSER");
                        db.WEBUSERS.Add(new WEBUSER {
                            WEBUSER_ID = userId,
                            EMAIL = model.Name,
                            PASSWD = model.Password
                        });
                        db.SaveChanges();

                        user = db.WEBUSERS.Where(u => u.WEBUSER_ID == userId)
                                          .FirstOrDefault();

                        // находим роль manager
                        // Эта роль будет ролью по умолчанию, т.е.
                        // будет выдана автоматически при регистрации
                        var defaultRole = 
                            db.WEBROLES
                              .Where(r => r.NAME == "manager")
                              .FirstOrDefault();

                        // назначаем вновь добавленному пользователю роль 
                        // по умолчанию
                        if (user != null && defaultRole != null)
                        {
                            db.WEBUSERINROLES.Add(new WEBUSERINROLE
                            {
                                WEBUSER_ID = user.WEBUSER_ID,
                                WEBROLE_ID = defaultRole.WEBROLE_ID
                            });
                            db.SaveChanges();
                        }
                    }
                    // если пользователь удачно добавлен в бд
                    if (user != null)
                    {
                        FormsAuthentication.SetAuthCookie(model.Name, true);
                        return RedirectToAction("Login", "Account");
                    }
                }
                else
                {
                    ModelState.AddModelError("", 
                        "Пользователь с таким логином уже существует");
                }
            }

            return View(model);
        }

        public ActionResult Logoff()
        {
            FormsAuthentication.SignOut();
            return RedirectToAction("Login", "Account");
        }
    }
}
]]>                
            </programlisting>
            </para>
            <para>Обратите внимание на атрибут <function>[Authorize(Roles = "admin")]</function>. Он
                обозначает, что действие по регистрации пользователей может производить только
                пользователь с ролью admin. Этот механизм называется фильтрами авторизации. Он нём
                будет сказано чуть позже.</para>
            <para>При регистрации мы добавляем нового пользователя в БД, а при логине просто
                смотрим, есть ли такой пользователь. И если пользователь найден, то с помощью
                аутентификации форм устанавливаем куки
                <programlisting language="csharp">
FormsAuthentication.SetAuthCookie(model.Name, true);                
            </programlisting>
            </para>
            <para>Вся информация о пользователе в Asp.Net MVC хранится в свойстве
                    <property>HttpContext.User</property>, которое представляет реализацию
                интерфейса <classname>IPrincipal</classname>, который определён в пространстве имён
                    <classname>System.Security.Principal</classname>.</para>
            <para>Интерфейс <classname>IPrincipal</classname> определяет свойство
                    <property>Identity</property>, которое хранит объект интерфейса
                    <classname>IIdentity</classname>, который описывает текущего
                пользователя.</para>
            <para>Интерфейс <classname>IIdentity</classname> содержит следующие свойства:<itemizedlist>
                    <listitem>
                        <para><property>AuthenticationType</property>: тип аутентификации</para>
                    </listitem>
                    <listitem>
                        <para><property>IsAuthenticated</property>: если пользователь
                            аутентифицирован, то возвращает <literal>true</literal></para>
                    </listitem>
                    <listitem>
                        <para><property>Name</property>: имя пользователя в системе</para>
                    </listitem>
                </itemizedlist></para>
            <para>Для определения аутентифицирован ли пользователь, ASP.NET MVC принимает от
                браузера куки, и если пользователь аутентифицирован, у свойства
                    <property>IIdentity.IsAuthenticated</property> устанавливается значение
                    <literal>true</literal>, а в свойство Name получает в качестве значения имя
                пользователя.</para>
            <para>Теперь добавим элементы авторизации. Для этого воспользуемся механизмом
                универсальных провайдеров.</para>
            <para>Универсальные провайдеры предоставляют уже готовый функционал авторизации. Но в то
                же время эти провайдеры обладают достаточной гибкостью — в частности мы можем их
                переопределить по своему усмотрению. При этом нам необязательно переопределять и
                использовать все четыре провайдера. Что довольно удобно, особенно в ситуации, когда
                нам не нужны все навороты ASP.NET Identity, а требуется построить очень простенькую
                систему авторизации.</para>
            <para>Итак, переопределим провайдер ролей. Для этого добавим через NuGet пакет
                Microsoft.AspNet.Providers.</para>
            <para>Теперь определим сам провайдер ролей. Для этого сначала добавим в проект папку
                    <filename>Providers</filename> и затем в него добавим новый класс
                    <classname>MyRoleProvider</classname>: <programlisting language="csharp">
<![CDATA[
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Security;
using FBMVCExample.Models;

namespace FBMVCExample.Providers
{
    public class MyRoleProvider : RoleProvider
    {
        /// <summary>
        /// Возвращает список имён ролей у пользователя
        /// </summary>
        /// <param name="username">Имя пользователя</param>
        /// <returns></returns>
        public override string[] GetRolesForUser(string username)
        {
            string[] roles = new string[] { };
            using (DbModel db = new DbModel())
            {
                // Получаем пользователя
                WEBUSER user = db.WEBUSERS.FirstOrDefault(
                    u => u.EMAIL == username);
                if (user != null)
                {
                    // заполняем массив доступных ролей
                    int i = 0;
                    roles = new string[user.WEBUSERINROLES.Count];
                    foreach (var rolesInUser in user.WEBUSERINROLES)
                    {
                        roles[i] = rolesInUser.WEBROLE.NAME;
                        i++;
                    }
                }
            }
            return roles;
        }

        /// <summary>
        /// Создаение новой роли
        /// </summary>
        /// <param name="roleName">Имя роли</param>
        public override void CreateRole(string roleName)
        {

            using (DbModel db = new DbModel())
            {
                WEBROLE newRole = new WEBROLE() { NAME = roleName };
                db.WEBROLES.Add(newRole);
                db.SaveChanges();
            }
        }

        /// <summary>
        /// Возвращает присутствует ли роль у пользователя
        /// </summary>
        /// <param name="username">Имя пользователя</param>
        /// <param name="roleName">Имя роли</param>
        /// <returns></returns>
        public override bool IsUserInRole(string username, string roleName)
        {
            bool outputResult = false;
            using (DbModel db = new DbModel())
            {
                var userInRole =
                    from ur in db.WEBUSERINROLES
                    where ur.WEBUSER.EMAIL == username && 
                          ur.WEBROLE.NAME == roleName
                    select new { id = ur.ID };

                outputResult = userInRole.Count() > 0;
            }
            return outputResult;
        }

        public override void AddUsersToRoles(string[] usernames, 
            string[] roleNames)
        {
            throw new NotImplementedException();
        }

        public override string ApplicationName
        {
            get { throw new NotImplementedException(); }
            set { throw new NotImplementedException(); }
        }

        public override bool DeleteRole(string roleName, 
            bool throwOnPopulatedRole)
        {
            throw new NotImplementedException();
        }

        public override string[] FindUsersInRole(string roleName, 
            string usernameToMatch)
        {
            throw new NotImplementedException();
        }

        public override string[] GetAllRoles()
        {
            throw new NotImplementedException();
        }

        public override string[] GetUsersInRole(string roleName)
        {
            throw new NotImplementedException();
        }

        public override void RemoveUsersFromRoles(string[] usernames, 
            string[] roleNames)
        {
            throw new NotImplementedException();
        }

        public override bool RoleExists(string roleName)
        {
            throw new NotImplementedException();
        }
    }
}
]]>                
            </programlisting>
            </para>
            <para>В целях демонстрации переопределено три метода. Первый из них —
                    <function>GetRolesForUser</function> позволяет получать набор ролей для
                определённого пользователя. Второй метод — <function>CreateRole</function> —
                предполагает создание роли. И третий метод — <function>IsUserInRole</function> —
                определяет, выполняет ли пользователь определённую роль в системе.</para>
            <para>Чтобы использовать провайдер ролей в приложении, надо добавить его определение в
                файл конфигурации. Откроем файл <filename>web.config</filename> и удалим из него
                определение провайдеров, которые были добавлены автоматически при добавлении пакета
                Microsoft.AspNet.Providers. И добавим туда вместо этого в пределах узла system.web
                добавим наш провайдер: <programlisting language="xml">
<![CDATA[
<system.web>
    <authentication mode="Forms">
      <forms name="cookies" timeout="2880" loginUrl="~/Account/Login" 
             defaultUrl="~/Invoice/Index"/>
    </authentication>
    <roleManager enabled="true" defaultProvider="MyRoleProvider">
      <providers>
        <add name="MyRoleProvider" 
             type="FBMVCExample.Providers.MyRoleProvider" />
      </providers>
    </roleManager>
  </system.web>
]]>                
            </programlisting>
            </para>
            <para>И теперь мы можем разграничить доступ к методам различных контроллеров с помощью
                атрибута <property>Authorize</property>. Мы уже видели его применение в контроллере
                    <classname>AccountController</classname>: <programlisting language="csharp">
<![CDATA[
[Authorize(Roles = "admin")]
public ActionResult Register()
{
…
]]>                    
                </programlisting>
            </para>
            <para>Данный фильтр можно применять как на уровне контроллера в целом, так и для
                отдельного действия контроллера. Давайте добавим разграничение прав для наших трёх
                основных контроллеров <classname>CustomerController</classname>,
                    <classname>InvoiceController</classname> и
                    <classname>ProductController</classname>. В нашем случае пользователь с ролью
                manager может смотреть и править данные во всех трёх таблицах. Установка фильтра для
                контроллера <classname>InvoiceController</classname> будет выглядеть следующим
                образом: <programlisting language="csharp">
<![CDATA[
[Authorize(Roles = "manager")]
public class InvoiceController : Controller
{
    private DbModel db = new DbModel();

    // Отображение представления
    public ActionResult Index()
    {
        return View();
    }
…
]]>                    
                </programlisting>
            </para>
        </section>
        <section>
            <title>Заключение</title>

            <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_dot_NET_MVC_source.zip"
                    >Исходные коды примера приложения</link></para>
            <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_database.zip"
                    >Готовая БД 2.5 и 3.0</link></para>
            <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ibase.ru"
                    >www.ibase.ru</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibsurgeon.com">www.ibsurgeon.com</link></para>
            <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="mailto:support@ibase.ru">support@ibase.ru</link>, <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="mailto:support@ib-aid.com">support@ib-aid.com</link></para>
        </section>
    </section>
    <section>
        <title>Создание Web приложений на PHP</title>

        <para>В этой главе мы рассмотрим процесс создания web приложения с использованием СУБД
            Firebird на языке PHP.</para>

        <section>
            <title>Обзор драйверов для работы с Firebird </title>

            <para>В PHP есть два драйвера для работы с СУБД Firebird:<itemizedlist>
                    <listitem>
                        <para>Расширение<link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://php.net/ibase">Firebird/Interbase</link> (ibase_
                            функции );</para>
                    </listitem>
                    <listitem>
                        <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://php.net/manual/ru/ref.pdo-firebird.php">PDO
                                драйвер</link> для Firebird.</para>
                    </listitem>
                </itemizedlist>
            </para>

            <section>
                <title>Обзор расширения Firebird/Interbase</title>

                <para>Расширение Firebird/Interbase появилось раньше и является наиболее
                    проверенным.</para>

                <para>Для установки расширения Firebird/Interbase в конфигурационном файле
                        <filename>php.ini</filename> необходимо раскомментировать строку
                    <programlisting language="ini">
extension=php_interbase.dll                    
                </programlisting>
                    или для UNIX подобных систем строку
                    <programlisting language="ini">
extension=php_interbase.so                    
                </programlisting>
                </para>
                <para>Это расширение требует, чтобы у вас была установлена клиентская библиотека
                        <filename>fbclient.dll</filename>/<filename>gds32.dll</filename> (для UNIX
                    подобных систем <filename>fbclient.so</filename>) соответствующей разрядности. </para>

                <note>
                    <title>Замечание для пользователей Win32/Win64</title>

                    <para>Для работы этого расширения системной переменной Windows PATH должны быть
                        доступны DLL-файлы <filename>fbclient.dll</filename> или
                            <filename>gds32.dll</filename>. Хотя копирование DLL-файлов из
                        директории PHP в системную папку Windows также решает проблему (потому что
                        системная директория по умолчанию находится в переменной PATH), это не
                        рекомендуется. Этому расширению требуются следующие файлы в переменной PATH:
                            <filename>fbclient.dll</filename> или
                        <filename>gds32.dll</filename>.</para>
                </note>

                <para>В Linux это расширение в зависимости от дистрибутива можно установить одной из
                    следующих команд (необходимо уточнить поддерживаемые версии, возможно,
                    необходимо подключить сторонний репозиторий):
                    <screen>
apt-get install php5-firebird

rpm –ihv php5-firebird

yum install php70w-interbase

zypper install php5-firebird                    
                </screen>
                </para>
                <para>Это расширение использует процедурный подход к написанию программ. Функции с
                    префиксом <function>ibase_</function> могут возвращать или принимать в качестве
                    одного из параметров идентификатор соединения, транзакции, подготовленного
                    запроса или курсора (результат SELECT запроса). Этот идентификатор имеет тип
                        <type>resource</type>. Все выделенные ресурсы необходимо освобождать, как
                    только они больше не требуются. Я не буду описывать каждую из функций подробно,
                    вы можете посмотреть их описание по адресу <link
                        xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://php.net/ibase"
                        >http://php.net/ibase</link>, вместо этого приведу несколько небольших
                    примеров с комментариями. </para>
                <para>
                    <programlisting language="php">
<![CDATA[
<?php

$db = 'localhost:example';
$username = 'SYSDBA';
$password = 'masterkey';

// Подключение к БД
$dbh = ibase_connect($db, $username, $password);
$sql = 'SELECT login, email FROM users';
// Выполняем запрос
$rc = ibase_query($dbh, $sql);
// Получаем результат построчно в виде объекта
while ($row = ibase_fetch_object($rc)) {
    echo $row->email, "\n";
}
// Освобождаем хэндл связанный с результатом запроса
ibase_free_result($rc);
// Освобождаем хэндл связанный с подключением
ibase_close($dbh);
]]>                        
                    </programlisting>
                </para>
                <para>Вместо функции <function>ibase_connect</function> вы можете применять функцию
                        <function>ibase_pconnect</function>, которая создаёт так называемые
                    постоянные соединения. В этом случае при вызове <function>ibase_close</function>
                    соединение не закрывается, все связанные с ней ресурсы освобождаются, транзакция
                    по умолчанию подтверждается, другие виды транзакций откатываются. Такое
                    соединение может быть использовано повторно в другой сессии, если параметры
                    подключения совпадают. В некоторых случаях постоянные соединения могут
                    значительно повысить эффективность вашего веб приложения. Это особенно заметно,
                    если затраты на установку соединения велики. Они позволяют дочернему процессу на
                    протяжении всего жизненного цикла использовать одно и то же соединение вместо
                    того, чтобы создавать его при обработке каждой страницы, которая взаимодействует
                    с SQL-сервером. Этим постоянные соединения напоминают работу с пулом соединений.
                    Подробнее о постоянных соединениях вы может прочитать по ссылке <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/persistent-connections"
                        >http://php.net/persistent-connections</link>.</para>
                <important>
                    <para>Многие ibase функции позволяют не передавать в них идентификатор
                        соединения (транзакции, подготовленного запроса). В этом случае эти функции
                        используют идентификатор последнего установленного соединения (начатой
                        транзакции). Я не рекомендую так делать, в особенности, если ваше веб
                        приложение может использовать более одного подключения.</para>
                </important>

                <para>Функция ibase_query выполняет SQL запрос и возвращает идентификатор результата
                    или true, если запрос не возвращает набор данных. Эта функция помимо
                    идентификатора подключения (транзакции) и текста SQL запроса может принимать
                    переменное число аргументов в качестве значений параметров SQL запроса. В этом
                    случае наш пример выглядит следующим образом: <programlisting language="php">
<![CDATA[
// …
$sql = 'SELECT login, email FROM users WHERE id=?';
$id = 1;  
// Выполняем запрос
$rc = ibase_query($dbh, $sql, $id);
// Получаем результат построчно в виде объекта
if ($row = ibase_fetch_object($rc)) {
    echo $row->email, "\n";
}
// Освобождаем хэндл связанный с результатом запроса
ibase_free_result($rc);
// …
]]>                    
                </programlisting>
                </para>
                <para>Очень часто параметризованные запросы используются многократно с различным
                    набором значений параметров, в этом случае для повышения производительности
                    рекомендуется использовать подготовленные запросы. В этом случае сначала
                    необходимо сначала получить идентификатор подготовленного запроса с помощью
                    функции <function>ibase_prepare</function>, а затем выполнять подготовленный
                    запрос с помощью функции <function>ibase_execute</function>. <programlisting language="php">
<![CDATA[
// …
$sql = 'SELECT login, email FROM users WHERE id=?';
// Подготавливаем запрос
$sth = ibase_prepare($dbh, $sql);
$id = 1;  
// Выполняем запрос
$rc = ibase_execute($sth, $id);
// Получаем результат построчно в виде объекта
if ($row = ibase_fetch_object($rc)) {
    echo $row->email, "\n";
}
// Освобождаем хэндл связанный с результатом запроса
ibase_free_result($rc);
// Освобождаем подготовленный запрос
ibase_free_query($sth);
// …
]]>                    
                </programlisting>
                </para>
                <para>Подготовленные запросы гораздо чаще используются, когда необходима массовая
                    заливка данных. <programlisting language="php">
<![CDATA[
// …
$sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
// Подготавливаем запрос
$sth = ibase_prepare($dbh, $sql);
$users = [["user1", "user1@gmail.com"], ["user2", "user2@gmail.com"]];  
// Выполняем запрос
foreach ($users as $user)) {
  ibase_execute($sth, $user[0], $user[1]);
}
// Освобождаем подготовленный запрос
ibase_free_query($sth);
// …
]]>                    
                </programlisting>
                </para>
                <para>По последнему примеру можно увидеть один из недостатков этого расширения, а
                    именно, функции с переменным числом аргументов не очень удобны для
                    параметризованных запросов. Этот недостаток проявляется особенно ярко, если вы
                    пытаетесь написать универсальный класс для исполнения любых запросов. Гораздо
                    удобнее было бы, если параметры можно было передавать одним массивом. Конечно,
                    существуют обходные пути вроде вот такого: <programlisting language="php">
<![CDATA[
function fb_execute ($stmt, $data)
{
   if (!is_array($data))
       return ibase_execute($stmt, $data);
   array_unshift($data, $stmt); 
   $rc = call_user_func_array('ibase_execute', $data);
   return $rc;
}
]]>                    
                </programlisting>
                </para>
                <para>Расширение Firebird/Interbase не работает с именованными параметрами
                    запроса.</para>
                <para>По умолчанию расширение Firebird/Interbase автоматически стартует транзакцию
                    по умолчанию после подключения. Транзакцию по умолчанию подтверждается при
                    закрытии соединения функцией <function>ibase_close</function>. Её можно
                    подтвердить или откатить раньше, если вызвать методы
                        <function>ibase_commit</function> или <function>ibase_rollback</function>
                    передав в них идентификатор соединения, или не передавая ни чего (если вы
                    используете единственное соединение). </para>

                <para>Если вам необходимо явное управление транзакциями, то необходимо стартовать
                    транзакцию с помощью функции <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/function.ibase-trans.php"
                        >ibase_trans</link>. Если параметры транзакции не указаны, то транзакция
                    будет начата с параметрами <literal>IBASE_WRITE | IBASE_CONCURRENCY |
                        IBASE_WAIT</literal>. Описание констант для задания параметров транзакции
                    можно найти по ссылке <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/ibase.constants.php"
                        >php.net/manual/ru/ibase.constants.php</link>. Транзакцию необходимо
                    завершать с помощью функции <function>ibase_commit</function> или
                        <function>ibase_rollback</function> передавая в эти функции идентификатор
                    транзакции. Если вместо этих функций использовать функции
                        <function>ibase_commit_ret</function> или
                        <function>ibase_rollback_ret</function>, то транзакция будет завершаться как
                        <literal>COMMIT RETAIN</literal> или <literal>ROLLBACK
                    RETAIN</literal>.</para>

                <note>
                    <para>Умолчательные параметры транзакции подходят для большинства случаев. Дело
                        в том что соединение с базой данных, как и все связанные с ним ресурсы
                        существуют максимум до конца работы PHP скрипта. Даже если вы используете
                        постоянные соединения, то все связанные ресурсы будут освобождены после
                        вызова функции <function>ibase_close</function>. Несмотря на сказанное,
                        настоятельно рекомендую завершать все выделенные ресурсы явно, вызывая
                        соответствующие ibase_ функции.</para>
                    <para>Пользоваться функциями <function>ibase_commit_ret</function> и
                            <function>ibase_rollback_ret</function> настоятельно не рекомендую, так
                        как это не имеет смысла. <literal>COMMIT RETAIN</literal> и
                            <literal>ROLLBACK RETAIN</literal> были введены для того, чтобы в
                        настольных приложениях сохранять открытыми курсоры при завершении
                        транзакции.</para>
                </note>

                <para>
                    <programlisting language="php">
<![CDATA[
$sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
// Подготавливаем запрос
$sth = ibase_prepare($dbh, $sql);
$users = [["user1", "user1@gmail.com"], ["user2", "user2@gmail.com"]]; 
$trh = ibase_trans($dbh, IBASE_WRITE | IBASE_CONCURRENCY | IBASE_WAIT); 
try {
  // Выполняем запрос
  foreach ($users as $user)) {
    ibase_execute($sth, $user[0], $user[1]);
    // Если произошла ошибка, бросаем исключение
    $err_msg = ibase_errmsg();
    if ($err_msg)
      throw new \Exception($err_msg);
  }
  ibase_commit($trh);
}
catch(\Exception $e) {
  ibase_rollback($trh);
     echo $e->getMessage();
}
// Освобождаем подготовленный запрос
ibase_free_query($sth);
]]>                        
                    </programlisting>
                </para>
                <important>
                    <para>ibase функции не бросают исключение в случае возникновения ошибки. Часть
                        функций возвращают <literal>false</literal>, если произошла ошибка. Обращаю
                        ваше внимание, что результат сравнивать с <literal>false</literal>
                        необходимо строгим оператором сравнения <function>===</function>.
                        Потенциально ошибка может возникнуть поле вызова любой ibase функции. Текст
                        ошибки можно узнать с помощью функции <function>ibase_errmsg</function>. Код
                        ошибки можно получить с помощью функции
                        <function>ibase_errcode</function>.</para>
                </important>

                <para>Расширение Firebird/Interbase позволяет взаимодействовать с сервером Firebird
                    не только посредством SQL запросов, но и используя Service API (см. функции
                        <function>ibase_service_attach</function>,
                        <function>ibase_service_detach</function>, ibase_server_info,
                        <function>ibase_maintain_db</function>, <function>ibase_db_info</function>,
                        <function>ibase_backup</function>, <function>ibase_restore</function>). Эти
                    функции позволяют получить информацию о сервере Firebird, сделать резервное
                    копирование, восстановление или получить статистику. Эта функциональность
                    требуется в основном для администрирования БД, поэтому мы не будем рассматривать
                    её подробно.</para>

                <para>Расширение Firebird/Interbase так же поддерживает работу с событиями Firebird
                    (см. функции <function>ibase_set_event_handler</function>,
                        <function>ibase_free_event_handler</function>,
                        <function>ibase_wait_event</function>).</para>
            </section>
            <section>
                <title>Обзор расширения PDO (драйвер Firebird)</title>

                <para>Расширение PDO предоставляет обобщённый интерфейс для доступа к различным
                    типам БД. Каждый драйвер базы данных, в котором реализован этот интерфейс, может
                    представить специфичный для базы данных функционал в виде стандартных функций
                    расширения.</para>
                <para>PDO и все основные драйверы внедрены в PHP как загружаемые модули. Чтобы их
                    использовать, требуется их просто включить, отредактировав файл
                        <filename>php.ini</filename> следующим образом:
                    <programlisting language="ini">
extension=php_pdo.dll                    
                </programlisting>
                </para>

                <note>
                    <para>Этот шаг необязателен для версий PHP 5.3 и выше, так как для работы PDO
                        больше не требуются DLL.</para>
                </note>

                <para>Далее нужно выбрать DLL конкретных баз данных и либо загружать их во время
                    выполнения функцией <function>dl()</function>, либо включить их в
                        <filename>php.ini</filename> после <filename>php_pdo.dll</filename>.
                    Например:
                    <programlisting language="ini">
extension=php_pdo.dll
extension=php_pdo_firebird.dll                   
                </programlisting>
                    Эти DLL должны лежать в директории <filename>extension_dir</filename>. </para>
                <para>Драйвер pdo_firebird требует, чтобы у вас была установлена клиентская
                    библиотека <filename>fbclient.dll</filename>/<filename>gds32.dll</filename> (для
                    UNIX подобных систем <filename>fbclient.so</filename>) соответствующей
                    разрядности.</para>
                <para>В Linux это расширение в зависимости от дистрибутива можно установить одной из
                    следующих команд (необходимо уточнить поддерживаемые версии, возможно,
                    необходимо подключить сторонний репозиторий):
                    <screen>
apt-get install php5-firebird

rpm –ihv php5-firebird

yum install php70w-firebird

zypper install php5-firebird                    
                </screen>
                </para>
                <para> PDO использует объектно-ориентированный подход к написанию программ. Какой
                    именно драйвер будет использоваться в PDO, зависит от строки подключения,
                    называемой так же DSN ( Data Source Name ). DSN состоит из префикса, который и
                    определяет тип базы данных, и набора параметров в виде
                        <replaceable>&lt;ключ&gt;</replaceable>=<replaceable>&lt;значение&gt;</replaceable>,
                    разделённых точкой с запятой «;». Допустимый набор параметров зависит от типа
                    базы данных. Для работы с Firebird строка подключения должна начинаться с
                    префикса <emphasis role="italic">firebird:</emphasis> и иметь вид, описанный в
                    документации в разделе <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/ref.pdo-firebird.connection.php"
                        >PDO_FIREBIRD DSN</link>. </para>
                <para>Соединения устанавливаются автоматически при создании объекта PDO от его
                    базового класса. Конструктор класса принимает аргументы для задания источника
                    данных (DSN), а также необязательные имя пользователя и пароль (если есть).
                    Четвёртым аргументом можно передать массив специфичных для драйвера настроек
                    подключения в формате
                        <replaceable>ключ</replaceable>=&gt;<replaceable>значение</replaceable>. <programlisting language="php">
<![CDATA[
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Подключение к БД
  $dbh = new \PDO($dsn, $username, $password, [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION]);
  $sql = 'SELECT login, email FROM users';
  // Выполняем запрос
  $query = $dbh->query($sql);
  // Получаем результат построчно в виде объекта
  while ($row = $query->fetch(\PDO::FETCH_OBJ)) {
    echo $row->email, "\n";
  }
    $query->closeCursor(); // Закрываем курсор
} catch (\PDOException $e) {
  echo $e->getMessage();
}
]]>                    
                </programlisting>
                </para>
                <para>Установив свойство <literal>\PDO::ATTR_ERRMODE</literal> в значение
                        <literal>\PDO::ERRMODE_EXCEPTION</literal>, мы установили режим, при котором
                    любая ошибка, в том числе и ошибка при подключении к БД, будет возбуждать
                    исключение <classname>\PDOException</classname>. Работать в таком режиме гораздо
                    удобнее, чем проверять наличие ошибки после каждого вызова ibase_
                    функций.</para>
                <note>
                    <para> Для того чтобы PDO использовал <link
                            xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="http://php.net/persistent-connections">постоянные
                            соединения</link> необходимо в конструктор PDO в массиве свойств
                        передать <literal>PDO::ATTR_PERSISTENT</literal> =&gt;
                            <literal>true</literal>. </para>
                </note>

                <para>Метод <function>query</function> выполняет SQL запрос и возвращает
                    результирующий набор в виде объекта <classname>\PDOStatement</classname>. В этот
                    метод помимо SQL запросы вы можете передать способ возвращения значений при
                    фетче. Это может быть столбец, экземпляр заданного класса, объект. Различные
                    способы вызова вы можете посмотреть по ссылке <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdo.query.php"
                        >http://php.net/manual/ru/pdo.query.php</link>.</para>
                <para>Если необходимо выполнить SQL запрос, не возвращающий набор данных, то вы
                    можете воспользоваться методом <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdo.exec.php">exec</link>, который
                    возвращает количество задействованных строк. Этот метод не обеспечивает
                    выполнение подготовленных запросов.</para>
                <para>Если в запросе используются параметры, то необходимо пользоваться
                    подготовленными запросами. В этом случае вместо метода query необходимо вызвать
                    метод <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdo.prepare.php">prepare</link>. Этот
                    метод возвращает объект класса <classname>\PDOStatement</classname>, который
                    инкапсулирует в себе методы для работы с подготовленными запросами и их
                    результатами. Для выполнения запроса необходимо вызвать метод <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdostatement.execute.php"
                        >execute</link>, который может принимать в качестве аргумента массив с
                    именованными или неименованными параметрами. Результат выполнения селективного
                    запроса можно получить с помощью методов <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdostatement.fetch.php">fetch</link>,
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdostatement.fetchall.php"
                        >fetchAll</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdostatement.fetchcolumn.php"
                        >fetchColumn</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdostatement.fetchobject.php"
                        >fetchObject</link>. Методы <function>fetch</function> и
                        <function>fetchAll</function> могут возвращать результаты в различном виде:
                    ассоциативный массив, объект или экземпляр определённого класса. Последнее
                    довольно часто используется в MVC паттерне при работе с моделями. <programlisting language="php">
<![CDATA[
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Подключение к БД
  $dbh = new \PDO($dsn, $username, $password, [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION]);
  $sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
  $users = [
    ["user1", "user1@gmail.com"], 
    ["user2", "user2@gmail.com"]
  ]; 

  // Подготавливаем запрос
  $query = $dbh->prepare($sql);
  // Выполняем запрос
  foreach ($users as $user)) {
      $query->execute($user);
  }
} catch (\PDOException $e) {
  echo $e->getMessage();
}
]]>                 
                </programlisting>
                </para>
                <para>Пример использования именованных параметров. <programlisting language="php">
<![CDATA[
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Подключение к БД
  $dbh = new \PDO($dsn, $username, $password, [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION]);
  $sql = 'INSERT INTO users(login, email) VALUES(:login, :email)';
     $users = [
    [":login" => "user1", ":email" => "user1@gmail.com"], 
    [":login" => "user2", ":email" => "user2@gmail.com"]
  ]; 
  // Подготавливаем запрос
  $query = $dbh->prepare($sql);
  // Выполняем запрос
  foreach ($users as $user)) {
      $query->execute($user);
  }
} catch (\PDOException $e) {
  echo $e->getMessage();
}
]]>                 
                </programlisting>
                </para>

                <note>
                    <para>Для поддержки именованных параметров PDO производит предобработку запроса
                        и заменяет параметры вида :paramname на «?», сохраняя при этом массив
                        соответствия между именем параметра и номерами его позиций в запросе. По
                        этой причине оператор <database>EXECUTE BLOCK</database> не будет работать,
                        если внутри него используются переменные маркированные двоеточием. На данный
                        момент нет никакой возможности заставить работать PDO с оператором
                            <database>EXECUTE BLOCK</database> иначе, например, задать
                        альтернативный префикс параметров, как это сделано в некоторых компонентах
                        доступа.</para>
                </note>

                <para>Передать параметры в запрос можно и другим способом, используя так называемое
                    связывание. Метод <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdostatement.bindvalue.php"
                        >bindValue</link> привязывает значение к именованному или неименованному
                    параметру. Метод <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdostatement.bindparam.php"
                        >bindParam</link> привязывает переменную к именованному или неименованному
                    параметру. Последний метод особенно полезен для хранимых процедур, которые
                    возвращают значение через OUT или IN OUT параметр (в Firebird механизм возврата
                    значений из хранимых процедур другой). <programlisting language="php">
<![CDATA[
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Подключение к БД
  $dbh = new \PDO($dsn, $username, $password, [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION]);
  $sql = 'INSERT INTO users(login, email) VALUES(:login, :email)';
  $users = [
    ["user1", "user1@gmail.com"], 
    ["user2", "user2@gmail.com"]
  ]; 

  // Подготавливаем запрос
  $query = $dbh->prepare($sql);
  // Выполняем запрос
  foreach ($users as $user)) {
    $query->bindValue(":login", $user[0]);
    $query->bindValue(":email", $user[1]);
    $query->execute();
  }
} catch (\PDOException $e) {
  echo $e->getMessage();
}
]]>                    
                </programlisting>
                </para>
                <important>
                    <para>Нумерация неименованных параметров в методах
                            <function>bindParam</function> и <function>bindValue</function>
                        начинается с 1.</para>
                </important>
                <para>
                    <programlisting language="php">
<![CDATA[
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Подключение к БД
  $dbh = new \PDO($dsn, $username, $password, [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION]);
  $sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
  $users = [
    ["user1", "user1@gmail.com"], 
    ["user2", "user2@gmail.com"]
  ]; 

  // Подготавливаем запрос
  $query = $dbh->prepare($sql);
  // Выполняем запрос
  foreach ($users as $user)) {
    $query->bindValue(1, $user[0]);
    $query->bindValue(2, $user[1]);
    $query->execute();
  }
} catch (\PDOException $e) {
  echo $e->getMessage();
}
]]>                        
                    </programlisting>
                </para>
                <para>По умолчанию PDO автоматически подтверждает транзакцию после выполнения
                    каждого SQL запроса, если вам необходимо явное управление транзакциями, то
                    необходимо стартовать транзакцию с помощью метода <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdo.begintransaction.php"
                            ><function>\PDO::beginTransaction</function></link>. По умолчанию
                    транзакция стартует с параметрами <literal>CONCURRENCY | WAIT |
                        READ_WRITE</literal>. Завершить транзакцию можно методом <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdo.commit.php"
                            ><function>\PDO::commit</function></link> или <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://php.net/manual/ru/pdo.commit.php"
                            ><function>\PDO::rollback</function></link>.</para>
                <para>
                    <programlisting language="php">
<![CDATA[
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Подключение к БД
  $dbh = new \PDO($dsn, $username, $password, 
                  [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION]);
  // Стартуем транзакцию для обеспечения согласованности между запросами
  $dbh->beginTransaction();
  // Получаем пользователей из одной таблицы
  $users_stmt = $dbh->prepare('SELECT login, email FROM old_users');
  $users_stmt->execute();  
  $users = $users_stmt->fetchAll(\PDO::FETCH_OBJECT);
  $users_stmt->closeCursor();
   
  // И переносим их в другую
  $sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
  // Подготавливаем запрос
  $query = $dbh->prepare($sql);
  // Выполняем запрос
  foreach ($users as $user)) {
    $query->bindValue(1, $user->LOGIN);
    $query->bindValue(2, $user->EMAIL]);
    $query->execute();
  }
  // Подтверждаем транзакцию
  $dbh->commit();
} catch (\PDOException $e) {
  // Если соединение произошло и транзакция стартовала, откатываем её
  if ($dbh &&  $dbh->inTransaction())
    $dbh->rollback();
  echo $e->getMessage();
}
]]>                        
                    </programlisting>
                </para>
                <para>К сожалению метод beginTransaction не предоставляет возможности изменить
                    параметры транзакции, однако вы можете сделать хитрый трюк, задав параметры
                    транзакции оператором SET TRANSACTION. <programlisting language="php">
<![CDATA[
$dbh = new \PDO($dsn, $username, $password);
$dbh->setAttribute(\PDO::ATTR_AUTOCOMMIT, false);
$dbh->exec("SET TRANSACTION READ ONLY ISOLATION LEVEL READ COMMITTED NO WAIT");
// Выполняем действия в транзакции
// …
$dbh->exec("COMMIT");
$dbh->setAttribute(\PDO::ATTR_AUTOCOMMIT, true);
]]>                    
                </programlisting>
                </para>
                <para>Ниже представлена сводная таблица возможностей различных драйверов для работы
                    с Firebird. <table frame="all">
                        <title>Сравнение расширений для работы с Firebird</title>
                        <tgroup cols="3">
                            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                            <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                            <thead>
                                <row>
                                    <entry>Возможность</entry>
                                    <entry>Расширение Firebird/Interbase</entry>
                                    <entry>PDO</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>Парадигма программирования</entry>
                                    <entry>Функциональная</entry>
                                    <entry>Объектно-ориентированная</entry>
                                </row>
                                <row>
                                    <entry>Поддерживаемые БД</entry>
                                    <entry>Firebird, Interbase, Yaffil и другие клоны
                                        Interbase.</entry>
                                    <entry>Любая БД, для которой существует PDO драйвер, в том числе
                                        Firebird.</entry>
                                </row>
                                <row>
                                    <entry>Работа с параметрами запросов</entry>
                                    <entry>Только неименованные параметры, работать не очень удобно,
                                        поскольку используется функция с переменным числом
                                        аргументов.</entry>
                                    <entry>Только неименованные параметры, работать не очень удобно,
                                        поскольку используется функция с переменным числом
                                        аргументов.</entry>
                                </row>
                                <row>
                                    <entry>Обработка ошибок</entry>
                                    <entry>Проверка результата функций
                                            <function>ibase_errmsg</function>,
                                            <function>ibase_errcode</function>. Ошибка может
                                        произойти после вызова любой ibase функции при этом
                                        исключение не будет возбуждено.</entry>
                                    <entry>Есть возможность установить режим, при котором любая
                                        ошибка приведёт к возбуждению исключения.</entry>
                                </row>
                                <row>
                                    <entry>Управление транзакциями</entry>
                                    <entry>Даёт возможность задать параметры транзакции.</entry>
                                    <entry>Не даёт возможность задать параметры транзакции. Есть
                                        обходной путь через выполнение оператора SET
                                        TRANSACTION.</entry>
                                </row>
                                <row>
                                    <entry>Специфичные возможности Interbase/Firebird</entry>
                                    <entry>Есть возможность работать с расширениями Service API
                                        (backup, restore, получение статистики и т.д.), а также с
                                        событиями базы данных.</entry>
                                    <entry>Не позволяет использовать специфичные возможности, с
                                        которыми невозможно работать, используя SQL.</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table></para>
                <para>Из приведённой таблицы видно, что большинству фреймворков гораздо удобнее
                    пользоваться PDO.</para>
            </section>
        </section>
        <section>
            <title>Выбор фреймворка для построения WEB приложения </title>

            <para>Небольшие web сайты можно писать, не используя паттерн MVC. Однако чем больше
                становится ваш сайт, тем сложнее его поддерживать, особенно если над ним работает не
                один человек. Поэтому при разработке нашего web приложения сразу договоримся об
                использовании этого паттерна.</para>

            <para>Итак, мы решили использовать паттерн MVC. Однако написание приложение с
                использованием этого паттерна не такая простая задача как кажется, особенно если мы
                не пользуемся сторонними библиотеками. Если всё писать самому, то необходимо решить
                множество задач: автозагрузка файлов <filename>.php</filename>, включающих
                определение классов, маршрутизация и др. Для решения этих задач было создано большое
                количество фреймворков, например Yii, Laravel, Symphony, Kohana и многие другие.
                Лично мне нравится Laravel, поэтому далее я буду описывать создание приложения с
                использованием этого фреймворка.</para>
        </section>
        <section>
            <title>Установка Laravel и создание проекта </title>

            <para>Прежде чем устанавливать Laravel вам необходимо убедится, что ваше системное
                окружение соответствует требованиям. <itemizedlist>
                    <listitem>
                        <para>PHP &gt;= 5.5.9</para>
                    </listitem>
                    <listitem>
                        <para>PDO расширение для PHP (для версии 5.1+)</para>
                    </listitem>
                    <listitem>
                        <para>MCrypt расширение для PHP (для версии 5.0)</para>
                    </listitem>
                    <listitem>
                        <para>OpenSSL (расширение для PHP)</para>
                    </listitem>
                    <listitem>
                        <para>Mbstring (расширение для PHP)</para>
                    </listitem>
                    <listitem>
                        <para>Tokenizer (расширение для PHP)</para>
                    </listitem>
                </itemizedlist></para>
            <para>Laravel использует <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://getcomposer.org">Composer</link> для управления
                зависимостями. Поэтому сначала установите Composer, а затем Laravel.</para>
            <para>Самый простой способ установить composer под Windows — это скачать и запустить
                инсталлятор <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://getcomposer.org/Composer-Setup.exe"
                    >Composer-Setup.exe</link>. Инсталлятор установит Composer и настроит PATH, так
                что вы можете вызвать Composer из любой директории в командной строке.</para>
            <para>Если необходимо установить Composer вручную, то необходимо запустить скрипт
                <programlisting>
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php -r "if (hash_file('SHA384', 'composer-setup.php') === 
'aa96f26c2b67226a324c27919f1eb05f21c248b987e6195cad9690d5c1ff713d53020a02
ac8c217dbf90a7eacc9d141d') { echo 'Installer verified'; } else { echo 
'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
php composer-setup.php
php -r "unlink('composer-setup.php');"                    
                </programlisting>
            </para>

            <para>Этот скрипт осуществляет следующие действия:<itemizedlist>
                    <listitem>
                        <para>Скачивает инсталлятор в текущую директорию</para>
                    </listitem>
                    <listitem>
                        <para>Проверяет инсталлятор с помощью SHA-384</para>
                    </listitem>
                    <listitem>
                        <para>Запускает скрипт инсталляции</para>
                    </listitem>
                    <listitem>
                        <para>Удаляет скрипт инсталляции</para>
                    </listitem>
                </itemizedlist></para>
            <para>После запуска этого скрипта у вас появится файл <filename>composer.phar</filename>
                (phar – это архив) — по сути это PHP скрипт, который может принимать несколько
                команд (install, update, ...) и умеет скачивать и распаковывать библиотеки. Если вы
                работаете под windows, то вы можете облегчить себе задачу, создав файл
                    <filename>composer.bat</filename> и поместив его в PATH. Для этого необходимо
                выполнить команду
                <programlisting>
echo @php "%~dp0composer.phar" %*>composer.bat                    
                </programlisting>Подробнее
                об установке composer можно ознакомится по адресу <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://getcomposer.org/doc/00-intro.md"
                    >https://getcomposer.org/doc/00-intro.md</link>.</para>
            <para>Теперь устанавливаем сам Laravel
                <programlisting>
composer global require "laravel/installer"                    
                </programlisting>
            </para>
            <para>Если установка прошла успешно, то приступаем к созданию каркаса проекта.
                <programlisting>
laravel new fbexample
                    </programlisting>
            </para>
            <para>Ждём завершения, после чего у нас будет создан каркас проекта. Описание структуры
                каталогов можно ознакомится по адресу <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://laravel.su/docs/5.2/structure"
                    >http://laravel.su/docs/5.2/structure</link> по Laravel. Нас будут интересовать
                следующие каталоги: <itemizedlist>
                    <listitem>
                        <para><filename>app</filename> – основной каталог нашего приложения. В корне
                            каталога будут размещены модели. В подкаталоге Http находится все, что
                            касается работы с браузером. В подкаталоге
                                <filename>Http/Controllers</filename> — наши контроллеры.</para>
                    </listitem>
                    <listitem>
                        <para><filename>config</filename> – каталог файлов конфигурации. Подробней о
                            конфигурировании будет написано ниже.</para>
                    </listitem>
                    <listitem>
                        <para><filename>public</filename> – корневой каталог web приложения (
                            DocumentRoot ). Содержит статические файлы - css, js, изображения и
                            т.п.</para>
                    </listitem>
                    <listitem>
                        <para><filename>resources</filename> - здесь находятся шаблоны (Views),
                            файлы локализации и, если таковые имеются, рабочие файлы LESS, SASS и
                            js-приложения на фреймворках типа ReactJS, AngularJS или Ember, которые
                            потом собираются внешним инструментом в папку
                                <filename>public</filename>.</para>
                        <para>В корне папки нашего приложения есть файл
                                <filename>composer.json</filename>, который описывает, какие пакеты,
                            потребуются нашему приложению помимо тех, что уже есть в Laravel. Нам
                            потребуется два таких пакета: <link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="https://github.com/zofe/rapyd-laravel"
                                >zofe/rapyd-laravel</link> - для быстрого построения интерфейса с
                            сетками (grids) и диалогами редактирования, и <link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="https://github.com/sim1984/laravel-firebird"
                                >sim1984/laravel-firebird</link> - расширение для работы с СУБД
                            Firebird. Пакет <package>sim1984/laravel-firebird</package> является
                            форком пакета «<link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="https://github.com/jacquestvanzuydam/laravel-firebird"
                                >jacquestvanzuydam/laravel-firebird</link>» с расширенными
                            возможностями поэтому его установка несколько отличается. Позже
                            планируется перенос некоторых возможностей моего пакета в официальный.
                            Не забудьте установить параметр minimum-stability равный dev, так как
                            пакет не является стабильным, а так же добавить ссылки на
                            репозиторий.</para>
                        <para>
                            <programlisting language="javascript">
   "repositories": [
        {
            "type": "package",
            "package": {
                "version": "dev-master",
                "name": "sim1984/laravel-firebird",
                "source": {
                    "url": "https://github.com/sim1984/laravel-firebird",
                    "type": "git",
                    "reference": "master"
                },
                "autoload": {
                    "classmap": [""]
                }
            }
        }
    ],                                 
                                </programlisting>
                        </para>
                        <para>В секции require добавьте требуемые пакеты следующим образом:
                            <programlisting language="javascript">
        "zofe/rapyd": "2.2.*",
        "sim1984/laravel-firebird": "dev-master"                                 
                                </programlisting>
                        </para>
                    </listitem>
                </itemizedlist></para>
            <para>Теперь можно запустить обновление пакетов командой (запускать надо в корне веб
                приложения)
                <programlisting>
composer update                    
                </programlisting>
            </para>
            <para>После выполнения этой команды новые пакеты будут установлены в ваше приложение.
                Теперь можно приступить к настройке. Для начала выполним команду
                <programlisting>
php artisan vendor:publish                    
                </programlisting>
                которая создаст дополнительные файлы конфигурации для пакета
                    <package>zofe/rapyd</package>. </para>
            <para>В файле <filename>config/app.php</filename> добавим два новых провайдера. Для
                этого добавим две новых записи в ключ providers
                <programlisting language="php">
        Zofe\Rapyd\RapydServiceProvider::class,
        Firebird\FirebirdServiceProvider::class,                            
                                </programlisting>
            </para>
            <para>Теперь перейдём к файлу <filename>config/databases.conf</filename>, который
                содержит настройки подключения к базе данных. Добавим в ключ connections следующие
                строки <programlisting language="php">
<![CDATA[                          
       'firebird' => [
            'driver' => 'firebird',
            'host' => env('DB_HOST', 'localhost'),           
            'port' => env('DB_PORT', '3050'),
            'database' => env('DB_DATABASE', 'examples'),
            'username' => env('DB_USERNAME', 'SYSDBA'),
            'password' => env('DB_PASSWORD', 'masterkey'),
            'charset' => env('DB_CHARSET', 'UTF8'),
            'engine_version' => '3.0.0',
        ],  
]]>         
                </programlisting>
            </para>
            <para>Поскольку мы будем использовать наше подключение в качестве подключения по
                умолчанию, установим следующее <programlisting language="php">
<![CDATA[                        
'default' => env('DB_CONNECTION', 'firebird'),  
]]>   
                </programlisting>
            </para>
            <para>Обратите внимание на функцию env, которая используется для чтения переменных
                окружения приложения из специального файла <filename>.env</filename>, находящегося в
                корне проекта. Исправим в этом файле <filename>.env</filename> следующие строки
                <programlisting>
DB_CONNECTION=firebird
DB_HOST=localhost
DB_PORT=3050
DB_DATABASE=examples
DB_USERNAME=SYSDBA
DB_PASSWORD=masterkey                    
                </programlisting>
            </para>
            <para>В файле конфигурации <filename>config/rapyd.php</filename> изменим отображение дат
                так, чтобы они были в формате принятом в России: <programlisting language="php">
<![CDATA[                        
'fields' => [
        'attributes' => ['class' => 'form-control'],
        'date' => [
            'format' => 'd.m.Y',
        ],
        'datetime' => [
            'format' => 'd.m.Y H:i:s',
            'store_as' => 'Y-m-d H:i:s',
        ],
    ],  
]]>    
                </programlisting>
            </para>
            <para>Первоначальная настройка закончена, теперь мы можем приступить непосредственно к
                написанию логики web приложения.</para>
        </section>
        <section>
            <title>Создание моделей</title>

            <para>Фреймворк Laravel поддерживает ORM Eloquent. ORM Eloquent - красивая и простая
                реализация паттерна ActiveRecord для работы с базой данных. Каждая таблица имеет
                соответствующий класс-модель, который используется для работы с этой таблицей.
                Модели позволяют читать данные из таблиц и записывать данные в таблицу.</para>

            <para>Создадим модель заказчиков, для упрощения этого процесса в Laravel есть artisan
                команда.
                <programlisting>
php artisan make:model Customer                
                </programlisting>
            </para>
            <para>Этой командой мы создаём шаблон модели. Теперь изменим нашу модель так, чтобы она
                выглядела следующим образом: <programlisting language="php">
<![CDATA[
namespace App;

use Firebird\Eloquent\Model;

class Customer extends Model
{
    /**
     * Таблица, связанная с моделью
     *
     * @var string
     */
    protected $table = 'CUSTOMER';
    
    /**
     * Первичный ключ модели
     *
     * @var string
     */
    protected $primaryKey = 'CUSTOMER_ID';    
    
    /**
     * Наша модель не имеет временной метки
     *
     * @var bool
     */
    public $timestamps = false;  
    
    /**
     * Имя последовательности для генерации первичного ключа
     *
     * @var string 
     */
    protected $sequence = 'GEN_CUSTOMER_ID';
}
]]>                
                </programlisting>
            </para>
            <important>
                <para>Мы используем модифицированную модель
                        <classname>Firebird\Eloquent\Model</classname> из пакета
                        <package>sim1984/laravel-firebird</package> в качестве базовой. Она
                    позволяет воспользоваться последовательностью, указанной в свойстве
                        <property>$sequence</property>, для генерирования значения идентификатора
                    первичного ключа.</para>
            </important>
            <para>По аналогии создадим модель товаров – <classname>Product</classname>. <programlisting language="php">
<![CDATA[
namespace App;

use Firebird\Eloquent\Model;

class Product extends Model
{
    /**
     * Таблица, связанная с моделью
     *
     * @var string
     */
    protected $table = 'PRODUCT';
    
    /**
     * Первичный ключ модели
     *
     * @var string
     */
    protected $primaryKey = 'PRODUCT_ID';    
    
    /**
     * Наша модель не имеет временной метки
     *
     * @var bool
     */
    public $timestamps = false;  
    
    /**
     * Имя последовательности для генерации первичного ключа
     *
     * @var string 
     */
    protected $sequence = 'GEN_PRODUCT_ID';     
}
]]>                    
                </programlisting>
            </para>
            <para>Теперь создадим модель для шапки счёт-фактуры. <programlisting language="php">
<![CDATA[
namespace App;

use Firebird\Eloquent\Model;

class Invoice extends Model {

    /**
     * Таблица, связанная с моделью
     *
     * @var string
     */
    protected $table = 'INVOICE';

    /**
     * Первичный ключ модели
     *
     * @var string
     */
    protected $primaryKey = 'INVOICE_ID';

    /**
     * Наша модель не имеет временной метки
     *
     * @var bool
     */
    public $timestamps = false;

    /**
     * Имя последовательности для генерации первичного ключа
     *
     * @var string 
     */
    protected $sequence = 'GEN_INVOICE_ID';

    /**
     * Заказчик
     *
     * @return \App\Customer
     */
    public function customer() {
        return $this->belongsTo('App\Customer', 'CUSTOMER_ID');
    }

    /**
     * Позиции счёт фактуры
	 
     * @return \App\InvoiceLine[]
     */
    public function lines() {
        return $this->hasMany('App\InvoiceLine', 'INVOICE_ID');
    }
    
    /**
     * Оплата 
     */
    public function pay() {
        $connection = $this->getConnection();

        $attributes = $this->attributes;

        $connection->executeProcedure('SP_PAY_FOR_INOVICE', 
            [$attributes['INVOICE_ID']]);
    }
 
}
]]>                    
                </programlisting>
            </para>
            <para>В этой модели можно заметить несколько дополнительных функций. Метод
                    <function>customer</function> возвращает заказчика связанного со счёт фактурой
                через поле <property>CUSTOMER_ID</property>. Для осуществления такой связи
                используется метод <function>belongsTo</function>, в который передаются имя класса
                модели и имя поле связи. Метод <function>lines</function> возвращают позиции
                счёт-фактуры, которые представлены коллекцией моделей
                    <classname>InvoiceLine</classname> (будет описана далее). Для осуществления
                связи один ко многим в методе <function>lines</function> используется метод
                    <function>hasMany</function>, в который передаётся имя класса модели и поле
                связи. Подробнее о задании отношений между сущностями вы можете почитать в разделе
                    <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://laravel.com/docs/5.2/eloquent-relationships"
                    >Отношения</link> документации Laravel.</para>
            <para>Метод <function>pay</function> осуществляет оплату счёт фактуры. Для этого
                вызывается хранимая процедура <function>SP_PAY_FOR_INVOICE</function>. В неё
                передаётся идентификатор счёт фактуры. Значение любого поля (атрибута модели) можно
                получить из свойства <property>attributes</property>. Вызов хранимой процедуры
                осуществляется с помощью метода <function>executeProcedure</function>. Этот метод
                доступен только при использовании расширения
                    <package>sim1984/laravel-firebird</package>.</para>
            <para>Теперь создадим модель для позиций счёт фактуры. <programlisting language="php">
<![CDATA[
namespace App;

use Firebird\Eloquent\Model;
use Illuminate\Database\Eloquent\Builder;

class InvoiceLine extends Model {

    /**
     * Таблица, связанная с моделью
     *
     * @var string
     */
    protected $table = 'INVOICE_LINE';

    /**
     * Первичный ключ модели
     *
     * @var string
     */
    protected $primaryKey = 'INVOICE_LINE_ID';

    /**
     * Наша модель не имеет временной метки
     *
     * @var bool
     */
    public $timestamps = false;

    /**
     * Имя последовательности для генерации первичного ключа
     *
     * @var string 
     */
    protected $sequence = 'GEN_INVOICE_LINE_ID';
	
    /**
      * Массив имён вычисляемых полей
      *
      * @var array
      */
    protected $appends = ['SUM_PRICE'];

    /**
     * Товар
     *
     * @return \App\Product
     */	
    public function product() {
        return $this->belongsTo('App\Product', 'PRODUCT_ID');
    }

    /**
     * Сумма по позиции
     *
     * @return double
     */		
    public function getSumPriceAttribute() {
        return $this->SALE_PRICE * $this->QUANTITY;
    }

    /**
     * Добавление объекта модели в БД
     * Переопределяем этот метод, т.к. в данном случаем мы работаем с помощью ХП 
     * 
     * @param  \Illuminate\Database\Eloquent\Builder  $query
     * @param  array  $options
     * @return bool
     */
    protected function performInsert(Builder $query, array $options = []) {

        if ($this->fireModelEvent('creating') === false) {
            return false;
        }

        $connection = $this->getConnection();

        $attributes = $this->attributes;
        
        $connection->executeProcedure('SP_ADD_INVOICE_LINE', [
            $attributes['INVOICE_ID'],
            $attributes['PRODUCT_ID'],
            $attributes['QUANTITY']
        ]);

        // We will go ahead and set the exists property to true, 
        // so that it is set when the created event is fired, just in case 
        // the developer tries to update it during the event. This will allow 
        // them to do so and run an update here.
        $this->exists = true;

        $this->wasRecentlyCreated = true;

        $this->fireModelEvent('created', false);

        return true;
    }

    /**
     * Сохранение изменений текущего экземпляра модели в БД
     * Переопределяем этот метод, т.к. в данном случаем мы работаем с помощью ХП 
     *
     * @param  \Illuminate\Database\Eloquent\Builder  $query
     * @param  array  $options
     * @return bool
     */
    protected function performUpdate(Builder $query, array $options = []) {
        $dirty = $this->getDirty();

        if (count($dirty) > 0) {
            // If the updating event returns false, we will cancel 
            // the update operation so developers can hook Validation systems 
            // into their models and cancel this operation if the model does 
            // not pass validation. Otherwise, we update.
            if ($this->fireModelEvent('updating') === false) {
                return false;
            }

            $connection = $this->getConnection();

            $attributes = $this->attributes;
            
            $connection->executeProcedure('SP_EDIT_INVOICE_LINE', [
                $attributes['INVOICE_LINE_ID'],
                $attributes['QUANTITY']
            ]);            


            $this->fireModelEvent('updated', false);
        }
    }

    /**
     * Удаление текущего экземпляра модели в БД
     * Переопределяем этот метод, т.к. в данном случаем мы работаем с помощью ХП 
     *
     * @return void
     */
    protected function performDeleteOnModel() {

        $connection = $this->getConnection();

        $attributes = $this->attributes;
        
        $connection->executeProcedure('SP_DELETE_INVOICE_LINE', 
            [$attributes['INVOICE_LINE_ID']]);          

    }
}
]]>                    
                </programlisting>
            </para>
            <para>В этой модели есть метод <function>product</function>, которая возвращает продукт
                (модель <classname>App/Product</classname>), указанный в позиции счёт фактуры. Связь
                осуществляется по полю <property>PRODUCT_ID</property> с помощью метода
                    <function>belongsTo</function>.</para>
            <para>Вычисляемое поле SumPrice вычисляется с помощью функции
                    <function>getSumPriceAttribute</function>. Для того чтобы это вычисляемое поле
                было доступно в модели, его имя должно быть указано в массиве имён вычисляемых полей
                    <property>$appends</property>.</para>
            <para>В этой модели мы переопределили операции insert, update и delete так, чтобы они
                выполнялись, используя хранимые процедуры. Эти хранимые процедуры помимо собственно
                операций вставки, редактирования и удаления пересчитывают сумму в шапке накладной.
                Этого можно было бы и не делать, но тогда пришлось бы выполнять в одной транзакции
                модификацию нескольких моделей. Как это сделать будет показано далее.</para>
            <para>Теперь немного поговорим о том, как работать с моделями в Laravel для выборки,
                вставки, редактирования и удаления данных. Laravel оперирует данными с помощью
                конструктора запросов. Полное описание синтаксиса и возможностей этого конструктора
                вы можете найти по ссылке <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://laravel.com/docs/5.2/queries"
                    >https://laravel.com/docs/5.2/queries</link>. Например, для получения всех строк
                поставщиков вы можете выполнить следующий запрос <programlisting language="php">
<![CDATA[                    
$customers = DB::table('CUSTOMER')->get();   
]]>
                </programlisting>
            </para>
            <para>Этот конструктор запросов является довольно мощным средством для построения и
                выполнения SQL запросов. Вы можете выполнять также фильтрация, сортировку и
                соединения таблиц, например <programlisting language="php">
<![CDATA[                    
DB::table('users')
        ->join('contacts', function ($join) {
            $join->on('users.id', '=', 'contacts.user_id')->orOn(...);
        })
        ->get()   
]]>                    
                </programlisting>
            </para>
            <para>Однако гораздо удобнее работать с использованием моделей. Описание моделей
                Eloquent ORM и синтаксиса запроса к ним можно найти по ссылке <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://laravel.com/docs/5.2/eloquent"
                    >https://laravel.com/docs/5.2/eloquent</link>. Так для получения всех элементов
                коллекции поставщиков необходимо выполнить следующий запрос <programlisting language="php">
<![CDATA[                    
$customers = Customer::all();  
]]>                    
                </programlisting>
            </para>
            <para>Следующий запрос вернёт первые 20 поставщиков отсортированных по алфавиту. <programlisting language="php">
<![CDATA[                    
$customers = App\Customer::select()
               ->orderBy('name')
               ->take(20)
               ->get();
]]>                    
                </programlisting>
            </para>
            <para>Для сложных моделей связанные отношения или коллекции отношений могут быть
                получены через динамические атрибуты. Например, следующий запрос вернёт позиции
                счёт-фактуры с идентификатором 1. <programlisting language="php">
<![CDATA[                    
$lines = Invoice::find(1)->lines; 
]]>                    
                </programlisting>
            </para>
            <para>Добавление записей осуществляется через создание экземпляра модели, инициализации
                его свойств и сохранение модели с помощью метода save. <programlisting language="php">
<![CDATA[                    
$flight = new Flight;
$flight->name = $request->name;
$flight->save();
]]>                    
                </programlisting>
            </para>
            <para>Для изменения запись её необходимо найти, изменить необходимые атрибуты и
                сохранить методом save. <programlisting language="php">
<![CDATA[                    
$flight = App\Flight::find(1);
$flight->name = 'New Flight Name';
$flight->save();
]]>                    
                </programlisting>
            </para>
            <para>Для удаления записи её необходимо найти и вызвать метод delete. <programlisting language="php">
<![CDATA[                    
$flight = App\Flight::find(1);
$flight->delete();
]]>                    
                </programlisting>
            </para>
            <para>Удалить запись по ключу можно и гораздо быстрее с помощью метода destroy. В этом
                случае можно удалить модель не получая её экземпляр. <programlisting language="php">
<![CDATA[                    
App\Flight::destroy(1);
]]>                    
                </programlisting>
            </para>
            <para>Существуют и другие способы удаления записей, например «мягкое» удаление. Подробно
                о способах удаления вы можете прочитать по ссылке <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://laravel.com/docs/5.2/eloquent#deleting-models"
                    >https://laravel.com/docs/5.2/eloquent#deleting-models</link>.</para>
            <para>Теперь поговорим немного о транзакциях. Что это такое я рассказывать не буду, а
                лишь покажу, как их можно использовать совместно с Eloquent ORM. <programlisting language="php">
<![CDATA[                    
DB::transaction(function () {
  // Создаём новую позицию в счёт фактуре
  $line = new App\InvoiceLine();
  $line->CUSTOMER_ID = 45;
  $line->PRODUCT_ID = 342;
  $line->QUANTITY = 10;
  $line->COST = 12.45;
  $line->save();	

  // добавляем сумму позиции по строке к сумме накладной 
  $invoice = App\Invoice::find($line->CUSTOMER_ID);
  $invoice->INVOICE_SUM += $line->SUM_PRICE;
  $invoice->save();  
});
]]>                    
                </programlisting> Всё что находится в функции обратного
                вызова, которая является аргументом метода transaction, выполняется в рамках одной
                транзакции. </para>
        </section>
        <section>
            <title>Создание контроллеров и настройка маршрутизации</title>

            <para>Фреймворк Laravel имеет мощную подсистему маршрутизации. Вы можете отображать ваши
                маршруты, как на простые функции обратного вызова, так и на методы контроллеров.
                Простейшие примеры маршрутов выглядят вот так
                <programlisting language="php">
Route::get('/', function () {
  return 'Hello World';
});

Route::post('foo/bar', function () {
  return 'Hello World';
});                    
                </programlisting>
            </para>
            <para>В первом случае мы регистрируем обработчик GET запроса для корня сайта, во втором
                – для POST запроса с маршрутом <filename>/foo/bar</filename>.</para>
            <para>Вы можете зарегистрировать маршрут сразу на несколько типов HTTP запросов,
                например
                <programlisting language="php">
Route::match(['get', 'post'], 'foo/bar', function () {
  return 'Hello World';
});                 
                </programlisting>
            </para>
            <para>Из маршрута можно извлекать часть адреса и использовать его в качестве параметров
                функции-обработчика
                <programlisting language="php">
Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {
  //
});             
                </programlisting>
            </para>
            <para>Параметры маршрута всегда заключаются в фигурные скобки.</para>
            <para> Подробнее о возможности настройки маршрутизации вы можете посмотреть в
                документации глава <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://laravel.com/docs/5.2/routing">Маршрутизация</link>. Маршруты
                настраиваются в файле <filename>app/Http/routes.php</filename> в Laravel 5.2 и
                    <filename>routes/wep.php</filename> в Laravel 5.3.</para>
            <para>Вместо того чтобы описывать обработку всех запросов в едином файле маршрутизации,
                мы можем организовать её используя классы контроллеров, которые позволяют
                группировать связанные обработчики запросов в отдельные классы. Контроллеры хранятся
                в папке <filename>app/Http/Controllers</filename>.</para>
            <para>Все Laravel контроллеры должны расширять базовый класс контроллера
                    <classname>App\Http\Controllers\Controller</classname>, присутствующий в Laravel
                по умолчанию. Подробнее о написании контроллеров вы можете почитать по ссылке <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://laravel.com/docs/5.2/controllers"
                    >https://laravel.com/docs/5.2/controllers</link>.</para>
            <para>Напишем наш первый контроллер, который будет отвечать за вывод списка заказчиков и
                его редактирование. <programlisting language="php">
<![CDATA[
<?php

/*
 * Контроллер заказчиков
 */

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Customer;


class CustomerController extends Controller 
{

    /**
     * Отображает список заказчиков
     *
     * @return Response
     */
    public function showCustomers() 
    {
        // запрашиваем из модели первые 20 заказчиков 
	 // отсортированных по алфавиту 
        $customers = Customer::select()
                   ->orderBy('NAME')
                   ->take(20)
                   ->get();
	  var_dump($customers);
    }

}
]]>                    
                </programlisting>
            </para>
            <para>Теперь необходимо связать методы контроллера с маршрутом. Для этого в
                    <filename>routes.php</filename> (<filename>web.php</filename>) необходимо внести
                строку
                <programlisting language="php">
Route::get('/customers', 'CustomerController@showCustomers');                    
                </programlisting>
                Здесь имя контроллера отделено от имени метода символом @. </para>
            <para>Для быстрого построения интерфейса с сетками и диалогами редактирования будем
                использовать пакет <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://github.com/zofe/rapyd-laravel">zofe/rapyd</link>. Мы его уже
                подключили ранее. Классы пакета <package>zofe/rapyd</package> берут на себя
                построение типичных запросов к моделям Eloquent ORM. Изменим контроллер заказчиков
                так, чтобы он выводил данные в сетку (grid), позволял производить их фильтрацию, а
                также добавлять, редактировать и удалять записи через диалоги редактирования.</para>
            <para>
                <programlisting language="php">
<![CDATA[
<?php

/*
 * Контроллер заказчиков
 */

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Customer;


class CustomerController extends Controller {

    /**
     * Отображает список заказчиков
     *
     * @return Response
     */
    public function showCustomers() {
        // Подключаем виджет для поиска
        $filter = \DataFilter::source(new Customer);
        // Поиск будет по наименованию поставщика
        $filter->add('NAME', 'Наименование', 'text');
        // Задаём подпись кнопке поиска
        $filter->submit('Поиск');
        // Добавляем кнопку сброса фильтра и задаём её подпись
        $filter->reset('Сброс');

        // Создам сетку для отображения отфильтрованных данных
        $grid = \DataGrid::source($filter);

        // выводимые столбцы 
        // Поле, подпись, сортируемый
        $grid->add('NAME', 'Наименование', true);
        $grid->add('ADDRESS', 'Адрес');
        $grid->add('ZIPCODE', 'Индекс');
        $grid->add('PHONE', 'Телефон');

        // Добавляем кнопки для просмотра, редактирования и удаления записи
        $grid->edit('/customer/edit', 'Редактирование', 'show|modify|delete'); 
        // Добавляем кнопку добавления заказчика
        $grid->link('/customer/edit', "Добавление заказчика", "TR");
        // задаём сортировку
        $grid->orderBy('NAME', 'asc'); 
        // задаём количество записей на страницу
        $grid->paginate(10); 
        // отображаем шаблон customer и передаём в него фильтр и грид
        return view('customer', compact('filter', 'grid'));
    }

    /**
     * Добавление, редактирование и удаление заказчика
     * 
     * @return Response
     */
    public function editCustomer() {
        if (\Input::get('do_delete') == 1)
            return "not the first";
        // создаём редактор
        $edit = \DataEdit::source(new Customer());
        // задаём подпись диалога в зависимости от типа операции
        switch ($edit->status) {
            case 'create':
                $edit->label('Добавление заказчика');
                break;
            case 'modify':
                $edit->label('Редактирование заказчика');
                break;
            case 'do_delete':
                $edit->label('Удаление заказчика');
                break;
            case 'show':
                $edit->label('Карточка заказчика');
                // добавляем ссылку для возврата назад на список заказчиков
                $edit->link('customers', 'Назад', 'TR');
                break;
        }
        // задаём что после операций добавления, редактирования и удаления 
        // возвращаемся к списку заказчиков 
        $edit->back('insert|update|do_delete', 'customers');
        // Добавляем редакторы определённого типа, задаём им подпись 
        // и связываем их с атрибутами модели
        $edit->add('NAME', 'Наименование', 'text')->rule('required|max:60');
        $edit->add('ADDRESS', 'Адрес', 'textarea')
             ->attributes(['rows' => 3])
             ->rule('max:250');
        $edit->add('ZIPCODE', 'Индекс', 'text')->rule('max:10');
        $edit->add('PHONE', 'Телефон', 'text')->rule('max:14');
        // отображаем шаблон customer_edit и передаём в него редактор
        return $edit->view('customer_edit', compact('edit'));
    }
}
]]>                        
                    </programlisting>
            </para>
            <para>Laravel по умолчанию использует шаблонизатор blade. Метод
                    <function>view</function> находит необходимый шаблон в директории
                    <filename>resources/views</filename>, делает необходимые замены в нём и
                возвращает текст HTML страницы. Кроме того, она передаёт в него переменные, которые
                становятся доступными в шаблоне. Описание синтаксиса шаблонов blade вы можете найти
                по адресу <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://laravel.com/docs/5.2/blade"
                    >https://laravel.com/docs/5.2/blade</link>.</para>
            <para>Шаблон для отображения заказчиков выглядит следующим образом: <programlisting language="javascript">
<![CDATA[                    
@extends('example')

@section('title','Заказчики')

@section('body')

    <h1>Заказчики</h1>
    <p>
        {!! $filter !!}
        {!! $grid !!}
    </p>
@stop       
]]>
                </programlisting>
            </para>
            <para>Данный шаблон унаследован от шаблона example и переопределяет его секцию body.
                Переменные $filter и $grid содержат HTML код для осуществления фильтрации и
                отображения данных в сетке. Шаблон example является общим для всех страниц. <programlisting language="javascript">
<![CDATA[                    
@extends('master')
@section('title', 'Пример работы с Firebird')

@section('body')

  <h1>Пример</h1>

  @if(Session::has('message'))
    <div class="alert alert-success">
        {!! Session::get('message') !!}
    </div>
  @endif

  <p>Пример работы с Firebird.<br/>
  </p>
@stop


@section('content')

    @include('menu')

    @yield('body')

@stop      
]]>
                </programlisting>
            </para>
            <para>Этот шаблон сам унаследован от шаблона master, кроме того он подключает шаблон
                menu.</para>
            <para>Меню довольно простое, состоит из трёх пунктов Заказчики, Продукты и Счёт фактуры. <programlisting language="javascript">
<![CDATA[
<nav class="navbar main">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" 
                data-toggle="collapse" data-target=".main-collapse">
            <span class="sr-only"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
    </div>
    <div class="collapse navbar-collapse main-collapse">
        <ul class="nav nav-tabs">
            <li @if (Request::is('customer*')) 
                class="active"@endif>{!! link_to("customers", "Заказчики") !!}</li>
            <li @if (Request::is('product*')) 
                class="active"@endif>{!! link_to("products", "Товары") !!}</li>
            <li @if (Request::is('invoice*')) 
                class="active"@endif>{!! link_to("invoices", "Счёт фактуры") !!}</li>
        </ul>
    </div>
</nav>
]]>                    
                </programlisting>
            </para>
            <para>В шаблоне master подключаются css стили и JavaScript файлы с библиотеками. <programlisting language="javascript">
<![CDATA[
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>@yield('title', 'Пример Web приложения на Firebird')</title>
        <meta name="description" content="@yield('description', 
             'Пример Web приложения на Firebird')" />
        @section('meta', '')

        
<link href="http://fonts.googleapis.com/css?family=Bitter" rel="stylesheet" 
      type="text/css" />        
<link href="//netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" 
      rel="stylesheet">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" 
      rel="stylesheet">
        
        
        {!! Rapyd::styles(true) !!}
    </head>

    <body>
        <div id="wrap">    
            <div class="container">
                <br />
                <div class="row">
                    <div class="col-sm-12">
                        @yield('content')
                    </div>
                </div>

            </div>  
        </div>    

        <div id="footer">
        </div>
        
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js">
</script>  
<script src="//netdna.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js">
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.pjax/1.9.6
/jquery.pjax.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/riot/2.2.4
/riot+compiler.min.js"></script>  
     
        {!! Rapyd::scripts() !!}
    </body>    
</html>
]]>                    
                </programlisting>
            </para>
            <para>Шаблон редактора заказчика customer_edit выглядит следующим образом <programlisting language="javascript">
<![CDATA[
@extends('example')

@section('title', 'Редактирование заказчика')

@section('body')
    <p>
        {!! $edit !!}
    </p>
@stop
]]>                    
                </programlisting>
            </para>
            <para>Контроллер товаров сделан аналогично контроллеру поставщиков. <programlisting language="php">
<![CDATA[
<?php

/*
 * Контроллер товаров
 */

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Product;


class ProductController extends Controller {
    /**
     * Отображает список продуктов
     *
     * @return Response
     */
    public function showProducts() {   
        // Подключаем виджет для поиска	
        $filter = \DataFilter::source(new Product);
        // Поиск будет по наименованию продукта
        $filter->add('NAME', 'Наименование', 'text');
        $filter->submit('Поиск');
        $filter->reset('Сброс');

        // Создам сетку для отображения отфильтрованных данных
        $grid = \DataGrid::source($filter);

        // выводимые столбцы сетки
        // Поле, подпись, сортируемый
        $grid->add('NAME', 'Наименование', true);
        // задаём формат с 2 знаками после запятой
        $grid->add('PRICE|number_format[2,., ]', 'Стоимость');
        
        $grid->row(function($row) {
            // Денежные величины прижимаем вправо
            $row->cell('PRICE')->style("text-align: right");
        });         
        // Добавляем кнопки для просмотра, редактирования и удаления записи
        $grid->edit('/product/edit', 'Редактирование', 'show|modify|delete'); 
        // Добавляем кнопку добавления заказчика
        $grid->link('/product/edit', "Добавление товара", "TR");
        // задаём сортировку
        $grid->orderBy('NAME', 'asc');
        // задаём количество записей на страницу
        $grid->paginate(10); 
        // отображаем шаблон customer и передаём в него фильтр и грид
        return view('product', compact('filter', 'grid'));
    }  
    
    /**
     * Добавление, редактирование и удаление продуктов
     * 
     * @return Response
     */
    public function editProduct() {
        if (\Input::get('do_delete') == 1)
            return "not the first";
        // создаём редактор
        $edit = \DataEdit::source(new Product());
        // задаём подпись диалога в зависимости от типа операции
        switch ($edit->status) {
            case 'create':
                $edit->label('Добавление товара');
                break;
            case 'modify':
                $edit->label('Редактирование товара');
                break;
            case 'do_delete':
                $edit->label('Удаление товара');
                break;
            case 'show':
                $edit->label('Карточка товара');
                $edit->link('products', 'Назад', 'TR');
                break;
        }
        // задаём что после операций добавления, редактирования и удаления 
        // возвращаемся к списку заказчиков 
        $edit->back('insert|update|do_delete', 'products');
        // Добавляем редакторы определённого типа, задаём им подпись 
        // и связываем их с атрибутами модели
        $edit->add('NAME', 'Наименование', 'text')->rule('required|max:100');
        $edit->add('PRICE', 'Стоимость', 'text')->rule('max:19');
        $edit->add('DESCRIPTION', 'Описание', 'textarea')
             ->attributes(['rows' => 8])
             ->rule('max:8192');
        // отображаем шаблон product_edit и передаём в него редактор
        return $edit->view('product_edit', compact('edit'));
    }    
}
]]>                    
                </programlisting>
            </para>
            <para>Контроллер счёт фактур является более сложным. В него добавлена дополнительная
                функция оплаты счёта. Оплаченные счёт фактуры подсвечиваются другим цветом. При
                просмотре счёт фактуры отображаются так же её позиции. Во время редактирования счёт
                фактуры есть возможность редактировать и её позиции. Далее я приведу текст
                контроллера с подробными комментариями. <programlisting language="php">
<![CDATA[
<?php

/*
 * Контроллер счёт фактур
 */

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Invoice;
use App\Customer;
use App\Product;
use App\InvoiceLine;

class InvoiceController extends Controller {

    /**
     * Отображает список счёт-фактур
     *
     * @return Response
     */
    public function showInvoices() {
        // Модель счёт фактур будет одновременно 
        // выбирать связанных поставщиков
        $invoices = Invoice::with('customer');
        // Подключаем виджет для поиска
        $filter = \DataFilter::source($invoices);
        // Позволяем фильтровать по диапазону дат
        $filter->add('INVOICE_DATE', 'Дата', 'daterange');
        // и фильтровать по имени заказчика
        $filter->add('customer.NAME', 'Заказчик', 'text');
        $filter->submit('Поиск');
        $filter->reset('Сброс');

        // Создам сетку для отображения отфильтрованных данных
        $grid = \DataGrid::source($filter);

        // выводимые столбцы сетки
        // Поле, подпись, сортируемый
        // для даты задаём дополнительную функцию, 
        // которая преобразует дату в строку
        $grid->add('INVOICE_DATE|strtotime|date[d.m.Y H:i:s]', 'Дата', true);
        // для денег задам формат с двумя знаками после запятой
        $grid->add('TOTAL_SALE|number_format[2,., ]', 'Сумма');
        $grid->add('customer.NAME', 'Заказчик');
        // Значение boolean отображаем как Да/Нет
        $grid->add('PAID', 'Оплачено')
             ->cell(function( $value, $row) {
                      return $value ? 'Да' : 'Нет';
                    });
        // задаём функцию обработки каждой строки
        $grid->row(function($row) {
            // Денежные величины прижимаем вправо
            $row->cell('TOTAL_SALE')->style("text-align: right");
            // окрашиваем оплаченные накладные в другой цвет
            if ($row->cell('PAID')->value == 'Да') {
                $row->style("background-color: #ddffee;");
            }
        });

        // Добавляем кнопки для просмотра, редактирования и удаления записи
        $grid->edit('/invoice/edit', 'Редактирование', 'show|modify|delete');
        // Добавляем кнопку добавления счёт-фактуры
        $grid->link('/invoice/edit', "Добавление счёта", "TR");
        // задаём сортировку
        $grid->orderBy('INVOICE_DATE', 'desc'); 
        // задаём количество записей на страницу
        $grid->paginate(10); 
        // отображаем шаблон customer и передаём в него фильтр и грид
        return view('invoice', compact('filter', 'grid'));
    }

    /**
     * Добавление, редактирование и удаление счет фактуры
     * 
     * @return Response
     */
    public function editInvoice() {
        // Получаем текст сохранённой ошибки, если она была
        $error_msg = \Request::old('error_msg');
        // создаём редактор счёт фактуры
        $edit = \DataEdit::source(new Invoice());
        // если счёт оплачен, то генерируем ошибку при попытке его редактирования
        if (($edit->model->PAID) && ($edit->status === 'modify')) {
            $edit->status = 'show';
            $error_msg = 'Редактирование не возможно. Счёт уже оплачен.';
        }
        // если счёт оплачен, то генерируем ошибку при попытке его удаления
        if (($edit->model->PAID) && ($edit->status === 'delete')) {
            $edit->status = 'show';
            $error_msg = 'Удаление не возможно. Счёт уже оплачен.';
        }        
        // задаём подпись диалога в зависимости от типа операции
        switch ($edit->status) {
            case 'create':
                $edit->label('Добавление счета');
                break;
            case 'modify':
                $edit->label('Редактирование счета');
                break;
            case 'do_delete':
                $edit->label('Удаление счета');
                break;
            case 'show':
                $edit->label('Счет');
                $edit->link('invoices', 'Назад', 'TR');
                // Если счёт фактуры не оплачена, показываем кнопку оплатить
                if (!$edit->model->PAID)
                    $edit->link('invoice/pay/' . $edit->model->INVOICE_ID, 
                                'Оплатить', 'BL');
                break;
        }

        // задаём что после операций добавления, редактирования и удаления 
        // возвращаемся к списку счет фактур 		
        $edit->back('insert|update|do_delete', 'invoices');

        // Задаём для поля дата, что оно обязательное
        // По умолчанию ставится текущая дата
        $edit->add('INVOICE_DATE', 'Дата', 'datetime')
                ->rule('required')
                ->insertValue(date('Y-m-d H:i:s'));

        // Добавляем поле для ввода заказчика. При наборе имени заказчика
        // будет отображаться список подсказок
        $edit->add('customer.NAME', 'Заказчик', 'autocomplete')
                ->rule('required')
                ->options(Customer::lists('NAME', 'CUSTOMER_ID')
                ->all());
        // добавляем поле, которое будет отображать сумму накладной, только для чтения
        $edit->add('TOTAL_SALE', 'Сумма', 'text')
                ->mode('readonly')
                ->insertValue('0.00');
        // Добавляем галочку Оплачено
        $paidCheckbox = $edit->add('PAID', 'Оплачено', 'checkbox')
                ->insertValue('0')
                ->mode('readonly');
        $paidCheckbox->checked_output = 'Да';
        $paidCheckbox->unchecked_output = 'Нет';

        // создаём грид для отображения строк счет фактуры
        $grid = $this->getInvoiceLineGrid($edit->model, $edit->status);
        // отображаем шаблон invoice_edit и передаём в него редактор и 
        // грид для отображения позиций
        return $edit->view('invoice_edit', compact('edit', 'grid', 'error_msg'));
    }

   /**
     * Оплата счёт фактуры
     *
     *  @return Response
     */
    public function payInvoice($id) {
        try {
            // находим счёт фактуру по идентификатору
            $invoice = Invoice::findOrFail($id);
            // вызываем процедуру оплаты
            $invoice->pay();
        } catch (\Illuminate\Database\QueryException $e) {
            // если произошла ошибка, то
            // выделяем текст исключения
            $pos = strpos($e->getMessage(), 'E_INVOICE_ALREADY_PAYED');
            if ($pos !== false) {
                // перенаправляем на страницу редактора и отображаем там ошибку
                return redirect('invoice/edit?show=' . $id)
                       ->withInput(['error_msg' => 'Счёт уже оплачен']);
            } else
                throw $e;
        }
        // перенаправляем на страницу редактора
        return redirect('invoice/edit?show=' . $id);
    }

    /**
     * Получение сетки для строк счета фактуры
     * @param \App\Invoice $invoice
     * @param string $mode 
     * @return \DataGrid
     */
    private function getInvoiceLineGrid(Invoice $invoice, $mode) {
        // Получаем строки счёт фактуры
        // Для каждой позиции счёта будет инициализироваться 
        // связанный с ним продукт
        $lines = InvoiceLine::with('product')
               ->where('INVOICE_ID', $invoice->INVOICE_ID);

        // Создам сетку для отображения позиций накладной
        $grid = \DataGrid::source($lines);
        // выводимые столбцы сетки
        // Поле, подпись, сортируемый
        $grid->add('product.NAME', 'Наименование');
        $grid->add('QUANTITY', 'Количество');
        $grid->add('SALE_PRICE|number_format[2,., ]', 'Стоимость')
             ->style('min-width: 8em;');
        $grid->add('SUM_PRICE|number_format[2,., ]', 'Сумма')
             ->style('min-width: 8em;');
        // задаём функцию обработки каждой строки
        $grid->row(function($row) {
            $row->cell('QUANTITY')->style("text-align: right");
            // Денежные величины приживаем вправо
            $row->cell('SALE_PRICE')->style("text-align: right");
            $row->cell('SUM_PRICE')->style("text-align: right");
        });

        if ($mode == 'modify') {
	     // Добавляем кнопки для просмотра, редактирования и удаления записи
            $grid->edit('/invoice/editline', 'Редактирование', 'modify|delete');
	     // Добавляем кнопку добавления заказчика
            $grid->link('/invoice/editline?invoice_id=' . $invoice->INVOICE_ID, 
                        "Добавление позиции", "TR");
        }

        return $grid;
    }

    /**
     * Добавление, редактирование и удаление позиций счет фактуры
     * 
     * @return Response
     */	
    public function editInvoiceLine() {
        if (\Input::get('do_delete') == 1)
            return "not the first";

        $invoice_id = null;
        // создаём редактор позиции счёт фактуры
        $edit = \DataEdit::source(new InvoiceLine());
        // задаём подпись диалога в зависимости от типа операции
        switch ($edit->status) {
            case 'create':
                $edit->label('Добавление позиции');
                $invoice_id = \Input::get('invoice_id');
                break;
            case 'modify':
                $edit->label('Редактирование позиции');
                $invoice_id = $edit->model->INVOICE_ID;
                break;
            case 'delete':
                $invoice_id = $edit->model->INVOICE_ID;
                break;
            case 'do_delete':
                $edit->label('Удаление позиции');
                $invoice_id = $edit->model->INVOICE_ID;
                break;
        }
        // формируем url для возврата
        $base = str_replace(\Request::path(), '', strtok(\Request::fullUrl(), '?'));
        $back_url = $base . 'invoice/edit?modify=' . $invoice_id;
        // устанавливаем страницу для возврата
        $edit->back('insert|update|do_delete', $back_url);
        $edit->back_url = $back_url;
        // добавляем скрытое поле с кодом счёт фактуры
        $edit->add('INVOICE_ID', '', 'hidden')
             ->rule('required')
             ->insertValue($invoice_id)
             ->updateValue($invoice_id);
        // Добавляем поле для ввода товара. При наборе имени товара
        // будет отображаться список подсказок
        $edit->add('product.NAME', 'Наименование', 'autocomplete')
             ->rule('required')
             ->options(Product::lists('NAME', 'PRODUCT_ID')->all());
        // поле для ввода количества		
        $edit->add('QUANTITY', 'Количество', 'text')
             ->rule('required');
        // отображаем шаблон invoice_line_edit и передаём в него редактор	
        return $edit->view('invoice_line_edit', compact('edit'));
    }
}
]]>                    
                </programlisting>
            </para>
            <para>Редактор счёт фактур имеет не стандартный для <package>zofe/rapyd</package> вид,
                поскольку нам необходимо выводить сетку с позициями счёт фактур. Для этого мы
                изменили шаблон invoice_edit следующим образом. <programlisting language="javascript">
<![CDATA[
@extends('example')

@section('title','Редактирование счета')

@section('body')

    <div class="container">
        {!! $edit->header !!}
        
        @if($error_msg)
            <div class="alert alert-danger">
                <strong>Ошибка!</strong> {{ $error_msg }}
            </div>           
        @endif
        
        {!! $edit->message !!}

        @if(!$edit->message)
        
            <div class="row">
                <div class="col-sm-4">
                    {!! $edit->render('INVOICE_DATE') !!}
                    {!! $edit->render('customer.NAME') !!}
                    {!! $edit->render('TOTAL_SALE') !!}
                    {!! $edit->render('PAID') !!}
                </div>            
            </div>
        
            {!! $grid !!}
        
        @endif
        
        {!! $edit->footer !!}
    </div>
@stop
]]>                
            </programlisting>
            </para>
            <para>Теперь, когда все контроллеры написаны, изменим маршруты так, чтобы наш сайт на
                стартовой странице открывал список счёт фактур. Напоминаю, что маршруты
                настраиваются в файле <filename>app/Http/routes.php</filename> в Laravel 5.2 и
                    <filename>routes/wep.php</filename> в Laravel 5.3. <programlisting language="php">
<![CDATA[
// Корневой маршрут
Route::get('/', 'InvoiceController@showInvoices');

Route::get('/customers', 'CustomerController@showCustomers');
Route::any('/customer/edit', 'CustomerController@editCustomer');

Route::get('/products', 'ProductController@showProducts');
Route::any('/product/edit', 'ProductController@editProduct');

Route::get('/invoices', 'InvoiceController@showInvoices');
Route::any('/invoice/edit', 'InvoiceController@editInvoice');
Route::any('/invoice/pay/{id}', 'InvoiceController@payInvoice');
Route::any('/invoice/editline', 'InvoiceController@editInvoiceLine');
]]>                
            </programlisting></para>
            <para>Здесь маршрут /invoice/pay/{id} выделяет идентификатор счёт фактуры из адреса и
                передаёт его в метод payInvoice. Остальные маршруты не требуют отдельного
                пояснения.</para>
            <para>Напоследок приведу несколько скриншотов получившегося веб приложения. <figure>
                    <title>Страница с гридом счёт-фактуры</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/php-invoice-grid.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Страница с гридом счёт-фактуры</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Страница с редактором счёт-фактуры</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/php-invoice-editor.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Страница с редактором счёт-фактуры</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>На этом мой пример закончен. Исходные коды вы можете скачать по ссылке <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://github.com/sim1984/phpfbexample"
                    >https://github.com/sim1984/phpfbexample</link>.</para>
        </section>
    </section>
    <section>
        <title>Создание приложений с использованием jOOQ и Spring MVC</title>

        <para>В данной главе будет описан процесс создания web приложения на языке Java с
            использованием фреймворка Spring MVC, библиотеки jOOQ и СУБД Firebird.</para>

        <para>Для упрощения разработки вы можете воспользоваться одной из распространённых IDE для
            Java (NetBeanse, IntelliJ IDEA, Eclipse, JDeveloper или др.). Лично я использовал
            NetBeanse. Для тестирования и отладки нам так же потребуется установить один и
            веб-серверов или серверов приложения (Apache Tomcat или Glass Fish). Создаём проект на
            основе шаблона Maven проекта веб-приложения.</para>

        <para>После создания проекта на основе шаблона необходимо преобразовать его структуру папок
            так чтобы она была корректной для Spring 4. Если проект создавался в среде NetBeans 8.2,
            то необходимо выполнить следующие шаги:<orderedlist>
                <listitem>
                    <para>Удалить файл <filename>index.html</filename></para>
                </listitem>
                <listitem>
                    <para>Создать папку <filename>WEB-INF</filename> внутри папки <filename>Web
                            Pages</filename></para>
                </listitem>
                <listitem>
                    <para>Внутри папки <filename>WEB-INF</filename> создать папки
                            <filename>jsp</filename>, <filename>jspf</filename> и
                            <filename>resources</filename></para>
                </listitem>
                <listitem>
                    <para>Внутри папки <filename>resources</filename> создаём папки
                            <filename>js</filename> и <filename>CSS</filename></para>
                </listitem>
                <listitem>
                    <para>Внутри папки <filename>jsp</filename> создаём файл
                            <filename>index.jsp</filename></para>
                </listitem>
            </orderedlist></para>
        <para>После наших манипуляций структура папок должна выглядеть следующим образом. <figure>
                <title>Структура каталогов Spring MVC проекта</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/java-dir-structure.png"/>
                    </imageobject>
                    <textobject>
                        <phrase>Структура каталогов Spring MVC проект</phrase>
                    </textobject>
                </mediaobject>
            </figure>
        </para>
        <para>В папке <filename>WEB-INF/jsp</filename> будут размещаться jsp странице, а в папке
                <filename>WEB-INF/jspf</filename> части страниц, которые будут подключены в другие
            странице с помощью инструкции
            <programlisting>
&lt;%@ include file ="<replaceable>&lt;имя файла&gt;</replaceable>" %&gt;
            </programlisting>
        </para>
        <para>Папка <filename>resource</filename> предназначена для размещения статических веб
            ресурсов. В папке <filename>WEB-INF/resources/css</filename> будут размещаться файлы
            каскадных таблиц стилей, в папке <filename>WEB-INF/resources/fonts</filename> – файлы
            шрифтов, в папке <filename>WEB-INF/resources/js</filename> – файлы JavaScript и
            сторонние JavaScript библиотеки.</para>
        <para>Теперь поправим файл pom.xml и пропишем в него общие свойства приложения, зависимости
            от пакетов библиотек (Spring MVC, Jaybird, JDBC пул, JOOQ) и свойства JDBC подключения. <programlisting language="xml">
<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>ru.ibase</groupId>
    <artifactId>fbjavaex</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging>

    <name>Firebird Java Example</name>

    <properties>
        <endorsed.dir>${project.build.directory}/endorsed</endorsed.dir>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <spring.version>4.3.4.RELEASE</spring.version>
        <jstl.version>1.2</jstl.version>
        <javax.servlet.version>3.0.1</javax.servlet.version>    
        <db.url>jdbc:firebirdsql://localhost:3050/examples</db.url>    
        <db.driver>org.firebirdsql.jdbc.FBDriver</db.driver>
        <db.username>SYSDBA</db.username>
        <db.password>masterkey</db.password>
    </properties>
    
    
    <dependencies>
        <dependency>
            <groupId>javax</groupId>
            <artifactId>javaee-web-api</artifactId>
            <version>7.0</version>
            <scope>provided</scope>
        </dependency>
        
        <dependency>  
            <groupId>javax.servlet</groupId>  
            <artifactId>javax.servlet-api</artifactId>  
            <version>${javax.servlet.version}</version>  
            <scope>provided</scope> 
        </dependency> 
         
        <dependency>  
            <groupId>jstl</groupId>  
            <artifactId>jstl</artifactId>  
            <version>${jstl.version}</version>  
        </dependency>   
        
        <!-- Работа с JSON -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-core</artifactId>
            <version>2.8.5</version>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-annotations</artifactId>
            <version>2.8.5</version>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.8.5</version>
        </dependency>        
                   
        
        <!-- Spring -->
        
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>${spring.version}</version>
        </dependency>
 
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
            <version>${spring.version}</version>
        </dependency>
 
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>${spring.version}</version>
        </dependency>
        
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>${spring.version}</version>
        </dependency>
    
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>${spring.version}</version>
        </dependency>        
        
        <!-- JDBC -->
        
        <dependency>
            <groupId>org.firebirdsql.jdbc</groupId>
            <artifactId>jaybird-jdk18</artifactId>
            <version>3.0.0</version>
        </dependency>  
        
        <!-- Пул коннектов -->  
        
        <dependency>
            <groupId>commons-dbcp</groupId>
            <artifactId>commons-dbcp</artifactId>
            <version>1.4</version>
        </dependency>          
        
        <!-- jOOQ -->   
                
        <dependency>
            <groupId>org.jooq</groupId>
            <artifactId>jooq</artifactId>
            <version>3.9.2</version>
        </dependency>
        
        <dependency>
            <groupId>org.jooq</groupId>
            <artifactId>jooq-meta</artifactId>
            <version>3.9.2</version>
        </dependency>
        
        <dependency>
            <groupId>org.jooq</groupId>
            <artifactId>jooq-codegen</artifactId>
            <version>3.9.2</version>
        </dependency>   
        
        <!-- Testing -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <type>jar</type>
            <scope>test</scope>
        </dependency>
    
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>${spring.version}</version>
            <scope>test</scope>
        </dependency>            
           
    </dependencies>

    <build>          
        
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.1</version>
                <configuration>
                    <source>1.7</source>
                    <target>1.7</target>
                    <compilerArguments>
                        <endorseddirs>${endorsed.dir}</endorseddirs>
                    </compilerArguments>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-war-plugin</artifactId>
                <version>2.3</version>
                <configuration>
                    <failOnMissingWebXml>false</failOnMissingWebXml>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-dependency-plugin</artifactId>
                <version>2.6</version>
                <executions>
                    <execution>
                        <phase>validate</phase>
                        <goals>
                            <goal>copy</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${endorsed.dir}</outputDirectory>
                            <silent>true</silent>
                            <artifactItems>
                                <artifactItem>
                                    <groupId>javax</groupId>
                                    <artifactId>javaee-endorsed-api</artifactId>
                                    <version>7.0</version>
                                    <type>jar</type>
                                </artifactItem>
                            </artifactItems>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>
]]>            
        </programlisting>
        </para>
        <para>После того как вы прописали все необходимые зависимости, желательно перезагрузить POM,
            чтобы загрузить все необходимые библиотеки. Если этого не сделать, то в процессе работы
            с проектом могут возникать ошибки. В NetBeans это делается следующим образом <figure>
                <title>Перезагрузка POM</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/java-reload-pom.png"/>
                    </imageobject>
                    <textobject>
                        <phrase>Перезагрузка POM</phrase>
                    </textobject>
                </mediaobject>
            </figure>
        </para>
        <para>Мне не очень нравится конфигурирование через xml, поэтому я буду работать через классы
            конфигурации Java. <programlisting language="java">
<![CDATA[
package ru.ibase.fbjavaex.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.view.JstlView;
import org.springframework.web.servlet.view.UrlBasedViewResolver;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.http.converter.HttpMessageConverter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.util.List;

@Configuration
@ComponentScan("ru.ibase.fbjavaex")
@EnableWebMvc
public class WebAppConfig extends WebMvcConfigurerAdapter {

    @Override
    public void configureMessageConverters(
      List<HttpMessageConverter<?>> httpMessageConverters) {
        MappingJackson2HttpMessageConverter jsonConverter = 
            new MappingJackson2HttpMessageConverter();
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, 
                               false);
        jsonConverter.setObjectMapper(objectMapper);
        httpMessageConverters.add(jsonConverter);
    }

    @Bean
    public UrlBasedViewResolver setupViewResolver() {
        UrlBasedViewResolver resolver = new UrlBasedViewResolver();
        resolver.setPrefix("/WEB-INF/jsp/");
        resolver.setSuffix(".jsp");
        resolver.setViewClass(JstlView.class);
        return resolver;
    }

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/WEB-INF/resources/");
    }
}
]]>            
        </programlisting>
        </para>
        <para>В данном конфигурационном классе мы задаём место поиска веб ресурсов и JSP
            представлений. Метод <function>configureMessageConverters</function> устанавливает, что
            дата должна сериализоваться в строковое представление (по умолчанию сериализуется в
            числовом представлении как timestamp).</para>
        <para>Теперь избавимся от файла <filename>Web.xml</filename> вместо него создадим файл
                <filename>WebInitializer.java</filename>. <programlisting language="javascript">
<![CDATA[
package ru.ibase.fbjavaex.config;

import javax.servlet.ServletContext;  
import javax.servlet.ServletException;  
import javax.servlet.ServletRegistration.Dynamic;  
  
import org.springframework.web.WebApplicationInitializer;  
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;  
import org.springframework.web.servlet.DispatcherServlet;  
  
public class WebInitializer implements WebApplicationInitializer {
    
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {        
        AnnotationConfigWebApplicationContext ctx = 
            new AnnotationConfigWebApplicationContext();  
        ctx.register(WebAppConfig.class);  
        ctx.setServletContext(servletContext);    
        Dynamic servlet = servletContext.addServlet("dispatcher", 
                                                    new DispatcherServlet(ctx));  
        servlet.addMapping("/");  
        servlet.setLoadOnStartup(1);
    }
    
}
]]>            
        </programlisting>
        </para>
        <para>Осталось сконфигурировать IoC контейнеры для внедрения зависимостей. К этому шагу мы
            вернёмся позже, а сейчас перейдём к генерации классов для работы с базой данных через
            jOOQ.</para>

        <section>
            <title>Генерации классов для работы с базой данных через jOOQ</title>

            <para>Работу с базой данных будем вести с помощью библиотеки <link
                    xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://www.jooq.org"
                    >jOOQ</link>. jOOQ позволяет строить SQL запросы из объектов jOOQ и кода
                (наподобие LINQ ). jOOQ имеет более тесную интеграцию с базой данных, чем ORM,
                поэтому кроме простых CRUD SQL запросов используемых в Active Record, позволяет
                использовать дополнительные возможности. Например, jOOQ умеет работать с хранимыми
                процедурами и функциями, последовательностями, использовать оконные функции и
                другие, специфичные для определённой СУБД, возможности. Полная документация по
                работе с jOOQ находится по адресу <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.jooq.org/doc/3.9/manual-single-page/"
                    >http://www.jooq.org/doc/3.9/manual-single-page/</link></para>

            <para>Классы jOOQ для работы с базой данных генерируются на основе схемы базы данных,
                описанной в главе <link linkend="app-db">Создание базы данных для примеров</link>. </para>

            <para>Для генерации классов jOOQ , работающих с нашей БД, необходимо скачать следующие
                бинарные файлы по ссылке <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.jooq.org/download">http://www.jooq.org/download</link>
                или через maven репозиторий: <itemizedlist>
                    <listitem>
                        <para><filename>jooq-3.9.2.jar</filename> — главная библиотека, которая
                            включается в наше приложение для работы с jOOQ.</para>
                    </listitem>
                    <listitem>
                        <para><filename>jooq-meta-3.9.2.jar</filename> — утилита, которая включается
                            в вашу сборку для навигации по схеме базы данных через сгенерированные
                            объекты;</para>
                    </listitem>
                    <listitem>
                        <para><filename>jooq-codegen-3.9.2.jar</filename> — утилита, которая
                            включается в вашу сборку для генерации схемы базы данных.</para>
                    </listitem>
                </itemizedlist></para>
            <para>Кроме того для подключения к БД Firebird через JDBC вам потребуется скачать
                драйвер <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://github.com/FirebirdSQL/jaybird/releases/download/v3.0.0/Jaybird-3.0.0-JDK_1.8.zip"
                    >jaybird-full-3.0.0.jar</link>.</para>
            <para>Теперь надо создать файл конфигурации <filename>example.xml</filename>, который
                будет использован для генерации классов схемы БД. <programlisting language="xml">
<![CDATA[
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<configuration xmlns="http://www.jooq.org/xsd/jooq-codegen-3.8.0.xsd">
  <!-- Конфигурация подключения к БД -->
  <jdbc>
    <driver>org.firebirdsql.jdbc.FBDriver</driver>
    <url>jdbc:firebirdsql://localhost:3050/examples</url>
    <user>SYSDBA</user>
    <password>masterkey</password>
    <properties>
      <property>
        <key>charSet</key>
        <value>utf-8</value>
      </property>
    </properties>
  </jdbc>

  <generator>
    <name>org.jooq.util.JavaGenerator</name>

    <database>
      <!-- Тип базы данных. Формат:
           org.util.[database].[database]Database -->
      <name>org.jooq.util.firebird.FirebirdDatabase</name>

      <inputSchema></inputSchema>

      <!-- Все объекты, которые генерируются из вашей схемы 
           (Регулярное выражение Java. Используйте фильтры, чтобы ограничить 
           количество объектов). 
           Следите за чувствительностью к регистру. В зависимости от вашей 
           базы данных, это может быть важно! -->
      <includes>.*</includes>

      <!-- Объекты, которые исключаются при генерации из вашей схемы.
           (Регулярное выражение Java).
           В данном случае мы исключаем системные таблицы RDB$, таблицы 
           мониторинга MON$ и псевдотаблицы безопасности SEC$. -->
      <excludes>
          RDB\$.*
        | MON\$.*
        | SEC\$.*
      </excludes>
    </database>

    <target>
      <!-- Имя пакета в который будут выгружены сгенерированные классы -->
      <packageName>ru.ibase.fbjavaex.exampledb</packageName>

      <!-- Директория для размещения сгенерированных классов. 
           Здесь используется структура директорий Maven. -->
      <directory>e:/OpenServer/domains/localhost/fbjavaex/src/main/java/</directory>
    </target>
  </generator>
</configuration>
]]>                
            </programlisting>
            </para>
            <para>Теперь переходим в командную строку и выполняем следующую команду:
                <programlisting>
java -cp jooq-3.9.2.jar;jooq-meta-3.9.2.jar;jooq-codegen-3.9.2.jar;
jaybird-full-3.0.0.jar;. org.jooq.util.GenerationTool example.xml                
            </programlisting>
            </para>
            <para>Данная команда создаст необходимые классы и позволит писать на языке Java запросы
                к объектам БД. Подробнее с процессом генерации классов вы можете ознакомиться по
                ссылке <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://www.jooq.org/doc/3.9/manual-single-page/%23code-generation"
                    >https://www.jooq.org/doc/3.9/manual-single-page/#code-generation</link>.
            </para>
        </section>
        <section>
            <title>Конфигурация IoC контейнеров</title>

            <para>В Spring внедрение зависимостей (Dependency Injection (DI)) осуществляется через
                Spring IoC (Inversion of Control) контейнер. Внедрение зависимостей, является
                процессом, согласно которому объекты определяют свои зависимости, т.е. объекты, с
                которыми они работают, через аргументы конструктора/фабричного метода или свойства,
                которые были установлены или возвращены фабричным методом. Затем контейнер inject
                (далее "внедряет") эти зависимости при создании бина. Подробнее о внедрении
                зависимостей вы можете почитать по ссылке <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans"
                    >http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans</link>.</para>
            <para>Я не сторонник xml конфигурации, поэтому мы будем использовать подход на основе
                аннотаций и Java-конфигурации. Основными признаками и частями Java-конфигурации IoC
                контейнера являются классы с аннотацией @Configuration и методы с аннотацией @Bean.
                Аннотация @Bean используется для указания того, что метод создает, настраивает и
                инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно
                использовать как в классах с аннотацией @Configuration. Наш IoC контейнер будет
                возвращать пул подключений, менеджер транзакций, транслятор исключений (преобразует
                исключения <classname>SQLException</classname> в специфичные для Spring исключения
                    <classname>DataAccessException</classname>), DSL контекст (стартовая точка, для
                построения всех запросов используя Fluent API), а также менеджеры для реализации
                бизнес логики и гриды для отображения данных. <programlisting language="java">
<![CDATA[
/**
 * Конфигурация IoC контейнера
 * для осуществления внедрения зависимостей.
 */

package ru.ibase.fbjavaex.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;
import org.apache.commons.dbcp.BasicDataSource;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy;
import org.jooq.impl.DataSourceConnectionProvider;
import org.jooq.DSLContext;
import org.jooq.impl.DefaultDSLContext;
import org.jooq.impl.DefaultConfiguration;
import org.jooq.SQLDialect;
import org.jooq.impl.DefaultExecuteListenerProvider;

import ru.ibase.fbjavaex.exception.ExceptionTranslator;

import ru.ibase.fbjavaex.managers.*;
import ru.ibase.fbjavaex.jqgrid.*;

/**
 * Конфигурационный класс Spring IoC контейнера
 */
@Configuration
public class JooqConfig {


    /**
     * Возвращает пул коннектов
     *
     * @return 
     */
    @Bean(name = "dataSource")
    public DataSource getDataSource() {
        BasicDataSource dataSource = new BasicDataSource();
        // определяем конфигурацию подключения
        dataSource.setUrl("jdbc:firebirdsql://localhost:3050/examples");
        dataSource.setDriverClassName("org.firebirdsql.jdbc.FBDriver");
        dataSource.setUsername("SYSDBA");
        dataSource.setPassword("masterkey");
        dataSource.setConnectionProperties("charSet=utf-8");
        return dataSource;
    }

    /**
     * Возращает менеджер транзакций
     * 
     * @return 
     */
    @Bean(name = "transactionManager")
    public DataSourceTransactionManager getTransactionManager() {
        return new DataSourceTransactionManager(getDataSource());
    }

    @Bean(name = "transactionAwareDataSource")
    public TransactionAwareDataSourceProxy getTransactionAwareDataSource() {
        return new TransactionAwareDataSourceProxy(getDataSource());
    }

    /**
     * Возвращает провайдер подключений
     * 
     * @return 
     */
    @Bean(name = "connectionProvider")
    public DataSourceConnectionProvider getConnectionProvider() {
        return new DataSourceConnectionProvider(getTransactionAwareDataSource());
    }

    /**
     * Возвращает транслятор исключений
     * 
     * @return 
     */
    @Bean(name = "exceptionTranslator")
    public ExceptionTranslator getExceptionTranslator() {
        return new ExceptionTranslator();
    }

    /**
     * Возвращает конфигурацию DSL контекста
     *
     * @return 
     */
    @Bean(name = "dslConfig")
    public org.jooq.Configuration getDslConfig() {
        DefaultConfiguration config = new DefaultConfiguration();
        // используем диалект SQL СУБД Firebird
        config.setSQLDialect(SQLDialect.FIREBIRD);
        config.setConnectionProvider(getConnectionProvider());
        DefaultExecuteListenerProvider listenerProvider = 
          new DefaultExecuteListenerProvider(getExceptionTranslator());
        config.setExecuteListenerProvider(listenerProvider);
        return config;
    }

    /**
     * Возвращает DSL контекст
     *
     * @return 
     */
    @Bean(name = "dsl")
    public DSLContext getDsl() {
        org.jooq.Configuration config = this.getDslConfig();
        return new DefaultDSLContext(config);
    }

    /**
     * Возвращает менеджер заказчиков
     * 
     * @return 
     */
    @Bean(name = "customerManager")
    public CustomerManager getCustomerManager() {
        return new CustomerManager();
    }

    /**
     * Возвращает грид с заказчиками
     * 
     * @return 
     */
    @Bean(name = "customerGrid")
    public JqGridCustomer getCustomerGrid() {
        return new JqGridCustomer();
    }

    /**
     * Возвращает менеджер продуктов
     * 
     * @return 
     */
    @Bean(name = "productManager")
    public ProductManager getProductManager() {
        return new ProductManager();
    }

    /**
     * Возвращает грид с товарами
     * 
     * @return 
     */
    @Bean(name = "productGrid")
    public JqGridProduct getProductGrid() {
        return new JqGridProduct();
    }

    /**
     * Возвращает менеджер счёт фактур
     * 
     * @return 
     */
    @Bean(name = "invoiceManager")
    public InvoiceManager getInvoiceManager() {
        return new InvoiceManager();
    }

    /**
     * Возвращает грид с заголовками счёт фактур
     * 
     * @return 
     */
    @Bean(name = "invoiceGrid")
    public JqGridInvoice getInvoiceGrid() {
        return new JqGridInvoice();
    }

    /**
     * Возвращает грид с позициями счёт фактуры
     * 
     * @return 
     */
    @Bean(name = "invoiceLineGrid")
    public JqGridInvoiceLine getInvoiceLineGrid() {
        return new JqGridInvoiceLine();
    }

    /**
     * Возвращает рабочий период
     * 
     * @return 
     */
    @Bean(name = "workingPeriod")
    public WorkingPeriod getWorkingPeriod() {
        return new WorkingPeriod();
    }

}
]]>                
            </programlisting>
            </para>
        </section>
        <section>
            <title>Построение SQL запросов используя jOOQ</title>

            <para>Прежде чем рассматривать реализацию менеджеров и сеток ( grids ) расскажем, как
                работать с базой данных через jOOQ. Здесь будут изложены лишь краткие сведения о
                построении запросов, полную документацию по этому вопросу вы можете найти в главе
                    <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://www.jooq.org/doc/3.9/manual-single-page/%23sql-building"
                    >sql-building</link> документации jOOQ.</para>

            <para>Класс <classname>org.jooq.impl.DSL</classname> является основным классом, от
                которого вы будете создавать все объекты jOOQ. Он выступает в роли статической
                фабрики для табличных выражений, выражений столбцов (или полей), условных выражений
                и многих других частей запроса.</para>
            <para>DSLContext ссылается на объект <classname>org.jooq.Configuration</classname>,
                который настраивает поведение jOOQ, при выполнении запросов. В отличие от
                статического DSL, DSLContext позволяет создавать SQL-операторы, которые уже
                "настроены" и готовы к выполнению. В нашем приложении DSLContext создаётся в классе
                конфигурации JooqConfig в методе <function>getDsl</function>. Конфигурация для
                DSLContext возвращается методом <function>getDslConfig</function>. В этом методе мы
                указали, что будем использовать диалект SQL СУБД Firebird, провайдер подключений
                (определяет, как мы получаем подключение через JDBC) и слушатель выполнения SQL
                запросов. </para>
            <para>jOOQ поставляется с собственным DSL (или Domain Specific Language), который
                эмулирует SQL в Java. Это означает, что вы можете писать SQL-операторы почти так,
                как если бы Java изначально поддерживал их, примерно так же, как .NET в C# делает
                это с помощью LINQ к SQL.</para>
            <para>jOOQ использует неформальную BNF нотацию, которая моделирует унифицированный SQL
                диалект, подходящий для большинства СУБД. В отличие от других, более простых
                фреймворков, которые используют "Fluent API" или "метод цепочек", иерархия
                интерфейса BNF на основе jOOQ не позволяет плохой синтаксис запросов.</para>
            <para>Давайте рассмотрим простой запрос на языке SQL <programlisting language="sql">
 <![CDATA[
 SELECT *
  FROM author a
  JOIN book b ON a.id = b.author_id
 WHERE a.year_of_birth > 1920
   AND a.first_name = 'Paulo'
 ORDER BY b.title
 ]]>               
            </programlisting>
            </para>
            <para>В jOOQ он будет выглядеть следующим образом: <programlisting language="java">
 <![CDATA[
Result<Record> result =
dsl.select()
   .from(AUTHOR.as("a"))
   .join(BOOK.as("b")).on(a.ID.equal(b.AUTHOR_ID))
   .where(a.YEAR_OF_BIRTH.greaterThan(1920)
   .and(a.FIRST_NAME.equal("Paulo")))
   .orderBy(b.TITLE)
   .fetch();
 ]]>               
            </programlisting>
            </para>
            <para>Классы <classname>AUTHOR</classname> и <classname>BOOK</classname>, описывающие
                соответствующие таблицы должны быть сгенерированы заранее. Процесс генерации классов
                jOOQ по заданной схеме БД был описан выше.</para>
            <para>В данном случае мы задали таблицам <classname>AUTHOR</classname> и
                    <classname>BOOK</classname> алиас с помощью конструкции <function>as</function>.
                Без использования алиасов этот запрос выглядел бы следующим образом <programlisting language="java">
<![CDATA[
Result<Record> result =
dsl.select()
   .from(AUTHOR)
   .join(BOOK).on(AUTHOR.ID.equal(BOOK.AUTHOR_ID))
   .where(AUTHOR.YEAR_OF_BIRTH.greaterThan(1920)
   .and(AUTHOR.FIRST_NAME.equal("Paulo")))
   .orderBy(BOOK.TITLE)
   .fetch();
]]>               
            </programlisting>
            </para>
            <para>Теперь посмотрим более сложный запрос с использованием агрегатных функций и
                группировки. <programlisting language="sql">
 <![CDATA[
SELECT AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, COUNT(*)
FROM AUTHOR
  JOIN BOOK ON AUTHOR.ID = BOOK.AUTHOR_ID
WHERE BOOK.LANGUAGE = 'DE'
  AND BOOK.PUBLISHED > '2008-01-01'
GROUP BY AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME
  HAVING COUNT(*) > 5
ORDER BY AUTHOR.LAST_NAME ASC NULLS FIRST
  OFFSET 1 ROWS
  FETCH FIRST 2 ROWS ONLY
 ]]>               
            </programlisting>
            </para>
            <para>В jOOQ он будет выглядеть так: <programlisting language="java">
<![CDATA[
dsl.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, count())
   .from(AUTHOR)
   .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
   .where(BOOK.LANGUAGE.equal("DE"))
   .and(BOOK.PUBLISHED.greaterThan("2008-01-01"))
   .groupBy(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
   .having(count().greaterThan(5))
   .orderBy(AUTHOR.LAST_NAME.asc().nullsFirst())
   .limit(2)
   .offset(1)
   .fetch();
]]>               
            </programlisting>
            </para>
            <para>Заметьте ограничение на количество возвращаемых записей, будет сгенерировано в
                соответствии с указанным диалектом SQL. В примере выше использовался диалект
                    <literal>FIREIRD_3_0</literal>. Если бы был указан диалект
                    <literal>FIREBIRD_2_5</literal> или просто FIREBIRD, то использовалось бы
                предложение ROWS вместо OFFSET … FETCH.</para>
            <para>Вы можете собирать запрос по частям. Это позволяет менять его динамически, что
                можно использовать для изменения порядка сортировки или добавления дополнительных
                параметров фильтрации. <programlisting language="java">
<![CDATA[
SelectFinalStep<?> select
    = dsl.select()
         .from(PRODUCT);

SelectQuery<?> query = select.getQuery();
switch (searchOper) {
    case "eq":
         query.addConditions(PRODUCT.NAME.eq(searchString));
         break;
    case "bw":
         query.addConditions(PRODUCT.NAME.startsWith(searchString));
         break;
    case "cn":
         query.addConditions(PRODUCT.NAME.contains(searchString));
         break;
}
switch (sOrd) {
    case "asc":
         query.addOrderBy(PRODUCT.NAME.asc());
         break;
    case "desc":
         query.addOrderBy(PRODUCT.NAME.desc());
         break;
}
return query.fetchMaps();
]]>               
            </programlisting>
            </para>
            <section>
                <title>Именованные и неименованные параметры</title>

                <para>По умолчанию каждый раз, когда вы используете в запросе литера строк, дат и
                    чисел, а также подставляете внешние переменные, jOOQ делает привязку этой
                    переменной или литерала через неименованные параметры. Например, следующее
                    выражение на языке Java <programlisting language="java">
<![CDATA[
dsl.select()
   .from(BOOK)
   .where(BOOK.ID.equal(5))
   .and(BOOK.TITLE.equal("Animal Farm"))
   .fetch();
]]>               
            </programlisting> Эквивалентно полной форме записи <programlisting language="java">
<![CDATA[
dsl.select()
   .from(BOOK)
   .where(BOOK.ID.equal(val(5)))
   .and(BOOK.TITLE.equal(val("Animal Farm")))
   .fetch();
]]>               
            </programlisting> и преобразуется в sql запрос <programlisting language="sql">
<![CDATA[
SELECT *
FROM BOOK
WHERE BOOK.ID = ?
  AND BOOK.TITLE = ?
]]>               
            </programlisting>
                </para>
                <para>Вам не нужно беспокоиться какой индекс у соответствующего параметра, значения
                    автоматически будут привязаны к нужному параметру. Если нужно изменить значение
                    параметра, то вы можете сделать это, выбрав нужный параметр по номеру индекса
                    (индексация начинается с 1). <programlisting language="java">
<![CDATA[
Select<?> select = 
  dsl.select()
     .from(BOOK)
     .where(BOOK.ID.equal(5))
     .and(BOOK.TITLE.equal("Animal Farm"));
Param<?> param = select.getParam("2");
Param.setValue("Animals as Leaders");
]]>               
            </programlisting>
                </para>
                <para>Другим способом присвоить параметру новое значение является вызов метода
                        <function>bind</function>. <programlisting language="java">
<![CDATA[
Query query1 = 
  dsl.select()
     .from(AUTHOR)
     .where(LAST_NAME.equal("Poe"));
query1.bind(1, "Orwell");
]]>               
            </programlisting>
                </para>
                <para>Кроме того, jOOQ поддерживает именованные параметры. В этом случае их надо
                    явно создавать, используя <classname>org.jooq.Param</classname>. <programlisting language="java">
<![CDATA[
// Create a query with a named parameter. You can then use that name for 
// accessing the parameter again
Query query1 = 
  dsl.select()
     .from(AUTHOR)
     .where(LAST_NAME.equal(param("lastName", "Poe")));
Param<?> param1 = query.getParam("lastName");

// Or, keep a reference to the typed parameter in order 
// not to lose the <T> type information:
Param<String> param2 = param("lastName", "Poe");
Query query2 = 
  dsl.select()
     .from(AUTHOR)
     .where(LAST_NAME.equal(param2));

// You can now change the bind value directly on the Param reference:
param2.setValue("Orwell");
]]>               
            </programlisting>
                </para>
                <para>Другим способом присвоить параметру новое значение является вызов метода
                        <function>bind</function>. <programlisting language="java">
<![CDATA[
// Or, with named parameters
Query query2 = 
  dsl.select()
     .from(AUTHOR)
     .where(LAST_NAME.equal(param("lastName", "Poe")));
query2.bind("lastName", "Orwell");
]]>               
            </programlisting>
                </para>
            </section>
            <section>
                <title>Возврат значений из селективных запросов</title>

                <para>jOOQ предоставляет множество способов извлечения данных из SQL запросов. Мы не
                    будем перечислять здесь все способы, подробнее вы можете прочитать о них в главе
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="https://www.jooq.org/doc/3.9/manual-single-page/#fetching"
                        >Fetching</link> документации jOOQ. Мы в своём примере будем пользоваться
                    возвратом в список карт (метод <function>fetchMaps</function>), который удобно
                    использовать для сериализации результата в JSON.</para>
            </section>
        </section>

    </section>
</chapter>
