<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="app" xml:lang="ru"
    xmlns:xi="http://www.w3.org/2001/XInclude">
    <info>
        <title>Создание приложений с использованием Firebird</title>
    </info>


    <section xml:id="app-delphi">
        <title>Создание приложений с использованием FireDac</title>

        <para>В данной главе будет описан процесс создания приложений для СУБД Firebird с
            использованием компонентов доступа FireDac и среды Delphi XE5. FireDac является
            стандартным набором компонентов доступа к различным базам данных начиная с Delphi
            XE3.</para>
        <para>Создайте новый проект <guimenu>File->New->VCL Forms Application - Delphi</guimenu>. В
            новый проект добавьте новый дата модуль <guimenu>File->New->Other</guimenu>, в
            появившемся мастере выберите <guimenu>Delphi Projects->Delphi Files->Data
                Module</guimenu>. Этот дата модуль будет главным в нашем проекте. Он будет содержать
            некоторые экземпляры глобальных компонентов доступа, которые должны быть доступны всем
            формам, которые должны работать с данными. Например, таким компонентом является
                <classname>TFDConnection</classname>.</para>

        <section>
            <title>Компонент TFDConnection</title>

            <para>Компонент <classname>TFDConnection</classname> обеспечивает подключение к
                различным типам баз данных. Будем указывать экземпляр этого компонента в свойствах
                    <property>Connection</property> остальных компонентов FireDac. К какому именно
                типу баз данных будет происходить подключение, зависит от значения свойства
                DriverName. Для доступа к Firebird нам необходимо выставить это свойство в значение
                FB. Для того чтобы подключение знало, с какой именно библиотекой доступа необходимо
                работать, разместим в главном дата модуле компонент
                    <classname>TFBPhysFBDriverLink</classname>. Его свойство
                    <property>VendorLib</property> позволяет указывать путь до клиентской
                библиотеки. Если оно не указано, то подключение к Firebird будет осуществляться
                через библиотеки, зарегистрированные в системе, например в
                    <filename>system32</filename>, что в ряде случаев может быть
                нежелательно.</para>

            <section>
                <title>Путь к клиентской библиотеке</title>

                <para>Мы будем размещать необходимую библиотеку доступа в папке
                        <filename>fbclient</filename>, которая расположена в папке приложения. Для
                    этого в коде на событие OnCreate дата модуля пропишем следующий код.
                    <programlisting language="delphi"> 
// указываем путь до клиентской библиотеки
xAppPath := ExtractFileDir(Application.ExeName) + PathDelim;
FDPhysFBDriverLink.VendorLib := xAppPath + 'fbclient' + PathDelim + 'fbclient.dll';
                </programlisting>
                </para>

                <important>
                    <para> Если вы компилируете 32 разрядное приложение, то вы должны использовать
                        32 разрядную библиотеку <filename>fbclient.dll</filename>. Для 64 разрядного
                        – 64 разрядную. Помимо файла <filename>fbclient.dll</filename> в ту же папку
                        желательно поместить библиотеки <filename>msvcp80.dll</filename> и
                            <filename>msvcr80.dll</filename> (для Firebird 2.5), и msvcp100.dll и
                        msvcr100.dll (для Firebird 3.0). Эти библиотеки можно найти либо в подпапке
                        bin (Firebird 2.5), либо в корневой папке сервера (Firebird 3.0). </para>
                    <para> Для того чтобы приложение правильно отображало собственные ошибки
                        firebird, необходимо также скопировать файл
                            <filename>firebird.msg</filename>. Для Firebird 2.5 и в более ранних
                        версиях он должен находиться на один уровень выше каталога клиентской
                        библиотеки, т.е. в нашем случае в каталоге приложения. Для Firebird 3 он
                        должен находиться в каталоге клиентской библиотеки, т.е. в каталоге
                        fbclient. </para>
                </important>

                <para>Если вам необходимо чтобы ваше приложение работало без установленного сервера
                    Firebird, т.е. в режиме Embedded, то для Firebird 2.5 необходимо заменить
                        <filename>fbclient.dll</filename> на <filename>fbembed.dll</filename>. При
                    желании имя библиотеки можно вынести в конфигурационный файл вашего приложения.
                    Для Firebird 3.0 ничего изменять не требуется (режим работы зависит от строки
                    подключения и значения параметра Providers в файле
                        <filename>firebird.conf</filename> или
                    <filename>databases.conf</filename>).</para>

                <tip>
                    <para>Даже если ваше приложение будет работать с Firebird в режиме Embedded,
                        разработку удобнее вести под полноценным сервером. Дело в том, что в режиме
                        Embedded Firebird работает в одном адресном пространстве с вашим
                        приложением, что может привести к нежелательным последствиям при
                        возникновении ошибок в вашем приложении. Кроме того, в момент разработки
                        среда Delphi и ваше приложение являются отдельными приложениями,
                        использующими Embedded. До версии 2.5 они не могут работать с одной базой
                        одновременно. </para>
                </tip>
            </section>

            <section>
                <title>Параметры подключения</title>

                <para>Компонент <classname>TFDConnection</classname> параметры подключения к базе
                    данных содержатся в свойстве Params (имя пользователя, пароль, набор символов
                    соединения и др.). Если воспользоваться редактором свойств
                        <classname>TFDConnection</classname> (двойной клик на компоненте), то
                    упомянутые свойства будут заполнены автоматически. Набор этих свойств зависит от
                    типа базы данных.</para>
                <para>
                    <table>
                        <?dbfo keep-together='auto'?>
                        <title>Основные свойства компонента TFDConnection</title>

                        <tgroup cols="2">
                            <colspec colwidth="2*" align="left"/>
                            <colspec colwidth="4*" align="left"/>
                            <thead>
                                <row valign="middle">
                                    <entry align="center">Свойство</entry>
                                    <entry align="center">Назначение</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row valign="middle">
                                    <entry>Pooled</entry>
                                    <entry><para>Используется ли пул соединений.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>Database</entry>
                                    <entry><para>Путь к базе данных или её псевдоним, определённый в
                                            файле конфигурации aliases.conf (или databases.conf)
                                            сервера Firebird.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>User_Name</entry>
                                    <entry><para>Имя пользователя.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>Password</entry>
                                    <entry><para>Пароль.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>OSAuthent</entry>
                                    <entry><para>Используется ли аутентификация средствами
                                            операционной системы.</para></entry>
                                </row>
                                <row valign="middle">
                                    <entry>Protocol</entry>
                                    <entry><para>Протокол соединения. Допускаются следующие значения:<itemizedlist>
                                                <listitem>
                                                  <para>Local — локальный протокол;</para>
                                                </listitem>
                                                <listitem>
                                                  <para>NetBEUI — именованные каналы;</para>
                                                </listitem>
                                                <listitem>
                                                  <para>SPX — локальный протокол (до Firebird 2.0,
                                                  не поддерживается в современных версиях);</para>
                                                </listitem>
                                                <listitem>
                                                  <para>TCPIP – TCP/IP.</para>
                                                </listitem>
                                            </itemizedlist></para></entry>
                                </row>
                                <row>
                                    <entry>Server</entry>
                                    <entry><para>Имя сервера или его IP адрес. Если сервер работает
                                            на нестандартном порту, то необходимо также указать порт
                                            через слэш, например localhost/3051.</para></entry>
                                </row>
                                <row>
                                    <entry>SQLDialect</entry>
                                    <entry><para>Диалект. Должен совпадать с диалектом базы
                                            данных.</para></entry>
                                </row>
                                <row>
                                    <entry>RoleName</entry>
                                    <entry><para>Имя роли.</para></entry>
                                </row>
                                <row>
                                    <entry>CharacterSet</entry>
                                    <entry><para>Имя набора символов соединения.</para></entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
                <para>
                    <figure>
                        <title>Параметры подключения</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/firedac-connection-editor.png"
                                    align="center"/>
                            </imageobject>
                            <textobject>
                                <phrase>Параметры подключения</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>Дополнительные свойства: <itemizedlist>
                        <listitem>
                            <para><emphasis role="bold">Connected</emphasis> – управление
                                подсоединением к БД, или проверка состояния соединения. Это свойство
                                должно быть выставлено в True для работы мастеров других компонентов
                                FireDac . Если ваше приложение должно запрашивать данные для
                                авторизации, то важно не забыть сбросить это свойство в False перед
                                компиляцией вашего приложения.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">LoginPrompt</emphasis> – запрашивать ли имя
                                пользователя и пароль при попытке соединения.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Transaction</emphasis> – компонент
                                TFDTransaction , который будет использоваться в качестве
                                умолчательного для выполнения различных операций TFDConnection .
                                Если это свойство не назначено явно, TFDConnection создаст себе
                                экземпляр TFDTransaction самостоятельно, его параметры можно указать
                                в свойстве TxOptions.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">UpdateTransaction</emphasis> – компонент
                                TFDTransaction , который будет использоваться в качестве
                                умолчательного для одноимённых свойств компонентов TFDQuery . Если
                                это свойство не назначено явно, будет использовано значение из
                                свойства Transaction .</para>
                        </listitem>
                    </itemizedlist></para>
                <para>Поскольку параметры подключения, за исключением имени пользователя и пароля,
                    обычно не изменяются в процессе эксплуатации приложения, мы будем считывать их
                    из файла конфигурации.
                    <programlisting language="delphi"> 
// считываем параметры подключения
xIniFile := TIniFile.Create(xAppPath + 'config.ini');
try
  xIniFile.ReadSectionValues('connection', FDConnection.Params);
finally
  xIniFile.Free;
end;
                </programlisting>
                </para>
                <para>Файл <filename>config.ini</filename> содержит примерно следующие строки:
                    <programlisting language="ini"> 
[connection]
DriverID=FB
Protocol=TCPIP
Server=localhost/3051
Database=examples
OSAuthent=No
RoleName=
CharacterSet=UTF8
                </programlisting>
                </para>
                <para>Содержимое секции connection можно получить, скопировав содержимое свойства
                    Params компонента TFDConnection после работы мастера.</para>
                <note>
                    <para>На самом деле общие настройки обычно находятся в
                                <filename>%AppData%\<replaceable>Manufacture</replaceable>\<replaceable>AppName</replaceable></filename>
                        и сохраняются туда инсталлятором приложения. Однако при разработке удобно
                        чтобы файл настроек лежал где-нибудь поближе, например, в папке с
                        приложением.</para>
                    <para>Учтите, что если ваше приложение будет устанавливаться в папку
                            <filename>Program Files</filename> и файл настройки будет лежать там же,
                        то либо этот файл будет виртуализироваться в <filename>Program
                            Data</filename>, либо будут проблемы с его модификацией и последующим
                        чтением новых настроек. </para>
                </note>
            </section>
            <section>
                <title>Подключение к базе данных</title>

                <para>Для подключения к базе данных необходимо изменить свойство
                        <property>Connected</property> компонента
                        <classname>TFDConnection</classname> в значение <literal>True</literal> или
                    вызвать метод <function>Open</function>. В последний метод можно передать имя
                    пользователя и пароль в качестве параметров. В нашем приложении мы заменим
                    стандартный диалог соединения с базой данных. Дадим возможность ошибиться при
                    вводе регистрационной информации не более трёх раз, после чего приложение будет
                    закрыто. Для этого напишем следующий код в обработчике события
                        <property>OnCreate</property> главного датамодуля.
                    <programlisting language="delphi"> 
// делаем максимум 3 попытки входа в систему, потом закрываем приложение
xLoginCount := 0;
xLoginPromptDlg := TLoginPromptForm.Create(Self);
while (xLoginCount &lt; MAX_LOGIN_COUNT) and 
      (not FDConnection.Connected) do
begin
  try
    if xLoginPromptDlg.ShowModal = mrOK then
      FDConnection.Open(
        xLoginPromptDlg.UserName, xLoginPromptDlg.Password)
    else
      xLoginCount := MAX_LOGIN_COUNT;
  except
    on E: Exception do
    begin
      Inc(xLoginCount);
      Application.ShowException(E);
    end
  end;
end;
xLoginPromptDlg.Free;

if not FDConnection.Connected then
  Halt;

                </programlisting>
                </para>
            </section>
        </section>

        <section>
            <title>Компонент TFDTransaction</title>

            <para>Компонент <classname>TFDTransaction</classname> предназначен для явной работы с
                транзакциями.</para>
            <para>Клиентская часть Firebird допускает выполнение любых действий только в контексте
                транзакции. Поэтому если вы смогли получить доступ к данным без явного вызова
                    <function>TFDTransaction.StartTransaction</function>, то значит где-то в недрах
                FireDac этот вызов произошёл автоматически. Такое поведение крайне не рекомендуется
                использовать. Для корректной работы приложений с базой данных желательно управлять
                транзакциями вручную, то есть явно вызывать методы
                    <function>StartTransaction</function>, <function>Commit</function> и
                    <function>Rollback</function> компонента
                <classname>TFDTransaction</classname>.</para>
            <para>
                <table>
                    <?dbfo keep-together='auto'?>
                    <title>Основные свойства компонента TFDTransaction</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Свойство</entry>
                                <entry align="center">Назначение</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>Connection</entry>
                                <entry><para>Связь с компонентом FDConnection.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.AutoCommit</entry>
                                <entry><para>Управляет автоматическим стартом и завершением
                                        транзакции. Значение по умолчанию True.</para>
                                    <para>Если значение этого свойства установлено в True , то
                                        FireDAC делает следующее:</para>
                                    <para>Запускается транзакция (если требуется) перед выполнением
                                        каждой SQL команды, и завершает транзакцию после выполнения
                                        SQL команды. Если команда выполнится успешно, то транзакция
                                        будет завершена как COMMIT, иначе — ROLLBACK.</para>
                                    <para>Если приложение вызывает метод StartTransaction, то
                                        автоматическое управление транзакциями будет отключено, до
                                        тех пор, пока транзакция не завершится как Commit или
                                        Rollback.</para>
                                    <para>При использовании Firebird автоматическое управление
                                        транзакциями эмулируется самими компонентами
                                    FireDAC.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.AutoStart</entry>
                                <entry><para>Управляет автоматическим запуском транзакции. По
                                        умолчанию True.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.AutoStop</entry>
                                <entry><para>Управляет автоматическим завершением транзакции. По
                                        умолчанию True.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.DisconnectAction</entry>
                                <entry><para>Действие, которое будет выполнено при закрытии
                                        соединения, если транзакция активна. Значение по умолчанию
                                        xdCommit. Возможны следующие варианты:<itemizedlist>
                                            <listitem>
                                                <para>xdNone — ничего не будет сделано. Действие
                                                  будет отдано на откуп СУБД;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xdCommit — подтверждение транзакции;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xdRollback — откат транзакции.</para>
                                            </listitem>
                                        </itemizedlist></para>
                                    <para>В других компонентах доступа значение по умолчанию для
                                        подобного свойства xdRollback. Поэтому необходимо выставлять
                                        это свойство вручную в то значение, которое действительно
                                        требуется.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>Options.EnableNested</entry>
                                <entry><para>Управляет вложенными транзакциями. Значение по
                                        умолчанию True.</para>
                                    <para>Когда транзакция активна, то следующий вызов
                                        StartTransaction создаст вложенную транзакцию. FireDAC
                                        эмулирует вложенные транзакции, используя точки сохранения,
                                        если СУБД не поддерживает вложенные транзакции в явном виде.
                                        Чтобы отключить вложенные транзакции, установите
                                        EnableNested в False, и последующий вызов StartTransaction
                                        вызовет исключение.</para>
                                    <para>Firebird не поддерживает вложенные транзакции в явном
                                        виде.</para></entry>
                            </row>
                            <row>
                                <entry>Options.Isolation</entry>
                                <entry><para>Определяет уровень изолированности транзакции. Это
                                        самое важное свойство транзакции. Значение по умолчанию
                                        xiReadCommited. Возможны следующие варианты:<itemizedlist>
                                            <listitem>
                                                <para>xiUnspecified – используется уровень изоляции
                                                  по умолчанию для вашей СУБД (в Firebird это
                                                  SNAPSHOT, т.е. с параметрами read write
                                                  concurrency wait);</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiDirtyRead – этого уровня изолированности в
                                                  Firebird не существует поэтому вместо него будет
                                                  использован READ COMMITED;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiReadCommited – уровень изолированности READ
                                                  COMMITED. В Firebird такая транзакция стартует с
                                                  параметрами read write read_committed rec_version
                                                  nowait;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiRepeatableRead – этого уровня
                                                  изолированности в Firebird не существует поэтому
                                                  вместо него будет использован SNAPSHOT;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiSnapshot – уровень изолированности SNAPSHOT
                                                  . В Firebird такая транзакция стартует с
                                                  параметрами read write concurrency wait;</para>
                                            </listitem>
                                            <listitem>
                                                <para>xiSerializable – уровень изолированности
                                                  SERIALIZABLE . На самом деле в Firebird не
                                                  существует транзакции с данным уровнем
                                                  изолированности, но он эмулируется запуском
                                                  транзакции с параметрами read write consistency
                                                  wait.</para>
                                            </listitem>
                                        </itemizedlist></para></entry>
                            </row>
                            <row>
                                <entry>Options.Params</entry>
                                <entry><para>Специфичные для СУБД параметры транзакции. В настоящее
                                        время используется только для Firebird и Interbase. Возможны
                                        комбинации из следующих значений:<itemizedlist
                                            spacing="compact">
                                            <listitem>
                                                <para>read</para>
                                            </listitem>
                                            <listitem>
                                                <para>write</para>
                                            </listitem>
                                            <listitem>
                                                <para>read_commited</para>
                                            </listitem>
                                            <listitem>
                                                <para>concurrency</para>
                                            </listitem>
                                            <listitem>
                                                <para>consistency</para>
                                            </listitem>
                                            <listitem>
                                                <para>wait</para>
                                            </listitem>
                                            <listitem>
                                                <para>nowait</para>
                                            </listitem>
                                            <listitem>
                                                <para>rec_version</para>
                                            </listitem>
                                            <listitem>
                                                <para>no rec_version</para>
                                            </listitem>
                                        </itemizedlist></para></entry>
                            </row>
                            <row>
                                <entry>Options.ReadOnly</entry>
                                <entry><para>Указывает является ли транзакция только для чтения. По
                                        умолчанию False . Если установлено в True , то любые
                                        изменения в рамках текущей транзакции невозможны, в Firebird
                                        в этом случае отсутствует значение read в параметрах
                                        транзакции.</para>
                                    <para>Установка этого свойства в True позволяет СУБД
                                        оптимизировать использование ресурсов.</para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>В отличие от других СУБД в Firebird и Interbase разрешено использовать сколько
                угодно компонентов <classname>TFDTransaction</classname> привязанных к одному
                соединению. В нашем приложении мы будем использовать одну общую читающую транзакцию
                для всех справочников и оперативных журналов, и по одной пишущей транзакции на
                каждый справочник/журнал.</para>
            <para>В нашем приложении мы не будем полагаться на автоматический старт и завершение
                транзакций, а потому во всех транзакциях Options.AutoCommit = False,
                Options.AutoStart = False и Options.AutoStop = False.</para>
            <para>Поскольку читающая транзакция общая для всех справочников и журналов, то удобно
                разместить её в главном дата модуле. Для обычной работы (показ данных в гриде и
                т.п.) обычно используются режим изолированости READ COMMITED (Options.Isolation =
                xiReadCommited), т.к. он позволяет транзакции видеть чужие, committed изменения базы
                данных просто путём повторного выполнения запросов (перечитывания данных). Поскольку
                эта транзакция используется только для чтения, установим свойство Options.ReadOnly в
                значение True. Таким образом, наша транзакция будет иметь параметры read
                read_commited rec_version. Транзакция с такими параметрами в Firebird может быть
                открытой сколь угодно долгое время (дни, недели, месяцы), без блокирования других
                транзакций или влияния на накопление мусора в базе данных (потому что на самом деле,
                на сервере такая транзакция стартует как committed).</para>
            <note>
                <para>Такую транзакцию нельзя использовать для отчётов (особенно если они используют
                    несколько последовательных запросов), потому что транзакция с режимом
                    изолированности READ COMMITED во время перечитывания данных будет видеть все
                    новые committed-изменения.</para>
                <para>Для отчётов рекомендуется использовать короткую транзакцию только для чтения с
                    режимом изолированности SNAPSHOT (Options.Isolation = xiSnapshot и
                    Options.ReadOnly= True). В данном примере работа с отчётами не
                    рассматривается.</para>
            </note>
            <para>Стартуем читающую транзакцию сразу после успешной установки соединения с базой
                данных, вызвав trRead.StartTransaction в событии OnCreate главного датамодуля, и
                завершаем перед закрытием соединения, вызвав tRead.Commit в событии OnDestroy
                главного датамодуля. Значение свойства Options.DisconnectAction равное xdCommit по
                умолчанию, подходит для транзакции только для чтения.</para>
            <para>Пишущая транзакция будет отдельной для каждого справочника/журнала. Её мы
                разместим на форме, которая относится непосредственно к нужному журналу. Пишущая
                транзакция должна быть максимально короткой для того, чтобы не удерживать Oldest
                Active Transaction, которая не даёт собрать мусор, что в свою очередь приводит к
                деградации производительности. Поскольку пишущая транзакция очень короткая мы можем
                использовать уровень изолированности SNAPSHOT. Таким образом, наша пишущая
                транзакция будет иметь параметры Options.ReadOnly=False и Options.Isolation =
                xiSnapshot. Для пишущих транзакций значение свойства Options.DisconnectAction по
                умолчанию не подходит, его необходимо выставить в значение xdRollback.</para>
        </section>
        <section>
            <title>Датасеты</title>

            <para>Работать с данными в FireDac можно при помощи компонент
                    <classname>TFDQuery</classname>, <classname>TFDTable</classname>,
                    <classname>TFDStoredProc</classname>, <classname>TFDCommand</classname>, но
                    <classname>TFDCommand</classname> не является датасетом.</para>
            <para><classname>TFDQuery</classname>, <classname>TFDTable</classname> и
                    <classname>TFDStoredProc</classname> унаследованы от
                    <classname>TFDRdbmsDataSet</classname>. Помимо наборов данных для работы
                непосредственно с базой данных, в FireDac существует также компонент
                    <classname>TFDMemTable</classname>, который предназначен для работы с набором
                данных в памяти, является аналогом <classname>TClientDataSet</classname>.</para>
            <para>Основным компонентом для работы с наборами данных является
                    <classname>TFDQuery</classname>. Возможностей этого компонента хватает
                практически для любых целей. Компоненты <classname>TFDTable</classname> и
                    <classname>TFDStoredProc</classname> всего лишь модификации, либо чуть
                расширенные, либо усеченные. Мы не будем их рассматривать и применять в нашем
                приложении. При желании вы можете ознакомиться с ними в документации по
                FireDac.</para>
            <para>Назначение компонента — буферизация записей, выбираемых оператором SELECT, для
                представления этих данных в Grid, а также для обеспечения "редактируемости" записи
                (текущей в буфере (гриде)). В отличие от компонента
                    <classname>IBX.TIBDataSet</classname> компонент <classname>TFDQuery</classname>
                не содержит свойств <property>RefreshSQL</property>, <property>InsertSQL</property>,
                    <property>UpdateSQL</property> и <property>DeleteSQL</property>. Вместо этого
                «редактируемость» обеспечивается компонентом <classname>TFDUpdateSQL</classname>,
                который устанавливается в свойство <property>UpdateObject</property>.</para>
            <note>
                <para>В ряде случаев можно сделать компонент <classname>TFDQuery</classname>
                    редактируемым без установки свойства <property>UpdateObject</property> и
                    прописывания запросов Insert/Update/Delete, просто установив свойство
                    UpdateOptions.RequestLive = True, при этом модифицирующие запросы будут
                    сгенерированы автоматически. Однако такой подход имеет множество ограничений на
                    основной SELECT запрос, поэтому не стоит полагаться на него. </para>
            </note>
            <para>
                <table>
                    <?dbfo keep-together='auto'?>
                    <title>Основные свойства компонента TFDQuery</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Свойство</entry>
                                <entry align="center">Назначение</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>Connection</entry>
                                <entry><para>Связь с компонентом FDConnection.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>MasterSource</entry>
                                <entry>
                                    <para>Ссылка на Master-источник данных (TDataSource) для
                                        FDQuery, используемого в качестве Detail.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>Transaction</entry>
                                <entry>
                                    <para>Транзакция, в рамках которой будет выполняться запрос,
                                        прописанный в свойстве SQL. Если свойство не указано будет
                                        использоваться транзакция по умолчанию для
                                        подключения.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateObject</entry>
                                <entry>
                                    <para>Связь с компонентом FDUpdateSQL, который обеспечивает
                                        «редактируемость» набора данных, когда SELECT запрос не
                                        отвечает требованиям для автоматического формирования
                                        модифицирующих запросов при установке
                                        UpdateOptions.RequestLive = True.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateTransaction</entry>
                                <entry>
                                    <para>Транзакция, в рамках которой будут выполняться
                                        модифицирующие запросы. Если свойство не указано, будет
                                        использована транзакция из свойства Transaction.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.CheckRequired</entry>
                                <entry>
                                    <para>Если свойство CheckRequired установлено в True, то FireDac
                                        контролирует свойство Required соответвующих полей, т.е.
                                        полей с ограничением NOT NULL. По умолчанию установлено в
                                        True.</para>
                                    <para>Если CheckRequired=True и в поле имеющее свойство
                                        Required=True не присвоено значение, то при вызове метода
                                        Post будет возбуждено исключение. Это может быть
                                        нежелательно в том случае, если значение этого поля может
                                        быть присвоено позже в BEFORE триггерах.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.EnableDelete</entry>
                                <entry>
                                    <para>Определяет, позволяется ли удаление записи из набора
                                        данных. Если EnableDelete=False, то при вызове метода Delete
                                        будет возбуждено исключение.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.EnableInsert</entry>
                                <entry>
                                    <para>Определяет, позволяется ли вставка записи в набор данных.
                                        Если EnableInsert=False, то при вызове метода Insert/Append
                                        будет возбуждено исключение.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.EnableUpdate</entry>
                                <entry>
                                    <para>Определяет, позволяется ли изменение записи в наборе
                                        данных. Если EnableUpdate=False, то при вызове метода Edit
                                        будет возбуждено исключение.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.FetchGeneratorsPoint</entry>
                                <entry>
                                    <para>Управляет моментом получения следующего значения
                                        генератора указанного в свойстве UpdateOptions.GeneratorName
                                        или свойстве GeneratorName автоинкрементного поля
                                        AutoGenerateValue = arAutoInc. Имеет следующие варианты значений:<itemizedlist>
                                            <listitem>
                                                <para>gpNone – значение генератора не
                                                  извлекается;</para>
                                            </listitem>
                                            <listitem>
                                                <para>gpImmediate – следующее значение генератора
                                                  извлекается сразу после вызова метода
                                                  Insert/Append;</para>
                                            </listitem>
                                            <listitem>
                                                <para>gpDeffered – следующее значение генератора
                                                  извлекается до публикации новой записи в базе
                                                  данных, т.е. во время выполнения методов Post или
                                                  ApplyUpdates.</para>
                                            </listitem>
                                        </itemizedlist> Значение по умолчанию gpDeffered. </para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.GeneratorName</entry>
                                <entry>
                                    <para>Имя генератора для извлечения следующего значения
                                        автоинкрементного поля.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>UpdateOptions.ReadOnly</entry>
                                <entry>
                                    <para>Указывает, является ли набор данных только для чтения. По
                                        умолчанию False. Если значение этого свойства установлено в
                                        True, то значения свойств EnableDelete, EnableInsert и
                                        EnableUpdate будут автоматически выставлены в False.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>UpdateOptions.RequestLive</entry>
                                <entry>
                                    <para>Установка RequestLive в True делает запрос «живым», т.е.
                                        редактируемым, если это возможно. При этом запросы
                                        Insert/Update/Delete будут сгенерированы автоматически. Эта
                                        опция накладывает множество ограничений на SELECT запрос,
                                        введена для обратной совместимости с BDE и не
                                        рекомендуется.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>UpdateOptions.UpdateMode</entry>
                                <entry>
                                    <para>Отвечает за проверку модификации записи. Это свойство
                                        позволяло контролировать возможное "перекрытие" обновлений
                                        для случаев, когда пользователь выполняет редактирование
                                        записи "долго", а другой пользователь может успеть
                                        отредактировать эту же запись и сохранить её раньше. То
                                        есть, первый пользователь на этапе редактирования даже не
                                        будет знать, что запись уже изменилась, возможно не один
                                        раз, и сумеет "затереть" эти обновления своим:<itemizedlist>
                                            <listitem>
                                                <para>upWhereAll — проверка на существование записи
                                                  по первичному ключу + проверка всех столбцов на
                                                  старые значения. Например
                                                  <programlisting language="sql">
update table 
set ... 
where pkfield = :old_ pkfield 
  and client_name = :old_client_name 
  and info = :old_info 
...                                                     
                                                </programlisting>
                                                  То есть, в данном случае запрос поменяет
                                                  информацию в записи только в том случае, если
                                                  запись до нас никто не успел изменить. Особенно
                                                  это важно, если существуют взаимозависимости между
                                                  значениями столбцов — например, минимальная и
                                                  максимальная зарплата, и т.п. </para>
                                            </listitem>
                                            <listitem>
                                                <para>upWhereCahnged — проверка записи на
                                                  существование по первичному ключу + плюс проверка
                                                  на старые значения только изменяемых столбцов.
                                                  <programlisting language="sql">
update table 
set ... 
where pkfield = :old_ pkfield 
  and client_name = :old_client_name 
  and info = :old_info 
...                                                     
                                                </programlisting>
                                                </para>
                                            </listitem>
                                            <listitem>
                                                <para>upWhereKeyOnly (по умолчанию) — проверка
                                                  записи на существование по первичному
                                                  ключу.</para>
                                            </listitem>
                                        </itemizedlist>
                                    </para>
                                    <para>Последняя проверка соответствует генерируемому
                                        автоматически для UpdateSQL запросу. Поэтому, при возможных
                                        конфликтах обновлений в многопользовательской среде
                                        необходимо дописывать условия к where самостоятельно. И,
                                        разумеется, также необходимо при реализации аналога
                                        upWhereChanged удалять лишние изменения столбцов в update
                                        table set ... - то есть, оставлять в перечне set только
                                        действительно изменённые столбцы, иначе запрос перепишет
                                        чужие обновления этой записи. Как вы понимаете, это означает
                                        необходимость динамического конструирования запроса
                                        UpdateSQL.</para>
                                    <para>Если вы хотите задать настройки обнаружения конфликтов
                                        обновления индивидуально для каждого поля, то вы можете
                                        воспользоваться свойством ProviderFlags для каждого
                                        поля.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>CachedUpdates</entry>
                                <entry>
                                    <para>Определяет, будет ли набор данных кэшировать изменения без
                                        немедленного внесения их в базу данных. Если это свойство
                                        установлено в значение True, то любые изменения
                                        (Insert/Post, Update/Post, Delete) вносятся в базу данных не
                                        сразу, а сохраняется в специальном журнале. Приложение
                                        должно явно применить изменения, вызвав метод ApplyUpdates.
                                        В этом случае все изменения будут выполнены в течение малого
                                        промежутка времени и в одной короткой транзакции. По
                                        умолчанию значение этого свойства False.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>SQL</entry>
                                <entry>
                                    <para>Содержит SQL запрос. Если это свойство содержит SELECT
                                        запрос, то его необходимо выполнять методом Open. В
                                        противном случае необходимо использовать методы Execute или
                                        ExecSQL.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
        </section>
        <section>
            <title>Компонент TFDUpdateSQL</title>

            <para>Компонент TFDUpdateSQL позволяет переопределять SQL команды, сгенерированные для
                автоматического обновления набора данных. Он может быть использован для внесения
                обновлений в компоненты TFDQuery, TFDTable и TFDStoredProc. Использование
                TFDUpdateSQL является необязательным для компонентов TFDQuery и TFDTable, потому что
                эти компоненты способны автоматически генерировать команды для публикации обновлений
                из набора данных в СУБД. Использование TFDUpdateSQL является обязательным для
                возможности обновления набора данных TFDStoredProc. Рекомендуем применять его
                всегда, даже для самых простых случаев, чтобы получать полный контроль над тем какие
                запросы выполняются в вашем приложении.</para>

            <para>Для того чтобы указать SQL команды на этапе проектирования, используйте редактор
                TFDUpdateSQL времени проектирования, который вызывается двойным щелчком по
                компоненту.</para>

            <note>
                <para>Для работы многих редакторов времени проектирования FireDac требуется, чтобы
                    было активно подключение к базе данных (TFDConnection.Connected = True) и
                    транзакция находилась в режиме автостарта (TFDTransaction.Options.AutoStart =
                    True). Но такие настройки могут мешать при работе приложения. Например,
                    пользователь должен входить в программу под своим логином, а TFDConnection
                    подключается к базе данных под SYSDBA. Поэтому после каждого использования
                    редакторов времени проектирования рекомендуем проверять свойство
                    TFDConnection.Connected и сбрасывать его. Кроме того, вам придётся включать и
                    выключать автостарт транзакции предназначенной только для чтения.</para>
            </note>

            <para>
                <figure>
                    <title>Настройка TFDUpdateSQL. Генерация запросов.</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-fdupdatesql.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Настройка TFDUpdateSQL. Генерация запросов.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>На закладке Generate вы можете упростить себе задачу по написанию
                Insert/Update/Delete/Refresh запросов. Для этого выберете таблицу для обновления, её
                ключевые поля, поля для обновления, и поля которые будут перечитаны после
                обновления, и нажмите на кнопку «Generate SQL». После чего запросы будут
                сгенерированы автоматически, и вы перейдёте на закладку «SQL Commands», где можете
                поправить каждый из запросов. <figure>
                    <title>Настройка TFDUpdateSQL. SQL команды.</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-fdupdatesql-sql.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Настройка TFDUpdateSQL. SQL команды.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <note>
                <para>Поскольку product_id не включено в Updating Fields, оно отсутствует в
                    генерируемом запросе insert. Предполагается, что этот столбец заполняется
                    автоматически триггером (с генератором), или же этот это IDENTITY столбец
                    (начиная с Firebird 3.0). При получении значения генератора для этого столбца с
                    сервера, рекомендуется вручную добавить столбец PRODUCT_ID в предложение
                    RETURNING оператора INSERT.</para>
            </note>
            <para>На закладке Options находятся некоторые свойства, которые могут повлиять на
                генерацию запросов. Эти свойства не относятся к самому компоненту TFDUpdateSQL, а
                являются ссылками на свойства UpdateOptions набора данных, у которого указан текущий
                TFDUpdateSQL в свойстве UpdateObject. Так сделано исключительно ради
                удобства.</para>
            <para>
                <table>
                    <?dbfo keep-together='auto'?>
                    <title>Основные свойства компонента TFDUpdateSQL</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Свойство</entry>
                                <entry align="center">Назначение</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>Connection</entry>
                                <entry><para>Связь с компонентом FDConnection.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>DeleteSQL</entry>
                                <entry><para>SQL запрос для удаления записи.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>FetchRowSQL</entry>
                                <entry><para>SQL запрос для возврата одной текущей (обновлённой,
                                        вставленной) записи. (RefreshSQL)</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>InsertSQL</entry>
                                <entry><para>SQL запрос для вставки записи.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>LockSQL</entry>
                                <entry><para>SQL запрос для блокировки одной текущей записи. (FOR
                                        UPDATE WITH LOCK).</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>ModifySQL</entry>
                                <entry><para>SQL запрос для модификации записи.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>UnlockSQL</entry>
                                <entry><para>SQL запрос для разблокировки текущей записи. В Firebird
                                        не применяется.</para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>Как вы уже заметили, у компонента TFDUpdateSQL нет свойства Transaction. Это
                потому, что компонент не выполняет модифицирующие запросы непосредственно, а лишь
                заменяет автоматически сгенерированные запросы в наборе данных, который является
                предком TFDRdbmsDataSet.</para>
        </section>
        <section>
            <title>Компонент TFDCommand</title>

            <para>Компонент TFDCommand предназначен для выполнения SQL запросов. Он не является
                предком TDataSet, а потому удобен лишь для выполнения SQL запросов, не возвращающих
                набор данных.</para>
            <para>
                <table>
                    <?dbfo keep-together='auto'?>
                    <title>Основные свойства компонента TFDCommand</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Свойство</entry>
                                <entry align="center">Назначение</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>Connection</entry>
                                <entry><para>Связь с компонентом FDConnection.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>Transaction</entry>
                                <entry>
                                    <para>Транзакция, в рамках которой будет выполняться SQL
                                        команда.</para>
                                </entry>
                            </row>
                            <row valign="middle">
                                <entry>CommandKind</entry>
                                <entry><para>Тип команды. <itemizedlist>
                                            <listitem>
                                                <para>skUnknown – неизвестен. В этом случае тип
                                                  команды будет определятся автоматически по тексту
                                                  команды внутренним парсером;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skStartTransaction – команда для старта
                                                  транзакции;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skCommit – команда завершения и подтверждения
                                                  транзакции;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skRollback – команда завершения и отката
                                                  транзакции;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skCreate – команда CREATE … для создания
                                                  нового объекта метаданных;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skAlter – команда ALTER … для модификации
                                                  объекта метаданных;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skDrop – команда DROP … для удаления объекта
                                                  метаданных;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skSelect – команда SELECT для выборки
                                                  данных;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skSelectForLock – команда SELECT … WITH LOCK
                                                  для блокировки выбранных строк;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skInsert – команда INSERT … для вставки новой
                                                  записи;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skUpdate – команда UPDATE … для модификации
                                                  записей;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skDelete – команда DELETE … для удаления
                                                  записей;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skMerge – команда MERGE INTO …</para>
                                            </listitem>
                                            <listitem>
                                                <para>skExecute – команда EXECUTE PROCEDURE или
                                                  EXECUTE BLOCK;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skStoredProc – вызов хранимой
                                                  процедуры;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skStoredProcNoCrs – вызов хранимой процедуры
                                                  не возвращающей курсор;</para>
                                            </listitem>
                                            <listitem>
                                                <para>skStoredProcWithCrs – вызов хранимой процедуры
                                                  возвращающей курсор.</para>
                                            </listitem>
                                        </itemizedlist> Обычно тип команды определяется
                                        автоматически по тексту SQL запроса.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>CommandText</entry>
                                <entry>
                                    <para>Текст SQL запроса.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
        </section>

        <section>
            <title>Создание справочников</title>

            <para>В нашем приложении мы создадим два справочника: справочник товаров и справочник
                заказчиков. Каждый из справочников представляет собой форму с сеткой TDBGrid,
                источником данных TDataSource, набором данных TFDQuery, пишущей транзакции
                TFDTransaction.</para>

            <para>Рассмотрим создание справочников на примере справочника заказчиков.</para>

            <para>
                <figure>
                    <title>Форма справочника Customers</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-customers-form.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Форма справочника Customers.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <note>
                <para>Компонент trRead не виден, потому что находится не на форме, а в модуле
                    dmMain.</para>
            </note>

            <para>Разместим компонент TFDQuery на форме с именем qryCustomers. Этот набор данных
                будет указан в свойстве DataSet источника данных DataSource. В свойстве Transaction
                укажем ReadOnly транзакцию trRead, которая была создана в главном датамодуле
                проекта. В свойстве UpdateTransaction указываем транзакцию trWrite, в свойстве
                Connection — соединение расположенное в главном датамодуле. В свойстве SQL напишем
                следующий запрос:
                <programlisting language="sql"> 
SELECT
    customer_id,
    name,
    address,
    zipcode,
    phone
FROM
    customer
ORDER BY name
                </programlisting>
            </para>

            <para>Пишущая транзакция trWrite должна быть максимально короткой, и иметь режим
                изолированности SNAPSHOT. Мы не будем полагаться на автоматический старт и
                завершение транзакции, а будем стартовать и завершать транзакцию явно. Таким
                образом, наша транзакция должна иметь следующие свойства:
                <programlisting> 
Options.AutoStart = False
Options.AutoCommit = False
Options.AutoStop = False
Options.DisconnectAction = xdRollback
Options.Isolations = xiSnapshot
Options.ReadOnly = False
                </programlisting>
            </para>

            <para>На самом деле необязательно устанавливать режим изолированности SNAPSHOT для
                простых INSERT/UPDATE/DELETE. Однако если у таблицы есть сложные триггеры, или
                вместо простых запросов INSERT/UPDATE/DELETE вызывается хранимая процедура, то
                желательно использовать уровень изолированности SNAPSHOT.</para>

            <para>Дело в том, что уровень изолированности READ COMMITED не обеспечивает атомарности
                оператора в пределах одной транзакции (statement read consistency). Таким образом,
                оператор SELECT может возвращать данные, которые попали в базу данных после начала
                выполнения запроса. В принципе режим изолированности SNAPSHOT можно рекомендовать
                почти всегда, если транзакция будет короткой.</para>

            <para>Для возможности редактирования набора данных необходимо заполнить свойства
                InsertSQL, ModifySQL, DeleteSQL и FetchRowSQL. Эти свойства могут быть сгенерированы
                мастером, но после этого может потребоваться некоторая правка. Например вы можете
                дописать предложение RETURNING, удалить модификацию некоторых столбцов, или же вовсе
                заменить автоматически сгенерированный запрос на вызов хранимой процедуры.</para>

            <formalpara>
                <title>InsertSQL:</title>

                <para>
                    <programlisting language="sql"> 
INSERT INTO customer (customer_id,
                      name,
                      address,
                      zipcode,
                      phone)
VALUES (:new_customer_id,
        :new_name,
        :new_address,
        :new_zipcode,
        :new_phone)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>ModifySQL:</title>

                <para>
                    <programlisting language="sql"> 
UPDATE customer
SET name = :new_name,
    address = :new_address,
    zipcode = :new_zipcode,
    phone = :new_phone
WHERE (customer_id = :old_customer_id)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>DeleteSQL:</title>

                <para>
                    <programlisting language="sql"> 
DELETE FROM customer
WHERE (customer_id = :old_customer_id)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>FetchRowSQL:</title>

                <para>
                    <programlisting language="sql"> 
SELECT
    customer_id,
    name,
    address,
    zipcode,
    phone
FROM
    customer
WHERE customer_id = :old_customer_id
                </programlisting>
                </para>
            </formalpara>

            <para>В этом справочнике будем получать значение генератора перед вставкой записи в
                таблицу. Для этого необходимо установить значение свойств компонента TFDQuery в
                следующие значения UpdateOptions.GeneratorName = GEN_CUSTOMER_ID и
                UpdateOptions.AutoIncFields = CUSTOMER_ID. Есть другой способ, когда значение
                генератора (автоинкрементного поля) возвращается после выполнения INSERT запроса с
                помощью предложения RETURNING. Этот способ будет показан позже.</para>

            <para>Для добавления новой записи и редактирования существующей принято использовать
                модальные формы, по закрытию которых с результатом mrOK изменения вносятся в базу
                данных. Обычно для создания таких форм используются DBAware компоненты, которые
                позволяют отображать значения некоторого поля в текущей записи и немедленно вносить
                изменения в текущую запись набора данных в режимах Insert/Edit, т.е. до Post. Но
                перевести набор данных в режим Insert/Edit можно только стартовав пишущую
                транзакцию. Таким образом, если кто-то откроет форму для внесения новой записи и
                уйдёт на обед, не закрыв эту форму, у нас будет висеть активная транзакция до тех
                пор, пока сотрудник не вернётся с обеда и не закроет форму. Это в свою очередь
                приведёт к тому, что активная транзакция будет удерживать сборку мусора, что позже
                приведёт к снижению производительности. Эту проблему можно решить одним из двух способов:<orderedlist>
                    <listitem>
                        <para>Использовать режим CachedUpdates , что позволяет держать транзакцию
                            активной только на очень короткий промежуток времени, а именно на время
                            внесения изменений.</para>
                    </listitem>
                    <listitem>
                        <para>Отказаться от применения DBAware компонентов. Однако этот путь
                            потребует от вас дополнительных усилий.</para>
                    </listitem>
                </orderedlist></para>

            <para>Мы покажем применение обоих способов. Для справочников гораздо удобнее
                использовать первый способ. Рассмотрим код редактирования записи поставщика
                <programlisting language="delphi"> 
procedure TCustomerForm.actEditRecordExecute(Sender: TObject);
var
  xEditor: TEditCustomerForm;
begin
  xEditor := TEditCustomerForm.Create(Self);
  try
    xEditor.OnClose := CustomerEditorClose;
    xEditor.CustomerForm := Self;
    xEditor.Caption := 'Edit customer';
    qryCustomer.CachedUpdates := True;
    qryCustomer.Edit;
    xEditor.ShowModal;
  finally
    xEditor.Free;
  end;
end;
                </programlisting>
            </para>
            <para>По коду видно, что перед переводом набора данных в режим редактирования мы
                устанавливаем ему режим CachedUpdates, а вся логика обработки редактирования
                происходит в модальной форме.
                <programlisting language="delphi"> 
procedure TCustomerForm.CustomerEditorClose (Sender: TObject;
  var Action: TCloseAction);
begin
  if TForm(Sender).ModalResult &lt;&gt; mrOK then
  begin
    // отменяем все изменения
    qryCustomer.Cancel;
    qryCustomer.CancelUpdates;
    // возвращаем набор данных в обычный режим обновления
    qryCustomer.CachedUpdates := False;
    // и позволяем закрыть форму
    Action := caFree;
    Exit;
  end;

  try
    // подтверждаем изменения на уровне набора данных
    qryCustomer.Post;
    // стартуем транзакцию
    trWrite.StartTransaction;
    // если в наборе данных есть изменения
    if (qryCustomer.ApplyUpdates = 0) then
    begin
      // записываем их в БД
      qryCustomer.CommitUpdates;
      // и подтверждаем транзакцию
      trWrite.Commit;
    end
    else begin
      raise Exception.Create(qryCustomer.RowError.Message);
    end;
    qryCustomer.CachedUpdates := False;
    Action := caFree;
  except
    on E: Exception do
    begin
      // откатываем транзакцию
      if trWrite.Active then
        trWrite.Rollback;
      Application.ShowException(E);
      // Не закрываем окно, даём возможность исправить ошибку
      Action := caNone;
    end;
  end;
end;
                </programlisting>
            </para>
            <para>Из кода видно, что до тех пор, пока кнопка OK не нажата, пишущая транзакция не
                стартует вовсе. Таким образом, пишущая транзакция активна только на время переноса
                данных из буфера набора данных в базу данных. Поскольку мы копим в буфере не более
                одной записи, транзакция будет активна очень короткое время, что и
                требовалось.</para>

            <para>Справочник товаров делается аналогично справочнику заказчиков. Однако в нём мы
                продемонстрируем другой способ получения автоинкрементных значений.</para>

            <para>Основной запрос будет выглядеть следующим образом:
                <programlisting language="sql"> 
SELECT
    product_id,
    name,
    price,
    description
FROM product
ORDER BY name
                </programlisting>
            </para>
            <para>Свойство компонента TFDUpdateSQL.InsertSQL будет содержать следующий запрос:
                <programlisting language="sql"> 
INSERT INTO PRODUCT
(NAME, PRICE, DESCRIPTION)
VALUES (:NEW_NAME, :NEW_PRICE, :NEW_DESCRIPTION)
RETURNING PRODUCT_ID
                </programlisting>
            </para>
            <para>В этом запросе появилось предложение RETURNING, которое вернёт значение поля
                PRODUCT_ID после изменения его в BEFORE INSERT триггере. В этом случае не имеет
                смысла выставлять значение свойства UpdateOptions.GeneratorName. Кроме того, полю
                PRODUCT_ID необходимо выставить свойства Required = False и ReadOnly = True,
                поскольку значение этого свойства не вносится напрямую. В остальном всё примерно
                также как это организовано для справочника производителей.</para>
        </section>

        <section>
            <title>Создание журналов</title>

            <para>В нашем приложении будет один журнал «Счёт-фактуры». В отличие от справочников
                журналы содержат довольно большое количество записей и являются часто
                пополняемыми.</para>

            <para>Счёт-фактура — состоит из заголовка, где описываются общие атрибуты (номер, дата,
                заказчик …), и строк счёт-фактуры со списком товаром, их количеством, стоимостью и
                т.д. Для таких документов удобно иметь два грида: в главном отображаются данные о
                шапке документа, а в детализирующем — список товаров. Таким образом, на форму
                документа нам потребуется поместить два компонента TDBGrid, к каждому из которых
                привязать свой TDataSource, которые в свою очередь будут привязаны к своим TFDQuery.
                В нашем случае набор данных с шапками документы будет называться qryInvoice, а со
                строками документа qryInvoiceLine.</para>

            <para>В свойстве Transaction обоих наборов данных укажем ReadOnly транзакцию trRead,
                которая была создана в главном датамодуле проекта. В свойстве UpdateTransaction
                указываем транзакцию trWrite, в свойстве Connection — соединение, расположенное в
                главном датамодуле.</para>

            <para>Большинство журналов содержат поле с датой создания документа. Чтобы уменьшить
                количество выбираемых данных обычно принято вводить такое понятие как рабочий период
                для того, чтобы уменьшить объём данных передаваемый на клиента. Рабочий период — это
                диапазон дат, внутри которого требуются рабочие документы. Поскольку приложение
                может содержать более одного журнала, то имеет смысл разместить переменные,
                содержащие дату начала и окончания рабочего периода, в глобальном датамодуле dmMain,
                который, так или иначе, используется всеми модулями, работающими с БД. При старте
                приложения рабочий период обычно инициализируется датой начала и окончания текущего
                квартала (могут быть другие варианты). В ходе работы приложения можно изменить
                рабочий период по желанию пользователя.</para>

            <para>
                <figure>
                    <title>Форма журнала Invoices</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-invoices-form.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Форма журнала Invoices.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Поскольку чаще всего требуются именно последние введённые документы, то имеет
                смысл сортировать их по дате в обратном порядке. С учётом вышесказанного, в свойстве
                SQL набора данных qryInvoice запрос будет выглядеть следующим образом:
                <programlisting language="sql"> 
SELECT
  invoice.invoice_id AS invoice_id,
  invoice.customer_id AS customer_id,
  customer.NAME AS customer_name,
  invoice.invoice_date AS invoice_date,
  invoice.total_sale AS total_sale,
  IIF(invoice.payed=1, 'Yes', 'No') AS payed 
FROM
  invoice
  JOIN customer ON customer.customer_id = invoice.customer_id 
WHERE invoice.invoice_date BETWEEN :date_begin AND :date_end
ORDER BY invoice.invoice_date DESC
                </programlisting>
            </para>

            <para>При открытии этого набора данных необходимо будет инициализировать параметры
                запроса:
                <programlisting language="delphi"> 
qryInvoice.ParamByName('date_begin').AsSqlTimeStamp := dmMain.BeginDateSt;
qryInvoice.ParamByName('date_end').AsSqlTimeStamp := dmMain.EndDateSt;
qryInvoice.Open;
                </programlisting>
            </para>

            <para>Все операции над счёт-фактурой будем производить с помощью хранимых процедур, хотя
                в более простых случаях это можно делать и с помощью обычных запросов
                INSERT/UPDATE/DELETE. </para>

            <para>Каждую хранимую процедуру будем выполнять как отдельный запрос в компонентах
                TFDCommand. Этот компонент не является предком TFDRdbmsDataSet, не буферизирует
                данные и возвращает максимум одну строку результата, поэтому его использование несёт
                меньше накладных расходов для запросов, не возвращающих данные. Поскольку наши
                хранимые процедуры выполняют модификацию данных, то свойство Transaction компонентов
                TFDCommand необходимо установить транзакцию trWrite.</para>

            <note>
                <para>Хранимые процедуры вставки, редактирования и добавления записи можно также
                    разместить в соответствующих свойствах компонента TFDUpdateSQL.</para>
            </note>

            <para>Для работы с шапкой счёт-фактуры предусмотрено четыре операции: добавление,
                редактирование, удаление и установка признака «оплачено». Как только счёт-фактура
                оплачена, мы запрещаем любые её модификации, как в шапке, так и в строках. Это
                сделано на уровне хранимых процедур. Приведём тексты запросов для вызова хранимых
                процедур.</para>

            <formalpara>
                <title>qryAddInvoice.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_add_invoice(
  NEXT VALUE FOR gen_invoice_id, 
  :CUSTOMER_ID, 
  :INVOICE_DATE
)
                </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>qryEditInvoice.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_edit_invoice(
  :INVOICE_ID, 
  :CUSTOMER_ID, 
  :INVOICE_DATE
)
                </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>qryDeleteInvoice.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_delete_invoice(:INVOICE_ID)
                </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>qryPayForInvoice.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_pay_for_inovice(:invoice_id)
                </programlisting>
                </para>
            </formalpara>

            <para>Поскольку наши хранимые процедуры вызываются не из компонента TFDUpdateSQL, то
                после их выполнения необходимо вызвать qryInvoice.Refresh для обновления данных в
                гриде.</para>

            <para>Вызов хранимых процедур, для которых не требуется ввод данных, производится
                следующим образом:
                <programlisting language="delphi"> 
if MessageDlg('Вы действительно хотите удалить счёт фактуру?', mtConfirmation,
  [mbYes, mbNo], 0) = mrYes then
begin
  // Стартуем транзакцию
  trWrite.StartTransaction;
  try
    qryDeleteInvoice.ParamByName('INVOICE_ID').AsInteger :=
      qryInvoice.FieldByName('INVOICE_ID').AsInteger;
    // выполнение хранимой процедуры
    qryDeleteInvoice.Execute;
    // подтверждение транзакции
    trWrite.Commit;
    // обновление данных в гриде
    qryInvoice.Refresh;
  except
    on E: EFDDBEngineException do
    begin
      if trWrite.Active then
        trWrite.Rollback;
      Application.ShowException(E);
    end;
  end;
end;
                </programlisting>
            </para>

            <para>Для добавления новой записи и редактирования существующей, как и в случае со
                справочниками мы будем использовать модальные формы. В данном случае мы не будем
                использовать DBAware компоненты. Ещё одна особенность - для выбора заказчика мы
                будем использовать компонент TButtonedEdit. Он будет отображать наименование
                текущего заказчика, а по нажатию кнопки вызывать модальную форму с гридом для выбора
                заказчика. Конечно, можно было бы воспользоваться чем-то вроде TDBLookupCombobox,
                но, во-первых заказчиков может быть очень много и пролистывать такой выпадающий
                список будет неудобно, во-вторых для поиска нужного заказчика одного названия может
                быть недостаточно.</para>

            <para>
                <figure>
                    <title>Форма редактирования счёт-фактуры</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-editinvoice-form.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Форма редактирования счёт-фактуры.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>В качестве модальной окна для выбора заказчика используем ту же форму, что была
                создана для ввода заказчиков. Код обработчика нажатия кнопки в компоненте
                TButtonedEdit будет выглядеть следующим образом:
                <programlisting language="delphi"> 
procedure TEditInvoiceForm.edtCustomerRightButtonClick(Sender: TObject);
var
  xSelectForm: TCustomerForm;
begin
  xSelectForm := TCustomerForm.Create(Self);
  try
    xSelectForm.Visible := False;
    if xSelectForm.ShowModal = mrOK then
    begin
      FCustomerId := xSelectForm.qryCustomer.FieldByName('CUSTOMER_ID')
        .AsInteger;
      edtCustomer.Text := xSelectForm.qryCustomer.FieldByName('NAME').AsString;
    end;
  finally
    xSelectForm.Free;
  end;
end;
                </programlisting>
            </para>
            <para>Поскольку мы используем не DBAware компоненты, то при вызове формы редактирования
                нам будет необходимо инициализировать код заказчика и его наименование для
                отображения.
                <programlisting language="delphi"> 
procedure TInvoiceForm.actEditInvoiceExecute(Sender: TObject);
var
  xEditor: TEditInvoiceForm;
begin
  xEditor := TEditInvoiceForm.Create(Self);
  try
    xEditor.InvoiceForm := Self;
    xEditor.EditMode := emInvoiceEdit;
    xEditor.Caption := 'Редактирование счёт-фактуры';

    xEditor.InvoiceId := qryInvoice.FieldByName('INVOICE_ID').AsInteger;
    xEditor.SetCustomer(qryInvoice.FieldByName('CUSTOMER_ID').AsInteger,
                        qryInvoice.FieldByName('CUSTOMER_NAME').AsString);
    xEditor.InvoiceDate := qryInvoice.FieldByName('INVOICE_DATE').AsDateTime;

    xEditor.ShowModal;
  finally
    xEditor.Free;
  end;
end;

procedure TEditInvoiceForm.SetCustomer(ACustomerId: Integer;
  const ACustomerName: string);
begin
  FCustomerId := ACustomerId;
  edtCustomer.Text := ACustomerName;
end;
                </programlisting>
            </para>
            <para>Обработку добавления новой счёт-фактуры и редактирование существующей будем
                осуществлять в событии закрытия модальной формы, также, как это сделано для
                справочников. Однако здесь мы уже не будем переводить набор данных в режим
                CachedUpdates, поскольку модификация производится с помощью хранимых процедур, и мы
                не используем DBAware компоненты. </para>
            <para>
                <programlisting language="delphi"> 
procedure TEditInvoiceForm.FormClose(Sender: TObject; var Action: TCloseAction);
var
  xCustomerId: Integer;
begin
  // если форма закрыта не по нажатию кнопки OK, 
  // то вообще ничего не делаем. Транзакция не стартует.
  if ModalResult &lt;&gt; mrOK then
  begin
    Action := caFree;
    Exit;
  end;

  // Выполняем всё в короткой транзакции
  FInvoiceForm.trWrite.StartTransaction;
  try
    if FEditMode = emInvoiceAdd then
    begin
      // если FcustomerId = 0, то прамаетру CUSTOMER_ID выставляем значение NULL 
      if FCustomerId &lt;&gt; 0 then
        FInvoiceForm.qryAddInvoice.ParamByName('CUSTOMER_ID').AsInteger :=
          FCustomerId
      else
        FInvoiceForm.qryAddInvoice.ParamByName('CUSTOMER_ID').Clear;

      FInvoiceForm.qryAddInvoice.ParamByName('INVOICE_DATE').AsSQLTimeStamp :=
        DateTimeToSQLTimeStamp(FInvoiceDate);
      // выполяем хранимую процедуру для вставки записи
      FInvoiceForm.qryAddInvoice.Execute();
    end;
    if FEditMode = emInvoiceEdit then
    begin
      FInvoiceForm.qryEditInvoice.ParamByName('INVOICE_ID').AsInteger :=
        FInvoiceId;
      FInvoiceForm.qryEditInvoice.ParamByName('CUSTOMER_ID').AsInteger :=
        FCustomerId;
      FInvoiceForm.qryEditInvoice.ParamByName('INVOICE_DATE').AsSQLTimeStamp :=
        DateTimeToSQLTimeStamp(FInvoiceDate);
      // выполняем хранимую процедуру для редактирования записи
      FInvoiceForm.qryEditInvoice.Execute();
    end;
    // подтверждение транзакции
    FInvoiceForm.trWrite.Commit;
    // обновление данных в гриде
    FInvoiceForm.qryInvoice.Refresh;

    Action := caFree;
  except
    on E: Exception do
    begin
      if FInvoiceForm.trWrite.Active then
        FInvoiceForm.trWrite.Rollback;
      Application.ShowException(E);
      // Не закрываем модальное окно. Даём пользователю возможность
      // исправить ошибку
      Action := caNone;
    end;
  end;
end;
                </programlisting>
            </para>

            <para>Теперь перейдём к позициям накладной. Набору данных qryInvoiceLine установим
                свойство MasterSource = MasterSource, который привязан к qryInvoice, а свойство
                MasterFields = INVOICE_ID. В свойстве SQL напишем следующий запрос:
                <programlisting language="sql"> 
SELECT
    invoice_line.invoice_line_id AS invoice_line_id,
    invoice_line.invoice_id AS invoice_id,
    invoice_line.product_id AS product_id,
    product.name AS productname,
    invoice_line.quantity AS quantity,
    invoice_line.sale_price AS sale_price,
    invoice_line.quantity * invoice_line.sale_price AS total
FROM
    invoice_line
JOIN product ON product.product_id = invoice_line.product_id
WHERE invoice_line.invoice_id = :invoice_id
                </programlisting>
            </para>
            <para>Все модификации, как и в случае с шапкой счёт-фактуры, будем осуществлять с
                помощью хранимых процедур. Приведём тексты запросов для вызова хранимых
                процедур.</para>
            <formalpara>
                <title>qryAddInvoiceLine.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_add_invoice_line(
  :invoice_id, 
  :product_id, 
  :quantity
)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>qryEditInvoiceLine.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_edit_invoice_line(
  :invoice_line_id,
  :quantity
)
                </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>qryDeleteInvoiceLine.CommandText:</title>

                <para>
                    <programlisting language="sql"> 
EXECUTE PROCEDURE sp_delete_invoice_line(
  :invoice_line_id
)
                </programlisting>
                </para>
            </formalpara>

            <para>Форма для добавления новой записи и редактирования существующей, как и в случае с
                шапкой не будет использовать DBAware. Для выбора товара мы будем использовать
                компонент TButtonedEdit. Код обработчика нажатия кнопки в компоненте TButtonedEdit
                будет выглядеть следующим образом:
                <programlisting language="delphi"> 
procedure TEditInvoiceLineForm.edtProductRightButtonClick(Sender: TObject);
var
  xSelectForm: TGoodsForm;
begin
  // не позволяем изменять товар в режиме редактирования
  // это можно сделать только при добавлении новой позиции
  if FEditMode = emInvoiceLineEdit then
    Exit;

  xSelectForm := TGoodsForm.Create(Self);
  try
    xSelectForm.Visible := False;
    if xSelectForm.ShowModal = mrOK then
    begin
      FProductId := xSelectForm.qryGoods.FieldByName('PRODUCT_ID')
        .AsInteger;
      edtProduct.Text := xSelectForm.qryGoods.FieldByName('NAME').AsString;
      // в данном случае мы копируем также цену по прайсу
      edtPrice.Text := xSelectForm.qryGoods.FieldByName('PRICE').AsString;
    end;
  finally
    xSelectForm.Free;
  end;
end;
                </programlisting>
            </para>
            <para>Поскольку мы используем не DBAware компоненты, то при вызове формы редактирования
                нам будет необходимо инициализировать код товара, его наименование и стоимость для
                отображения.
                <programlisting language="delphi"> 
procedure TInvoiceForm.actEditInvoiceLineExecute(Sender: TObject);
var
  xEditor: TEditInvoiceLineForm;
begin
  xEditor := TEditInvoiceLineForm.Create(Self);
  try
    xEditor.InvoiceForm := Self;
    xEditor.EditMode := emInvoiceLineEdit;
    xEditor.Caption := 'Редактирование позиции';

    xEditor.InvoiceLineId := qryInvoiceLine.FieldByName('INVOICE_LINE_ID').AsInteger;
    xEditor.SetProduct(qryInvoiceLine.FieldByName('PRODUCT_ID').AsInteger,
                       qryInvoiceLine.FieldByName('PRODUCTNAME').AsString,
                       qryInvoiceLine.FieldByName('SALE_PRICE').AsCurrency);
    xEditor.Quantity := qryInvoiceLine.FieldByName('QUANTITY').AsInteger;

    xEditor.ShowModal;
  finally
    xEditor.Free;
  end;
end;

procedure TEditInvoiceLineForm.SetProduct(AProductId: Integer;
  AProductName: string; APrice: Currency);
begin
  FProductId := AProductId;
  edtProduct.Text := AProductName;
  edtPrice.Text := CurrToStr(APrice);
end;
                </programlisting>
            </para>
            <para>Обработку добавления новой позиции и редактирование существующей будем производить
                в событии закрытия модальной формы.
                <programlisting language="delphi"> 
procedure TEditInvoiceLineForm.FormClose(Sender: TObject;
  var Action: TCloseAction);
var
  xCustomerId: Integer;
begin
  // если форма закрыта не по нажатию кнопки OK, 
  // то вообще ничего не делаем. Транзакция не стартует.
  if ModalResult &lt;&gt; mrOK then
  begin
    Action := caFree;
    Exit;
  end;

  // Всё делаем в короткой транзакции
  FInvoiceForm.trWrite.StartTransaction;
  try
    if FEditMode = emInvoiceLineAdd then
    begin
      FInvoiceForm.qryAddInvoiceLine.ParamByName('INVOICE_ID').AsInteger :=
        FInvoiceId;

      if FProductId = 0 then
        raise Exception.Create('Не выбран товар');
        

      FInvoiceForm.qryAddInvoiceLine.ParamByName('PRODUCT_ID').AsInteger :=
        FProductId;
      FInvoiceForm.qryAddInvoiceLine.ParamByName('QUANTITY').AsInteger :=
        FQuantity;
      // Выполняем хранимую процедуру для добавления позиции 
      FInvoiceForm.qryAddInvoiceLine.Execute();
    end;

    if FEditMode = emInvoiceLineEdit then
    begin
      FInvoiceForm.qryEditInvoiceLine.ParamByName('INVOICE_LINE_ID').AsInteger :=
        FInvoiceLineId;
      FInvoiceForm.qryEditInvoiceLine.ParamByName('QUANTITY').AsInteger :=
        FQuantity;
      // Выполняем хранимую процедуру для редактирования  
      FInvoiceForm.qryEditInvoiceLine.Execute();
    end;
    // Подтверждаем транзакцию
    FInvoiceForm.trWrite.Commit;
    // Обновляем оба грида
    FInvoiceForm.qryInvoice.Refresh;
    FInvoiceForm.qryInvoiceLine.Refresh;

    Action := caFree;
  except
    on E: Exception do
    begin
      if FInvoiceForm.trWrite.Active then
        FInvoiceForm.trWrite.Rollback;
      Application.ShowException(E);
      // Не загрываем окно редактирования. Позволяем пользователю исправить ошибку
      Action := caNone;
    end;
  end;
end;
                </programlisting>
            </para>
            <para>В итоге у нас получилось приложение которое выглядит следующим образом: <figure>
                    <title>Скриншот работающего приложения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/firedac-screen.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Скриншот работающего приложения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
        </section>

        <section>
            <title>Заключение</title>

            <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_delphi_source.zip"
                    >Исходные коды примера приложения</link>
                <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_database.zip"
                    >Готовая БД</link>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ibase.ru"
                    >www.ibase.ru</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.ibsurgeon.com">www.ibsurgeon.com</link>
                <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="mailto:support@ibase.ru">support@ibase.ru</link>, <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="mailto:support@ib-aid.com">support@ib-aid.com</link></para>
        </section>
    </section>

    <section xml:id="app-ef-winform">
        <title>Создание приложений с использованием Entity Framework</title>

        <para>В данной главе будет описан процесс создания приложений для СУБД Firebird с
            использованием компонентов доступа Entity Framework и среды Visual Studio 2015. </para>

        <para><emphasis role="bold">ADO.NET Entity Framework</emphasis> (EF) —
            объектно-ориентированная технология доступа к данным, является object-relational mapping
            (ORM) решением для .NET Framework от Microsoft. Предоставляет возможность взаимодействия
            с объектами как посредством LINQ в виде LINQ to Entities, так и с использованием Entity
            SQL.</para>
        <para>Entity Framework предполагает три возможных способа взаимодействия с базой данных:<itemizedlist>
                <listitem>
                    <para><emphasis role="bold">Database first</emphasis>: Entity Framework создаёт
                        набор классов, которые отражают модель конкретной базы данных.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Model first</emphasis>: сначала разработчик создаёт
                        модель базы данных, по которой затем Entity Framework создаёт реальную базу
                        данных на сервере.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Code first</emphasis>: разработчик создаёт класс
                        модели данных, которые будут храниться в БД, а затем Entity Framework по
                        этой модели генерирует базу данных и её таблицы.</para>
                </listitem>
            </itemizedlist></para>
        <para>В своём приложении мы будем использовать подход Code First, однако вы без труда
            сможете использовать и другие подходы.</para>
        <note>
            <para>На самом деле у нас уже есть база данных. Поэтому будем просто писать код который
                бы привёл к созданию нашей БД.</para>
        </note>

        <section xml:id="app-dotnet-vsprepare">
            <title>Подготовка Visual Studio 2015 для работы с Firebird</title>

            <para>Для работы с Firebird вам необходимо установить:<itemizedlist>
                    <listitem>
                        <para>FirebirdSql.Data.FirebirdClient.dll</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework.Firebird.dll</para>
                    </listitem>
                    <listitem>
                        <para>DDEX Provider for Visual Studio</para>
                    </listitem>
                </itemizedlist></para>

            <para>Установка первых двух не вызывает никаких сложностей. В настоящий момент они
                распространяются и устанавливаются в проект с помощью NuGet. А вот последняя
                библиотека, предназначенная для работы мастеров Visual Studio, устанавливается не
                так легко и может потратить у вас много сил и времени.</para>
            <para>Добрые люди попытались автоматизировать процесс установки и включить установку
                всех компонентов в один дистрибутив (<link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://sourceforge.net/projects/firebird-4-8-0-ddex-installer/"
                    >http://sourceforge.net/projects/firebird-4-8-0-ddex-installer/</link>). Однако
                в ряде случаев вам может потребоваться ручная установка всех компонентов. В этом
                случае вам потребуется скачать:<itemizedlist>
                    <listitem>
                        <para>FirebirdSql.Data.FirebirdClient-4.10.0.0.msi (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/FirebirdSql.Data.FirebirdClient-4.10.0.0.msi/download"
                                >http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/FirebirdSql.Data.FirebirdClient-4.10.0.0.msi/download</link>)
                        </para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework.Firebird-4.10.0.0-NET45.7z (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/EntityFramework.Firebird-4.10.0.0-NET45.7z/download"
                                >http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/EntityFramework.Firebird-4.10.0.0-NET45.7z/download</link>)
                        </para>
                    </listitem>
                    <listitem>
                        <para>DDEXProvider-3.0.2.0.7z (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0.7z/download"
                                >http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0.7z/download</link>)
                        </para>
                    </listitem>
                    <listitem>
                        <para>DDEXProvider-3.0.2.0-src.7z (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0-src.7z/download"
                                >http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0-src.7z/download</link>)
                        </para>
                    </listitem>
                </itemizedlist></para>
            <para>Далее описан процесс установки:<orderedlist>
                    <listitem>
                        <para>Устанавливаем FirebirdSql.Data.FirebirdClient-4.10.0.0.msi</para>
                    </listitem>
                    <listitem>
                        <para>Распаковываем EntityFramework.Firebird-4.10.0.0-NET45.7z в папку с
                            установленным клиентом Firebird. У меня это папка <filename>c:\Program
                                Files (x86)\FirebirdClient\</filename>
                        </para>
                        <important>
                            <para>Это необходимо делать с правами администратора. Как и другие
                                действия с защищёнными директориями.</para>
                        </important>
                    </listitem>
                    <listitem>
                        <para>Необходимо установить сборки Firebird в GAC. Для удобство пописываем в
                            %PATH% путь до утилиты <application>gacutil</application> для .NET
                            Framework 4.5. У меня этот путь <filename>c:\Program Files
                                (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1
                                Tools\</filename></para>
                    </listitem>
                    <listitem>
                        <para>Запускаем командную строку <application>cmd</application> от имени
                            администратора и переходим в директорию с установленным клиентом.
                            <programlisting>
chdir "c:\Program Files (x86)\FirebirdClient"                                
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Теперь проверяем что FirebirdSql.Data.FirebirdClient установлен в GAC.
                            Для этого набираем команду <programlisting>
gacutil /l FirebirdSql.Data.FirebirdClient                                
</programlisting>
                            <screen>
Microsoft (R) .NET Global Assembly Cache Utility.  Version 4.0.30319.0
c Корпорация Майкрософт (Microsoft Corporation). Все права защищены.

В глобальном кэше сборок содержатся следующие сборки:
  FirebirdSql.Data.FirebirdClient, Version=4.10.0.0, Culture=neutral, PublicKeyToken=3750abcc3150b00c, processorArchitecture=MSIL

Число элементов = 1    
</screen>
                        </para>
                        <para>Если FirebirdSql.Data.FirebirdClient не был установлен в GAC, то
                            сделаем это с помощью команды
                            <programlisting>
gacutil /i FirebirdSql.Data.FirebirdClient.dll                               
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Теперь установим EntityFramework.Firebird в GAC
                            <programlisting>
gacutil /i EntityFramework.Firebird.dll                              
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Распаковываем <filename>DDEXProvider-3.0.2.0.7z</filename> в удобную
                            директорию. Я распаковал её в <filename>c:\Program Files
                                (x86)\FirebirdDDEX\</filename></para>
                    </listitem>
                    <listitem>
                        <para>Туда же распаковываем <filename>DDEXProvider-3.0.2.0-src.7z</filename>
                            содержимое поддиректории архива
                            <filename>/reg_files/VS2015</filename></para>
                        <note>
                            <para>Забавно, но по какой-то причине этих файлов нет в предыдущем
                                архиве со скомпилированными dll библиотеками, но они присутствуют в
                                архиве с исходными кодами.</para>
                        </note>
                    </listitem>
                    <listitem>
                        <para>Открываем файл <filename>FirebirdDDEXProvider64.reg</filename> с
                            помощью блокнота. Находим строчку, которая содержит
                                <filename>%path%</filename> и меняем его на полный путь к файлу
                                <filename>FirebirdSql.VisualStudio.DataTools.dll</filename>
                            <programlisting>
   "CodeBase"="c:\\Program Files (x86)\\FirebirdDDEX\\FirebirdSql.VisualStudio.DataTools.dll"                         
                        </programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Сохраняем этот файл, запускаем его. На запрос добавить информацию в
                            реестр нажимаем ДА.</para>
                    </listitem>
                    <listitem>
                        <para>Теперь нужно отредактировать файл machine.config, в моем случае он
                            находится по пути:
                                <filename>C:\Windows\Microsoft.NET\Framework\v4.0.30319\Config</filename></para>
                        <para>Открываем этот файл блокнотом. Находим секцию <programlisting language="xml">
<![CDATA[
  <system.data>
    <DbProviderFactories>

]]>                            
                        </programlisting> Добавляем в эту секцию
                            строчку: <programlisting language="xml">
<![CDATA[
<add name="FirebirdClient Data Provider" 
     invariant="FirebirdSql.Data.FirebirdClient" 
     description=".Net Framework Data Provider for Firebird" 
     type="FirebirdSql.Data.FirebirdClient.FirebirdClientFactory, 
           FirebirdSql.Data.FirebirdClient, Version=4.10.0.0, Culture=neutral, 
           PublicKeyToken=3750abcc3150b00c" />
]]>                            
                        </programlisting>
                        </para>
                        <note>
                            <para>Всё это действительно для версии 4.10.0.</para>
                        </note>
                        <para>То же самое проделаем для <filename>machine.config</filename>, который
                            находится в
                                <filename>c:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\</filename></para>

                        <para>Установка закончена.</para>

                        <para>Для проверки, что всё успешно установилось, запускаем Visual Studio
                            2015. Находим обозреватель серверов и пытаемся подключиться к одной из
                            существующих баз данных Firebird.</para>
                    </listitem>
                </orderedlist></para>
            <para>
                <figure>
                    <title>Добавление подключения в Visual Studio</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-odbc.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Добавление подключения в Visual Studio.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Выбор провайдера подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-select-datasource.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Выбор провайдера подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Настройка подключения к Firebird</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-fbprovider.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Настройка подключения к Firebird.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Успешное подключение</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-connok.png"/>
                        </imageobject>
                        <textobject>
                            <phrase>Успешное подключение.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
        </section>

        <section>
            <title>Создание проекта</title>

            <para>В данной главе мы рассмотрим пример создания Windows Forms приложения. Остальные
                типы приложений хоть и отличаются, но принципы работы с Firebird через Entity
                Framework остаются те же.</para>

            <para>Прежде всего, после создания Windows Forms проекта нам необходимо добавить с
                помощью менеджера пакетов NuGet следующие пакеты:<itemizedlist spacing="compact">
                    <listitem>
                        <para>FirebirdSql.Data.FirebirdClient</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework.Firebird</para>
                    </listitem>
                </itemizedlist></para>

            <para>Для этого необходимо щёлкнуть правой клавишей мыши по имени проекта в обозревателе
                решений и в выпадающем меню выбрать пункт «Управление пакетами NuGet». <figure>
                    <title>Контекстное меню проекта</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-vsmenu-nuget.png"/>
                        </imageobject>
                        <textobject>
                            <phrase>Контекстное меню проекта.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>В появившемся менеджере пакетов произвести поиск и установку необходимых пакетов. <figure>
                    <title>Контекстное меню проекта</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-nuget.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Контекстное меню проекта.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
        </section>

        <section xml:id="app-dotnet-createedm">
            <title>Создание EDM модели</title>

            <para>В своём приложении мы будем использовать подход Code First.</para>

            <para>Для создания модели EDM необходимо щёлкнуть правой клавишей мыши по имени проекта
                в обозревателе решений и выбрать пункт меню <guimenu>Добавить -> Создать
                    элемент</guimenu>. <figure>
                    <title>Добавление элемента</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-add-elem.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Добавление элемента.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Далее в мастере добавления нового элемента выбираем пункт «Модель ADO.NET EDM». <figure>
                    <title>Добавление модели ADO.NET EDM</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-add-model.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Добавление модели ADO.NET EDM.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Поскольку у нас уже существует база данных, то будем генерировать EDM модель из
                базы данных. <figure>
                    <title>Выбор типа модели</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-edm-master.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Выбор типа модели.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Теперь надо выбрать подключение, из которого будет создана модель. Если Такого
                подключения нет, то его надо создать. <figure>
                    <title>Выбор подключения для модели</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-edm-selectsource.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Выбор подключения для модели.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Параметры подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-connection-params.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Параметры подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Кроме основных параметров подключения могут потребоваться также указать ряд
                дополнительных параметров, например, уровень изолированности транзакций (по
                умолчанию Read Commited), использование пула подключений и т.д. Поскольку Entity
                Framework (как впрочем, ADO.NET в целом) использует отсоединённую модель
                взаимодействия, при которой каждое подключение и транзакция активна очень короткий
                промежуток времени, то я бы рекомендовал задать режим изолированности Snapshot. <figure>
                    <title>Дополнительные свойства подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-connection-properties.png"/>
                        </imageobject>
                        <textobject>
                            <phrase>Дополнительные свойства подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>В процессе работы мастера создания модели у вас спросят, как хранить строку
                подключения. <figure>
                    <title>Сохранение строки подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-save-connectionstring.png" width="680"
                            />
                        </imageobject>
                        <textobject>
                            <phrase>Сохранение строки подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>Если вы строите веб приложение или трёхзвенку, где все пользователи будут работать
                с базой данных под одной и той же учётной записью, то смело выбирайте «Да». Если же
                ваше приложение должно запрашивать учётные данные для соединения с базой данных
                выбирайте «Нет». Впрочем, с мастерами гораздо более удобно работать, когда у вас
                выбран пункт «Да». Вы всегда можете это изменить в готовом приложении, просто
                отредактировав строку подключения в файле конфигурации приложения
                        <filename><replaceable>&lt;AppName&gt;</replaceable>.exe.conf</filename>.
                Строка подключения будет сохранена в секции <emphasis role="bold"
                    >connectionStrings</emphasis> примерно в таком виде <programlisting language="xml">
<![CDATA[
<add name="DbModel" 
     connectionString="character set=UTF8; data source=localhost; 
                       initial catalog=examples; port number=3050; 
                       user id=sysdba; dialect=3; isolationlevel=Snapshot; 
                       pooling=True; password=masterkey;" 
     providerName="FirebirdSql.Data.FirebirdClient" />
]]>                    
                </programlisting>
            </para>
            <para>Для того чтобы файл конфигурации перестал хранить конфиденциальную информацию
                просто удалите из строки подключения <emphasis role="italic"
                    >password=masterkey;</emphasis></para>

            <note>
                <title>Замечание о работе с Firebird 3.0</title>
                <para> К сожалению текущий ADO .Net провайдер для Firebird (версия 5.9.0.0) не
                    поддерживает шифрование сетевого трафика (по умолчанию в Firebird 3.0). Поэтому
                    если вы желаете работать с Firebird 3.0, то вам необходимо изменить некоторые
                    настройки в <filename>firebird.conf</filename> (или в
                        <filename>databases.conf</filename> для конкретной БД), чтобы Firebird
                    работал без использования шифрования сети. Для этого необходимо поменять
                    следующие настройки:
                    <programlisting>
WireCrypt = Disabled                    
                </programlisting>
                </para>
            </note>

            <para>Далее у вас спросят, какие таблицы и представления должны быть включены модель. <figure>
                    <title>Сохранение строки подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-select-edm-tables.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Сохранение строки подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>

            <para>В принципе EDM модель готова. После работы этого мастера у вас должно появиться 5
                новых файлов. Один файл модели и четыре файла описывающих каждую из сущностей
                модели.</para>

            <para>Давайте посмотрим один из сгенерированных файлов описывающих сущность INVOICE. <programlisting language="csharp">
<![CDATA[                
[Table("Firebird.INVOICE")]
public partial class INVOICE
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", 
       "CA2214:DoNotCallOverridableMethodsInConstructors")]
    public INVOICE()
    {
        INVOICE_LINES = new HashSet<INVOICE_LINE>();
    }

    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.None)]
    public int INVOICE_ID { get; set; }

    public int CUSTOMER_ID { get; set; }

    public DateTime? INVOICE_DATE { get; set; }

    public decimal? TOTAL_SALE { get; set; }

    public short PAYED { get; set; }

    public virtual CUSTOMER CUSTOMER { get; set; }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", 
       "CA2227:CollectionPropertiesShouldBeReadOnly")]
    public virtual ICollection<INVOICE_LINE> INVOICE_LINES { get; set; }
}  
]]>
            </programlisting>
            </para>
            <para>Класс содержат свойства, которые отображают поля таблицы INVOICE. Каждое из таких
                свойств снабжено атрибутами, описывающими ограничения. Подробнее об различных
                атрибутах вы можете почитать в документации Майкрософт <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://msdn.microsoft.com/en-us/data/jj591583">Code First Data
                    Annotations</link>.</para>
            <para>Кроме того, было сгенерировано ещё два навигационных свойства CUSTOMER и
                INVOICE_LINES. Первое содержит ссылку на сущность поставщика, второе — коллекцию
                строк накладных. Оно было сгенерировано потому, что таблица INVOICE_LINE имеет
                внешний ключ на таблицу INVOICE. Конечно, вы можете удалить это свойство из сущности
                INVOICE, но делать это вовсе не обязательно. Дело в том, что в данном случае
                свойства CUSTOMER и INVOICE_LINES использует так называемую «ленивую загрузку». При
                таком загрузка осуществляется при первом обращении к объекту, т.е. если связанные
                данные не нужны, то они не подгружаются. Однако при первом же обращении к
                навигационному свойству эти данные автоматически подгружаются из БД.</para>
            <para>При использовании ленивой загрузки надо иметь в виду некоторые моменты при
                объявлении классов. Так, классы, использующие ленивую загрузку должны быть
                публичными, а их свойства должны иметь модификаторы <emphasis role="bold"
                    >public</emphasis> и <emphasis role="bold">virtual</emphasis>.</para>
            <para>Теперь откроем файл <filename>DbModel.cs</filename> описывающий модель в целом. <programlisting language="csharp">
<![CDATA[  
public partial class DbModel : DbContext
{
    public DbModel()
        : base("name=DbModel")
    {
    }

    public virtual DbSet<CUSTOMER> CUSTOMERS { get; set; }
    public virtual DbSet<INVOICE> INVOICES { get; set; }
    public virtual DbSet<INVOICE_LINE> INVOICE_LINES { get; set; }
    public virtual DbSet<PRODUCT> PRODUCTS { get; set; }

    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        modelBuilder.Entity<CUSTOMER>()
            .Property(e => e.ZIPCODE)
            .IsFixedLength();

        modelBuilder.Entity<CUSTOMER>()
            .HasMany(e => e.INVOICES)
            .WithRequired(e => e.CUSTOMER)
            .WillCascadeOnDelete(false);

        modelBuilder.Entity<PRODUCT>()
            .HasMany(e => e.INVOICE_LINES)
            .WithRequired(e => e.PRODUCT)
            .WillCascadeOnDelete(false);

        modelBuilder.Entity<INVOICE>()
            .HasMany(e => e.INVOICE_LINES)
            .WithRequired(e => e.INVOICE)
            .WillCascadeOnDelete(false);

    }
}
]]>
            </programlisting>
            </para>

            <para>Здесь мы видим свойства описывающие набор данных для каждой сущности. А так же
                задание дополнительных свойств создания модели с помощью Fluent API. Полное описание
                Fluent API вы может прочитать в документации Microsoft <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://msdn.microsoft.com/en-us/data/jj591617.aspx"
                    >Configuring/Mapping Properties and Types with the Fluent API</link>.</para>
            <para>Зададим в методе OnModelCreating точность для свойств типа decimal с помощью
                Fluent API. Для этого допишем следующие строчки <programlisting language="csharp">
<![CDATA[ 
            modelBuilder.Entity<PRODUCT>()
                .Property(p => p.PRICE)
                .HasPrecision(15, 2);
            modelBuilder.Entity<INVOICE>()
                .Property(p => p.TOTAL_SALE)
                .HasPrecision(15, 2);

            modelBuilder.Entity<INVOICE_LINE>()
                .Property(p => p.SALE_PRICE)
                .HasPrecision(15, 2);

            modelBuilder.Entity<INVOICE_LINE>()
                .Property(p => p.QUANTITY)
                .HasPrecision(15, 0);
]]>
            </programlisting>
            </para>
        </section>

        <section>
            <title>Создание пользовательского интерфейса</title>

            <para>В нашем приложении мы создадим два справочника: справочник товаров и справочник
                заказчиков. Каждый справочник содержит сетку DataGridView, панель с кнопками
                ToolStrip, а также компонент BindingSource, который служит для упрощения привязки
                данных к элементам управления в форме. <figure>
                    <title>Форма справочника заказчиков</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-customer-form.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Форма справочника заказчиков.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>Поскольку по функционалу оба справочника похожи и реализованы схожим образом
                описывать мы будем только один.</para>

            <section xml:id="app-dotnet-getcontext">
                <title>Получение контекста</title>

                <para>Для работы с нашей моделью нам потребуется метод для получения контекста (или
                    модели). В принципе для этого достаточно выполнить:
                    <programlisting language="csharp">
DbModel dbContext = new DbModel();                    
                </programlisting>
                </para>
                <para>Однако, если в строке подключения не хранятся конфиденциальные данные
                    (например, пароль), а мы инициализируем во время авторизации их при старте
                    приложения, то нам потребуется специальный метод для хранения и восстановления
                    строки подключения или сохранение ранее созданного контекста. Для этого создадим
                    специальный класс, который помимо метода для получения контекста будет также
                    содержать некоторые глобальные переменные уровня приложения, например рабочий
                    период. <programlisting language="csharp">
<![CDATA[                        
static class AppVariables
{
    private static DbModel dbContext = null;

    /// <summary>
    /// Дата начала рабочего периода
    /// </summary>
    public static DateTime StartDate { get; set; }

    /// <summary>
    /// Дата окончания рабочего периода
    /// </summary>
    public static DateTime FinishDate { get; set; }

    /// <summary>
    /// Возвращает экземпляр модели (контекста)
    /// </summary>
    /// <returns>Модель</returns>
    public static DbModel CreateDbContext() {
        dbContext = dbContext ?? new DbModel();
        return dbContext;        
    }
}                    
]]>
                </programlisting>
                </para>
                <para>Сама строка подключения инициализируется при старте приложения, после того как
                    успешно прошла авторизация. Для этого в обработчике события Load главной формы
                    напишем следующий код. <programlisting language="csharp">
<![CDATA[                        
private void MainForm_Load(object sender, EventArgs e) {
    var dialog = new LoginForm();
    if (dialog.ShowDialog() == DialogResult.OK)
    {
        var dbContext = AppVariables.getDbContext();

        try
        {
            string s = dbContext.Database.Connection.ConnectionString;
            var builder = new FbConnectionStringBuilder(s);
            builder.UserID = dialog.UserName;
            builder.Password = dialog.Password;

            dbContext.Database.Connection.ConnectionString = builder.ConnectionString;

            // пробуем подключится
            dbContext.Database.Connection.Open();
        }
        catch (Exception ex)
        {
            // отображаем ошибку
            MessageBox.Show(ex.Message, "Error");
            Application.Exit();
        }
    }
    else
        Application.Exit();
}                  
]]>
                </programlisting>
                </para>
                <para>Теперь для получения контекста мы будем использовать статический метод
                    CreateDbContext.
                    <programlisting language="csharp">
var dbContext = AppVariables.getDbContext();                   
                </programlisting>
                </para>
            </section>

            <section>
                <title>Работа с данными</title>

                <para>Сами по себе сущности модели не содержат никаких данных. Самым простым
                    способом загрузить данные является вызовам метода Load, например вот так: <programlisting language="csharp">
<![CDATA[                        
private void LoadCustomersData()
{
    dbContext.CUSTOMERS.Load(); 
    var customers = dbContext.CUSTOMERS.Local;

    bindingSource.DataSource = customers.ToBindingList();    
}

private void CustomerForm_Load(object sender, EventArgs e)
{
    LoadCustomersData();

    dataGridView.DataSource = bindingSource;
    dataGridView.Columns["CUSTOMER_ID"].Visible = false;
}                 
]]>
                </programlisting>
                </para>

                <para>Однако такой способ имеет ряд недостатков:<orderedlist>
                        <listitem>
                            <para>Метод Load загружает сразу все данные из таблицы CUSTOMER в
                                память.</para>
                        </listitem>
                        <listitem>
                            <para>Ленивые свойства ( INVOICES ) хоть и не загружаются сразу, а лишь
                                по мере обращения к ним, всё равно будут загружены при отображении
                                записей в гриде. Причём ровно столько раз, сколько записей будет
                                выведено.</para>
                        </listitem>
                        <listitem>
                            <para>Порядок записей неопределён.</para>
                        </listitem>
                    </orderedlist></para>

                <para>Для обхода этих недостатком мы будем использовать технологию LINQ (Language
                    Integrated Query), или точнее<emphasis role="bold">LINQ to Entities</emphasis>.
                    LINQ to Entities предлагает простой и интуитивно понятный подход для получения
                    данных с помощью выражений, которые по форме близки выражениям языка SQL. С
                    синтаксисом LINQ вы можете ознакомиться по <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="https://msdn.microsoft.com/ru-ru/library/bb386964(v=vs.110).aspx"
                        >LINQ to Entities</link>.</para>
                <para>Методы расширений LINQ могут возвращать два объекта: <emphasis role="bold"
                        >IEnumerable</emphasis> и <emphasis role="bold">IQueryable</emphasis>.
                    Интерфейс IQueryable наследуется от IEnumerable, поэтому по идее объект
                    IQueryable это и есть также объект IEnumerable. Но между ними есть существенная
                    разница.</para>
                <para>Интерфейс IEnumerable находится в пространстве имён <emphasis role="bold"
                        >System.Collections</emphasis>. Объект IEnumerable представляет набор данных
                    в памяти и может перемещаться по этим данным только вперёд. При выполнении
                    запроса IEnumerable загружает все данные, и если нам надо выполнить их
                    фильтрацию, то сама фильтрация происходит на стороне клиента.</para>
                <para>Интерфейс IQueryable располагается в пространстве имён System.Linq. Объект
                    IQueryable предоставляет удалённый доступ к базе данных и позволяет перемещаться
                    по данным как в прямом порядке от начала до конца, так и в обратном порядке. В
                    процессе создания запроса, возвращаемым объектом которого является IQueryable,
                    происходит оптимизация запроса. В итоге в процессе его выполнения тратится
                    меньше памяти, меньше пропускной способности сети.</para>
                <para>Свойство Local возвращает интерфейс IEnumerable. Поэтому мы можем составлять
                    LINQ запросы к нему. <programlisting language="csharp">
<![CDATA[                        
private void LoadCustomersData()
{
    var dbContext = AppVariables.getDbContext();
    dbContext.CUSTOMERS.Load(); 
    
    var customers = 
        from customer in dbContext.CUSTOMERS.Local
        orderby customer.NAME
        select new customer;

    bindingSource.DataSource = customers.ToBindingList();
}                 
]]>
                </programlisting>
                </para>

                <para>Однако как уже сказано этот запрос будет выполняться над данными в памяти. В
                    принципе для маленьких таблиц, которым не требуется предварительная фильтрация
                    это приемлемо.</para>
                <para>Для того чтобы LINQ запрос был преобразован в SQL и выполнялся на стороне
                    сервера нам необходимо использовать в LINQ запросе вместо обращения к свойству
                        <function>dbContext.CUSTOMERS.Local</function> обращаться сразу к
                        <function>dbContext.CUSTOMERS</function>. В этом случае нам не потребуется
                    предварительный вызов <function>dbContext.CUSTOMERS.Load();</function> для
                    загрузки коллекции в память.</para>
                <para>Однако тут нас подстерегает одна маленькая засада. Объекты IQueryable не умеют
                    возвращать BindingList. BindingList является базовым классом для создания
                    двустороннего механизма привязки данных. Из интерфейса IQueryable мы можем
                    получить обычный список посредством вызова ToList, но в этом случае мы лишаемся
                    приятных бонусов, таких как сортировка в гриде и многих других. Кстати в .NET
                    Framework 5 это уже исправили и создали специальное расширение. Сделаем своё
                    расширение, которое будет делать тоже самое. <programlisting language="csharp">
<![CDATA[                        
public static class DbExtensions
{
    // Внутренний класс для маппинга на него значения генератора
    private class IdResult
    {
        public int Id { get; set; }
    }

    // Преобразование IQueryable в BindingList
    public static BindingList<T> ToBindingList<T>
        (this IQueryable<T> source) where T : class
    {
        return (new ObservableCollection<T>(source)).ToBindingList();
    }

    // Получение следующего значения последовательности
    public static int NextValueFor(this DbModel dbContext, string genName)
    {
        string sql = String.Format(
            "SELECT NEXT VALUE FOR {0} AS Id FROM RDB$DATABASE", genName);
        return dbContext.Database.SqlQuery<IdResult>(sql).First().Id;
    }

    // Отсоединение всех объектов коллекции DbSet от контекста
    // Полезно для обновлении кеша
    public static void DetachAll<T>(this DbModel dbContext, DbSet<T> dbSet) 
        where T : class 
    {         
        foreach (var obj in dbSet.Local.ToList())
        {
            dbContext.Entry(obj).State = EntityState.Detached;
        }
    }

    // Обновление всех изменённых объектов в коллекции
    public static void Refresh(this DbModel dbContext, RefreshMode mode, 
       IEnumerable collection)
    {
        var objectContext = ((IObjectContextAdapter)dbContext).ObjectContext;
        objectContext.Refresh(mode, collection);
    }

    // Обновление объекта
    public static void Refresh(this DbModel dbContext, RefreshMode mode, 
         object entity)
    {
        var objectContext = ((IObjectContextAdapter)dbContext).ObjectContext;
        objectContext.Refresh(mode, entity);
    }
}                
]]>
                </programlisting> В этом же классе присутствует ещё несколько расширений. </para>

                <para>Метод <function>NextValueFor</function> предназначен для получения следующего
                    значения генератора. Метод <function>dbContext.Database.SqlQuery</function>
                    позволяет выполнять SQL запросы напрямую и отображать их результаты на некоторую
                    сущность (проекцию). Вы можете воспользоваться им, если вам потребуется
                    выполнить SQL запрос напрямую.</para>
                <para>Метод <function>DetachAll</function> предназначен для отсоединения всех
                    объектов коллекции DBSet от контекста. Это необходимо для обновления внутреннего
                    кеша. Дело в том, что в рамках контекста все извлекаемые кешируются и не
                    извлекаются из базы данных снова. Однако это не всегда полезно, поскольку
                    затрудняет получение изменённых записей сделанных в другом контексте. </para>

                <note>
                    <para>В Web приложениях контекст обычно живёт очень короткое время, а новый
                        контекст имеет не заполненный кеш.</para>
                </note>

                <para>Метод <function>Refresh</function> предназначен для обновления свойств
                    объекта-сущности. Он полезен для обновления свойств объекта после его
                    редактирования или добавления.</para>

                <para>Таким образом, наш код загрузки данных будет выглядеть так <programlisting language="csharp">
<![CDATA[                        
private void LoadCustomersData()
{
    var dbContext = AppVariables.getDbContext();
    // отсоединяем все загруженные объекты
    // это необходимо чтобы обновился внутренний кеш
    // при второй и последующих вызовах этого метода
    dbContext.DetachAll(dbContext.CUSTOMERS);

    var customers =
          from customer in dbContext.CUSTOMERS
          orderby customer.NAME
          select customer;


    bindingSource.DataSource = customers.ToBindingList();
}

private void CustomerForm_Load(object sender, EventArgs e)
{
    LoadCustomersData();

    dataGridView.DataSource = bindingSource;
    dataGridView.Columns["INVOICES"].Visible = false;
    dataGridView.Columns["CUSTOMER_ID"].Visible = false;
    dataGridView.Columns["NAME"].HeaderText = "Name";
    dataGridView.Columns["ADDRESS"].HeaderText = "Address";
    dataGridView.Columns["ZIPCODE"].HeaderText = "ZipCode";
    dataGridView.Columns["PHONE"].HeaderText = "Phone";
}               
]]>
                </programlisting>
                </para>

                <para>Код обработчика события на нажатие кнопки добавления выглядит следующим
                    образом. <programlisting language="csharp">
<![CDATA[                        
private void btnAdd_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    // создание нового экземпляра сущности        
    var customer = (CUSTOMER)bindingSource.AddNew();
    // создаём форму для редактирования
    using (CustomerEditorForm editor = new CustomerEditorForm()) {
        editor.Text = "Добавление заказчика";
        editor.Customer = customer;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
           if (editor.DialogResult == DialogResult.OK) {
              try {
                 // получаем новое значение генератора
                 // и присваиваем его идентификатору
                 customer.CUSTOMER_ID = dbContext.NextValueFor("GEN_CUSTOMER_ID");
                 // добавляем нового заказчика
                 dbContext.CUSTOMERS.Add(customer);
                 // пытаемся сохранить изменения
                 dbContext.SaveChanges();
                 // и обновить текущую запись
                 dbContext.Refresh(RefreshMode.StoreWins, customer);
              }
              catch (Exception ex) {
                 // отображаем ошибку
                 MessageBox.Show(ex.Message, "Error");
                 // не закрываем форму для возможности исправления ошибки
                 fe.Cancel = true;
              }
           }
           else
               bindingSource.CancelEdit();

        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}               
]]>
                </programlisting>
                </para>
                <para>При добавлении новой записи мы получаем значение следующего идентификатора с
                    помощью генератора. Мы могли бы не инициализировать значение идентификатора, и в
                    этом случае отработал бы BEFORE INSERT триггер, который всё равно дёрнул бы
                    следующее значение генератора. Однако в этом случае мы не смогли бы обновить
                    вновь добавленную запись.</para>

                <para>Код обработчика события на нажатие кнопки редактирования выглядит следующим
                    образом. <programlisting language="csharp">
<![CDATA[                        
private void btnEdit_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    // получаем сущность
    var customer = (CUSTOMER)bindingSource.Current;
    // создаём форму для редактирования
    using (CustomerEditorForm editor = new CustomerEditorForm()) {
        editor.Text = "Редактирование заказчика";
        editor.Customer = customer;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
            if (editor.DialogResult == DialogResult.OK) {
                try {
                    // пытаемся сохранить изменения
                    dbContext.SaveChanges();
                    dbContext.Refresh(RefreshMode.StoreWins, customer);
                    // обновляем все связанные контролы
                    bindingSource.ResetCurrentItem();
                }
                catch (Exception ex) {
                    // отображаем ошибку
                    MessageBox.Show(ex.Message, "Error");
                    // не закрываем форму для возможности исправления ошибки
                    fe.Cancel = true;
                }
            }
            else
                bindingSource.CancelEdit();

        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}             
]]>
                </programlisting>
                </para>
                <para>Форма для редактирования заказчика выглядит следующим образом. <figure>
                        <title>Форма редактирования заказчика</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/dotnet-customer-editor-form.png"/>
                            </imageobject>
                            <textobject>
                                <phrase>Форма редактирования заказчика.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>

                <para>Код привязки к данным очень прост. <programlisting language="csharp">
<![CDATA[                        
public CUSTOMER Customer { get; set; }

private void CustomerEditorForm_Load(object sender, EventArgs e)
{
    edtName.DataBindings.Add("Text", this.Customer, "NAME");
    edtAddress.DataBindings.Add("Text", this.Customer, "ADDRESS");
    edtZipCode.DataBindings.Add("Text", this.Customer, "ZIPCODE");
    edtPhone.DataBindings.Add("Text", this.Customer, "PHONE");
}             
]]>
                </programlisting>
                </para>

                <para>Код обработчика события на нажатие кнопки удаления выглядит следующим образом. <programlisting language="csharp">
<![CDATA[                        
private void btnDelete_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    var result = MessageBox.Show("Вы действительно хотите удалить заказчика?",
                "Подтверждение",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);
    if (result == DialogResult.Yes) {
       // получаем сущность 
       var customer = (CUSTOMER)bindingSource.Current;
       try {
           dbContext.CUSTOMERS.Remove(customer);
           // пытаемся сохранить изменения
           dbContext.SaveChanges();
           // удаляем из связанного списка
           bindingSource.RemoveCurrent();
       }
       catch (Exception ex) {
           // отображаем ошибку
           MessageBox.Show(ex.Message, "Error");
       }
    }
}             
]]>
                </programlisting>
                </para>
            </section>

            <section>
                <title>Журналы</title>

                <para>В нашем приложении будет один журнал «Счёт-фактуры». В отличие от справочников
                    журналы содержат довольно большое количество записей и являются часто
                    пополняемыми.</para>
                <para>Счёт-фактура — состоит из заголовка, где описываются общие атрибуты (номер,
                    дата, заказчик …), и строк счёт-фактуры со списком товаром, их количеством,
                    стоимостью и т.д. Для таких документов удобно иметь два грида: в главном
                    отображаются данные о шапке документа, а в детализирующем — список товаров.
                    Таким образом, на форму документа нам потребуется поместить два компонента
                    DataGridView, к каждому из которых привязать свой BindingSource <figure>
                        <title>Форма журнала счёт-фактур</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/dotnet-invoice-form.png" width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Форма журнала счёт-фактур.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>Большинство журналов содержат поле с датой создания документа. Чтобы уменьшить
                    количество выбираемых данных обычно принято вводить такое понятие как рабочий
                    период для того, чтобы уменьшить объём данных передаваемый на клиента. Рабочий
                    период — это диапазон дат, внутри которого требуются рабочие документы.
                    Поскольку приложение может содержать более одного журнала, то имеет смысл
                    разместить переменные, содержащие дату начала и окончания рабочего периода, в
                    глобальном модуле AppVariables (см. <link linkend="app-dotnet-getcontext"
                        >Получение контекста</link>), который, так или иначе, используется всеми
                    модулями, работающими с БД. При старте приложения рабочий период обычно
                    инициализируется датой начала и окончания текущего квартала (могут быть другие
                    варианты). В ходе работы приложения можно изменить рабочий период по желанию
                    пользователя.</para>
                <para>Поскольку чаще всего требуются именно последние введённые документы, то имеет
                    смысл сортировать их по дате в обратном порядке. Извлекать данные, как и в
                    случае со справочниками будем при помощи LINQ. С учётом вышесказанного, метод
                    для загрузки данных шапок счёт-фактур будет выглядеть следующим образом: <programlisting language="csharp">
<![CDATA[                        
public void LoadInvoicesData() {
    var dbContext = AppVariables.getDbContext();

    // запрос на LINQ преобразуется в SQL
    var invoices =
        from invoice in dbContext.INVOICES
        where (invoice.INVOICE_DATE >= AppVariables.StartDate) &&
              (invoice.INVOICE_DATE <= AppVariables.FinishDate)
        orderby invoice.INVOICE_DATE descending
        select new InvoiceView
        {
            Id = invoice.INVOICE_ID,
            Cusomer_Id = invoice.CUSTOMER_ID,
            Customer = invoice.CUSTOMER.NAME,
            Date = invoice.INVOICE_DATE,
            Amount = invoice.TOTAL_SALE,
            Payed = (invoice.PAYED == 1) ? "Yes" : "No"
        };

    masterBinding.DataSource = invoices.ToBindingList();
}          
]]>
                </programlisting>
                </para>
                <para>В качестве проекции мы использовали не анонимный тип, а класс InvoiceView. Это
                    упрощает приведение типа. Определение класса InvoiceView выглядит следующим
                    образом: <programlisting language="csharp">
<![CDATA[                        
public class InvoiceView {
    public int Id { get; set; }
    public int Cusomer_Id { get; set; }
    public string Customer { get; set; }
    public DateTime? Date { get; set; }
    public decimal? Amount { get; set; }
    public string Payed { get; set; }

    public void Load(int Id) {
        var dbContext = AppVariables.getDbContext();

        var invoices =
            from invoice in dbContext.INVOICES
            where invoice.INVOICE_ID == Id
            select new InvoiceView
            {
                Id = invoice.INVOICE_ID,
                Cusomer_Id = invoice.CUSTOMER_ID,
                Customer = invoice.CUSTOMER.NAME,
                Date = invoice.INVOICE_DATE,
                Amount = invoice.TOTAL_SALE,
                Payed = (invoice.PAYED == 1) ? "Yes" : "No"
            };

        InvoiceView invoiceView = invoices.ToList().First();
        this.Id = invoiceView.Id;
        this.Cusomer_Id = invoiceView.Cusomer_Id;
        this.Customer = invoiceView.Customer;
        this.Date = invoiceView.Date;
        this.Amount = invoiceView.Amount;
        this.Payed = invoiceView.Payed;
    }
}         
]]>
                </programlisting> Метод Load позволяет нам быстро обновить 1 добавленную или
                    обновлённую запись в гриде, вместо того чтобы полностью перезагружать все
                    записи. </para>

                <para>Код обработчика события на нажатие кнопки добавления выглядит следующим
                    образом. <programlisting language="csharp">
<![CDATA[                        
private void btnAddInvoice_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    var invoice = dbContext.INVOICES.Create();

    using (InvoiceEditorForm editor = new InvoiceEditorForm()) {
        editor.Text = "Добавление счёт фактуры";
        editor.Invoice = invoice;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
            if (editor.DialogResult == DialogResult.OK) {
                try {
                    // получаем значение генератора
                    invoice.INVOICE_ID = dbContext.NextValueFor("GEN_INVOICE_ID");
                    // добавляем запись
                    dbContext.INVOICES.Add(invoice);
                    // пытаемся сохранить изменения
                    dbContext.SaveChanges();
                    // добавляем проекцию в список для грида
                    ((InvoiceView)masterBinding.AddNew()).Load(invoice.INVOICE_ID);
                }
                catch (Exception ex) {
                    // отображаем ошибку
                    MessageBox.Show(ex.Message, "Error");
                    // не закрываем форму для возможности исправления ошибки
                    fe.Cancel = true;
                }
            }
        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}      
]]>
                </programlisting>
                </para>
                <para>В отличие от аналогичного метода справочника здесь обновление записи
                    происходит не с помощью вызова <function>dbContext.Refresh</function>, а с
                    помощью метода <function>Load</function> проекции
                        <function>InvoiceView</function>. Дело в том, что
                        <function>dbContext.Refresh</function> предназначен для обновления объектов
                    сущностей, а не произвольных проекций, которые могут получаться сложными LINQ
                    запросами.</para>

                <para>Код обработчика события на нажатие кнопки редактирования выглядит следующим
                    образом. <programlisting language="csharp">
<![CDATA[                        
private void btnEditInvoice_Click(object sender, EventArgs e) {
    // получение контекста
    var dbContext = AppVariables.getDbContext();
    // поиск сущности по идентификатору
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);

    if (invoice.PAYED == 1) {
        MessageBox.Show("Изменение не возможно, счёт фактура уже оплачена.", "Ошибка");
        return;
    }

    using (InvoiceEditorForm editor = new InvoiceEditorForm()) {
        editor.Text = "Edit invoice";
        editor.Invoice = invoice;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
            if (editor.DialogResult == DialogResult.OK) {
                try {
                    // пытаемся сохранить изменения
                    dbContext.SaveChanges();
                    // перезагружаем проекцию
                    CurrentInvoice.Load(invoice.INVOICE_ID);
                    masterBinding.ResetCurrentItem();
                }
                catch (Exception ex) {
                    // отображаем ошибку
                    MessageBox.Show(ex.Message, "Error");
                    // не закрываем форму для возможности исправления ошибки
                    fe.Cancel = true;
                }
            }
        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}    
]]>
                </programlisting>
                </para>
                <para>Здесь нам потребовалось найти сущность по её идентификатору доступному в
                    текущей записи. Свойство CurrentInvoice предназначено для получения выделенной в
                    гриде счёт-фактуры. Оно реализовано так: <programlisting language="csharp">
<![CDATA[                        
public InvoiceView CurrentInvoice {
    get {
        return (InvoiceView)masterBinding.Current;
    }
}  
]]>
                </programlisting>
                </para>
                <para>Удаление шапки счёт фактуры вы можете сделать самостоятельно.</para>

                <para>Помимо добавления, редактирования и удаления для счёт-фактур мы ввели ещё одну
                    операцию оплаты, код метода реализующего эту операцию выглядит следующим
                    образом: <programlisting language="csharp">
<![CDATA[                        
private void btnInvoicePay_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
    try {
        if (invoice.PAYED == 1)
           throw new Exception("Изменение не возможно, счёт фактура уже оплачена.");

        invoice.PAYED = 1;
        // сохраняем изменения
        dbContext.SaveChanges();
        // перезагружаем изменённую запись
        CurrentInvoice.Load(invoice.INVOICE_ID);
        masterBinding.ResetCurrentItem();
    }
    catch (Exception ex) {
        // отображаем ошибку
        MessageBox.Show(ex.Message, "Ошибка");
    }
} 
]]>
                </programlisting>
                </para>
                <para>Для отображения позиций счёт-фактуры существует два метода:<orderedlist>
                        <listitem>
                            <para>Получать данные по каждой счёт-фактуре из навигационного свойства
                                INVOICE _ LINE и отображать содержимое этого сложного свойства
                                (возможно с преобразованиями LINQ ) в детейл гриде.</para>
                        </listitem>
                        <listitem>
                            <para>Получать данные по каждой счёт-фактуре отдельным LINQ запросом,
                                который будет перевыполняться при перемещении в указателя в мастер
                                гриде.</para>
                        </listitem>
                    </orderedlist> Каждый из методов имеет свои преимущества и недостатки. </para>

                <para>Первый метод предполагает, что при открытии формы счёт-фактуры мы должны сразу
                    извлечь все счёт-фактуры за указанный период и связанные данные по их позициям.
                    Это хоть и выполняется одним SQL запросом, но может занять довольно много
                    времени, и требует значительного объёма оперативной памяти. Этот метод лучше
                    подходит для WEB приложений где вывод записей обычно происходит
                    постранично.</para>

                <para>Второй метод несколько более сложен в реализации, но позволяет быстро
                    открывать форму счёт-фактуры и менее требователен к ресурсам, однако при каждом
                    перемещении указателя в мастер гриде будет перевыполняться SQL запрос и
                    загружать сетевой трафик (хотя объём будет невелик).</para>

                <para>В нашем приложении я буду использовать второй подход. Для этого необходимо
                    написать обработчик события изменения текущей записи для компонента
                    BindingSource. <programlisting language="csharp">
<![CDATA[                        
private void masterBinding_CurrentChanged(object sender, EventArgs e) {
   LoadInvoiceLineData(this.CurrentInvoice.Id);
   detailGridView.DataSource = detailBinding;
} 
]]>
                </programlisting>
                </para>
                <para>Метод для загрузки данных о позициях счёт-фактуры выглядит следующим образом: <programlisting language="csharp">
<![CDATA[                        
private void LoadInvoiceLineData(int? id) {
    var dbContext = AppVariables.getDbContext();

    var lines =
        from line in dbContext.INVOICE_LINES
        where line.INVOICE_ID == id
        select new InvoiceLineView
        {
            Id = line.INVOICE_LINE_ID,
            Invoice_Id = line.INVOICE_ID,
            Product_Id = line.PRODUCT_ID,
            Product = line.PRODUCT.NAME,
            Quantity = line.QUANTITY,
            Price = line.SALE_PRICE,
            Total = Math.Round(line.QUANTITY * line.SALE_PRICE, 2)
        };

    detailBinding.DataSource = lines.ToBindingList();
}
]]>
                </programlisting>
                </para>
                <para>В качестве проекции мы использовали класс
                    <function>InvoiceLineView</function>. <programlisting language="csharp">
<![CDATA[                        
public class InvoiceLineView {
   public int Id { get; set; }
   public int Invoice_Id { get; set; }
   public int Product_Id { get; set; }
   public string Product { get; set; }
   public decimal Quantity { get; set; }
   public decimal Price { get; set; }
   public decimal Total { get; set; }
}
]]>
                </programlisting>
                </para>
                <para>Замечу, что в отличие от класса <function>InvoiceView</function> здесь
                    отсутствует метод для загрузки одной текущей записи. Здесь скорость перезагрузки
                    детейл грида не настолько критична, поскольку один документ не содержит тысячи
                    позиций, однако при желании вы можете реализовать такой метод. </para>
                <para>Добавим специальное свойство для получения текущей строки документа выделенной
                    в детейл гриде. <programlisting language="csharp">
<![CDATA[                        
public InvoiceLineView CurrentInvoiceLine {
    get {
        return (InvoiceLineView)detailBinding.Current;
    }
}
]]>
                </programlisting>
                </para>
                <para>В методах для добавления, редактирования и удаления мы покажем, как работать с
                    хранимыми процедурами в Entity Framework. Например, метод для добавления новой
                    записи выглядит так: <programlisting language="csharp">
<![CDATA[                        
private void btnAddInvoiceLine_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    // получаем текущую счёт-фактуру
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
    // проверяем не оплачена ли счёт-фактура
    if (invoice.PAYED == 1) {
        MessageBox.Show("Невозможно изменение, счёт-фактура оплачена.", "Error");
        return;
    }
    // создаём позицию счёт-фактуры
    var invoiceLine = dbContext.INVOICE_LINES.Create();
    invoiceLine.INVOICE_ID = invoice.INVOICE_ID;
    // создаём редактор позиции счёт фактуры
    using (InvoiceLineEditorForm editor = new InvoiceLineEditorForm()) {
        editor.Text = "Add invoice line";
        editor.InvoiceLine = invoiceLine;
        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
            if (editor.DialogResult == DialogResult.OK) {
              try {
                 // создаём параметры ХП
                 var invoiceIdParam = new FbParameter("INVOICE_ID", FbDbType.Integer);
                 var productIdParam = new FbParameter("PRODUCT_ID", FbDbType.Integer);
                 var quantityParam = new FbParameter("QUANTITY", FbDbType.Integer);
                 // инициализируем параметры значениями
                 invoiceIdParam.Value = invoiceLine.INVOICE_ID;
                 productIdParam.Value = invoiceLine.PRODUCT_ID;
                 quantityParam.Value = invoiceLine.QUANTITY;
                 // выполняем хранимую процедуру
                 dbContext.Database.ExecuteSqlCommand(
                   "EXECUTE PROCEDURE SP_ADD_INVOICE_LINE("
                        + "@INVOICE_ID, @PRODUCT_ID, @QUANTITY)", 
                   invoiceIdParam, 
                   productIdParam, 
                   quantityParam);
                 // обновляем гриды
                 // перезагрузка текущей записи счёт-фактуры
                 CurrentInvoice.Load(invoice.INVOICE_ID);
                 // перезагрузка всех записей детейл грида
                 LoadInvoiceLineData(invoice.INVOICE_ID);
                 // обновляем связанные данные
                 masterBinding.ResetCurrentItem();
              }
              catch (Exception ex) {
                 // отображаем ошибку
                 MessageBox.Show(ex.Message, "Error");
                 // не закрываем форму для возможности исправления ошибки
                 fe.Cancel = true;
              }
            }
        };
        // показываем модальную форму
        editor.ShowDialog(this);
    }
}
]]>
                </programlisting>
                </para>
                <para>Здесь обновление записи мастер грида требуется потому, что одно из его полей
                    (TotalSale) содержит агрегированную информацию по строкам документа.</para>
                <para>Метод для обновления записи реализован так. <programlisting language="csharp">
<![CDATA[                        
private void btnEditInvoiceLine_Click(object sender, EventArgs e) {
    var dbContext = AppVariables.getDbContext();
    // получаем текущую счёт-фактуру
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
    // проверяем не оплачена ли счёт-фактура
    if (invoice.PAYED == 1) {
        MessageBox.Show("Изменение не возможно, счёт фактура оплачена.", "Error");
        return;
    }
    // получаем текущую позицию счёт-фактуры
    var invoiceLine = invoice.INVOICE_LINES
        .Where(p => p.INVOICE_LINE_ID == this.CurrentInvoiceLine.Id)
        .First();
    // создаём редактор позиции счёт фактуры
    using (InvoiceLineEditorForm editor = new InvoiceLineEditorForm()) {
        editor.Text = "Edit invoice line";
        editor.InvoiceLine = invoiceLine;

        // Обработчик закрытия формы
        editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
           if (editor.DialogResult == DialogResult.OK) {
               try {
                   // создаём параметры ХП
                   var idParam = new FbParameter("INVOICE_LINE_ID", FbDbType.Integer);
                   var quantityParam = new FbParameter("QUANTITY", FbDbType.Integer);
                   // инициализируем параметры значениями
                   idParam.Value = invoiceLine.INVOICE_LINE_ID;
                   quantityParam.Value = invoiceLine.QUANTITY;
                   // выполняем хранимую процедуру
                   dbContext.Database.ExecuteSqlCommand(
                      "EXECUTE PROCEDURE SP_EDIT_INVOICE_LINE("
                         + "@INVOICE_LINE_ID, @QUANTITY)", 
                      idParam, 
                      quantityParam);
                   // обновляем гриды
                   // перезагрузка текущей записи счёт-фактуры
                   CurrentInvoice.Load(invoice.INVOICE_ID);
                   // перезагрузка всех записей детейл грида
                   LoadInvoiceLineData(invoice.INVOICE_ID);
                   // обновляем связанные контролы
                   masterBinding.ResetCurrentItem();
               }
               catch (Exception ex) {
                   // отображаем ошибку
                   MessageBox.Show(ex.Message, "Error");
                   // не закрываем форму для возможности исправления ошибки
                   fe.Cancel = true;
               }
           }
       };

       // показываем модальную форму
       editor.ShowDialog(this);
    }
}
]]>
                </programlisting>
                </para>
                <para>Метод для удаления записи реализован так. <programlisting language="csharp">
<![CDATA[                        
private void btnDeleteInvoiceLine_Click(object sender, EventArgs e) {
    var result = MessageBox.Show(
                "Вы действительно хотите удалить строку счёт-фактуры?",
                "Подтверждение",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);
    if (result == DialogResult.Yes) {
       var dbContext = AppVariables.getDbContext();
       // получаем текущую счёт-фактуру
       var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
       try {
           // проверяем не оплачена ли счёт-фактура
           if (invoice.PAYED == 1)
              throw new Exception("Не возможно удалить запись, счёт-фактура оплачена.");
           // создаём параметры ХП
           var idParam = new FbParameter("INVOICE_LINE_ID", FbDbType.Integer);
           // инициализируем параметры значениями
           idParam.Value = this.CurrentInvoiceLine.Id;
           // выполняем хранимую процедуру
           dbContext.Database.ExecuteSqlCommand(
              "EXECUTE PROCEDURE SP_DELETE_INVOICE_LINE(@INVOICE_LINE_ID)", 
              idParam);

           // обновляем гриды
           // перезагрузка текущей записи счёт-фактуры
           CurrentInvoice.Load(invoice.INVOICE_ID);
           // перезагрузка всех записей детейл грида
           LoadInvoiceLineData(invoice.INVOICE_ID);
           // обновляем связанные контролы
           masterBinding.ResetCurrentItem();
       }
       catch (Exception ex) {
           // отображаем ошибку
           MessageBox.Show(ex.Message, "Error");
       }
    }
}
]]>
                </programlisting>
                </para>
                <para>В методах для добавления и редактирования позиций счёт-фактуры мы использовали
                    форму для редактирования. <figure>
                        <title>Форма редактора позиций счёт-фактур</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/dotnet-invoiceline-editor-form.png"/>
                            </imageobject>
                            <textobject>
                                <phrase>Форма редактора позиций счёт-фактур.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>

                <para>Для отображения товара мы будем использовать TextBox. По нажатию кнопки,
                    расположенной рядом, будет вызываться модальная форма с гридом для выбора
                    товара. В качестве модальной окна для выбора продукта используем ту же форму,
                    что была создана для их отображения. Код обработчика нажатия кнопки и
                    инициализации формы будет выглядеть следующим образом: <programlisting language="csharp">
<![CDATA[                        
public partial class InvoiceLineEditorForm : Form {
    public InvoiceLineEditorForm() {
        InitializeComponent();
    }


    public INVOICE_LINE InvoiceLine { get; set; }

    private void InvoiceLineEditorForm_Load(object sender, EventArgs e) {
        if (this.InvoiceLine.PRODUCT != null) {
           edtProduct.Text = this.InvoiceLine.PRODUCT.NAME;
           edtPrice.Text = this.InvoiceLine.PRODUCT.PRICE.ToString("F2");
           btnChooseProduct.Click -= this.btnChooseProduct_Click;
        }
        if (this.InvoiceLine.QUANTITY == 0)
           this.InvoiceLine.QUANTITY = 1;
        edtQuantity.DataBindings.Add("Value", this.InvoiceLine, "QUANTITY");
    }

    private void btnChooseProduct_Click(object sender, EventArgs e) {
       GoodsForm goodsForm = new GoodsForm();
       if (goodsForm.ShowDialog() == DialogResult.OK) {
          InvoiceLine.PRODUCT_ID = goodsForm.CurrentProduct.Id;
          edtProduct.Text = goodsForm.CurrentProduct.Name;
          edtPrice.Text = goodsForm.CurrentProduct.Price.ToString("F2");
       }
   }
}
]]>
                </programlisting>
                </para>
            </section>

            <section>
                <title>Работа с транзакциями</title>

                <para>Когда мы вызываем при добавлении, обновлении, удалении метод
                        <function>SaveChanges()</function>, то фактически Entity Framework неявно
                    стартует и завершает транзакцию. Поскольку используется отсоединённая модель, то
                    все операции происходят в рамках одной транзакции. Кроме того EF автоматически
                    стартует и завершает транзакцию при каждом извлечении данных. Рассмотрим работу
                    автоматических транзакций на следующем примере. Допустим нам необходимо сделать
                    скидку на товары, выделенные в гриде. Код без явного использования транзакций
                    будет выглядеть следующим образом: <programlisting language="csharp">
<![CDATA[                        
var dbContext = AppVariables.getDbContext();
foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
    int id = (int)gridRows.Cells["Id"].Value;
    // здесь происходит неявный старт и завершение транзакции
    var product = dbContext.PRODUCTS.Find(id);
    // скидка 10%
    decimal discount = 10.0m;
    product.PRICE = product.PRICE * (100 - discount) /100;
}
// здесь происходит неявный старт и завершение транзакции
// все изменения происходят за одну транзакцию
dbContext.SaveChanges();
]]>
                </programlisting>
                </para>
                <para>Допустим, мы выбрали 10 товаров. В этом случае будет неявно использовано 10
                    транзакций для поиска товара по идентификатору и одиннадцатая для сохранения
                    изменений. В данном случае можно использовать всего одну транзакцию, если
                    использовать явное управление транзакциями. Например, вот так: <programlisting language="csharp">
<![CDATA[                        
var dbContext = AppVariables.getDbContext();
// явный старт транзакции по умолчанию
using (var dbTransaction = dbContext.Database.BeginTransaction()) {
    string sql =
         "UPDATE PRODUCT " +
         "SET PRICE =  PRICE * ROUND((100 - @DISCOUNT)/100, 2) " +
         "WHERE PRODUCT_ID = @PRODUCT_ID";
    try {
        // создаём параметры запроса
        var idParam = new FbParameter("PRODUCT_ID", FbDbType.Integer);
        var discountParam = new FbParameter("DISCOUNT", FbDbType.Decimal);
        // создаём SQL команду для обновления записей
        var sqlCommand = dbContext.Database.Connection.CreateCommand();
        sqlCommand.CommandText = sql;
        // указываем команде, какую транзакцию использовать
        sqlCommand.Transaction = dbTransaction.UnderlyingTransaction;
        sqlCommand.Parameters.Add(discountParam);
        sqlCommand.Parameters.Add(idParam);
        // подготавливаем команду
        sqlCommand.Prepare();
        // для всех выделенных записей в гриде
        foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
            int id = (int)gridRows.Cells["Id"].Value;
            // инициализируем параметры запроса
            idParam.Value = id;
            discountParam.Value = 10.0m; // скидка 10%
            // выполняем sql запрос
            sqlCommand.ExecuteNonQuery();
        }
        dbTransaction.Commit();
    }
    catch (Exception ex) {
        dbTransaction.Rollback();
        MessageBox.Show(ex.Message, "error");                 
    }
}
]]>
                </programlisting>
                </para>
                <para>В данном случае мы стартовали транзакцию с параметрами по умолчанию. Для того
                    чтобы задавать свои параметры транзакции необходимо использовать метод
                    UseTransaction. <programlisting language="csharp">
<![CDATA[                        
private void btnDiscount_Click(object sender, EventArgs e) {         
    DiscountEditorForm editor = new DiscountEditorForm();

    editor.Text = "Enter discount";
    if (editor.ShowDialog() != DialogResult.OK)
        return;


    bool needUpdate = false;

    var dbContext = AppVariables.getDbContext();
    var connection = dbContext.Database.Connection;
    // явный старт транзакции по умолчанию
    using (var dbTransaction = connection.BeginTransaction(IsolationLevel.Snapshot)) {
        dbContext.Database.UseTransaction(dbTransaction);
        string sql =
            "UPDATE PRODUCT " +
            "SET PRICE =  ROUND(PRICE * (100 - @DISCOUNT)/100, 2) " +
            "WHERE PRODUCT_ID = @PRODUCT_ID";
        try {
            // создаём параметры запроса
            var idParam = new FbParameter("PRODUCT_ID", FbDbType.Integer);
            var discountParam = new FbParameter("DISCOUNT", FbDbType.Decimal);
            // создаём SQL комманду для обновления записей
            var sqlCommand = connection.CreateCommand();
            sqlCommand.CommandText = sql;
            // указываем команде какую транзакцию использовать
            sqlCommand.Transaction = dbTransaction;
            sqlCommand.Parameters.Add(discountParam);
            sqlCommand.Parameters.Add(idParam);
            // подготавливаем команду
            sqlCommand.Prepare();
            // для всех выделенных записей в гриде
            foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
                int id = (int)gridRows.Cells["PRODUCT_ID"].Value;
                // инициализируем параметры запроса
                idParam.Value = id;
                discountParam.Value = editor.Discount;
                // выполняем sql запрос                            
                needUpdate = (sqlCommand.ExecuteNonQuery() > 0) || needUpdate;
            }
            dbTransaction.Commit();
        }
        catch (Exception ex) {
            dbTransaction.Rollback();
            MessageBox.Show(ex.Message, "error");
            needUpdate = false;
        }
    }
    // перезагружаем содержимое грида
    if (needUpdate) {
       // для всех выделенных записей в гриде
       foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
            var product = (PRODUCT)bindingSource.List[gridRows.Index];
            dbContext.Refresh(RefreshMode.StoreWins, product);
       }
       bindingSource.ResetBindings(false);
    }

}
]]>
                </programlisting>
                </para>
                <para>Ну вот. Теперь у нас для всего набора обновлений используется всего одна
                    транзакция, и нет лишних команд для поиска данных. Осталось только добавить
                    диалог для ввода значения скидки и обновление данных в гриде. Попробуйте сделать
                    это самостоятельно.</para>
                <para>В заключении приведём скриншот готового приложения. <figure>
                        <title>Скриншот готового приложения</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/dotnet-winform-app.png" width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Скриншот готового приложения</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
            </section>
            <section>
                <title>Заключение</title>

                <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_dot_NET_source.zip"
                        >Исходные коды примера приложения</link></para>
                <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.ibase.ru/files/articles/firebird_examples/firebird_example_database.zip"
                        >Готовая БД 2.5 и 3.0</link></para>
                <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.ibase.ru">www.ibase.ru</link>, <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.ibsurgeon.com">www.ibsurgeon.com</link></para>
                <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="mailto:support@ibase.ru">support@ibase.ru</link>, <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="mailto:support@ib-aid.com">support@ib-aid.com</link></para>
            </section>
        </section>
    </section>
    <section>
        <title>Создание Web приложений с использованием Entity Framework</title>

        <para>В данной главе будет описан процесс создания web приложений для СУБД Firebird с
            использованием Entity Framework и среды Visual Studio 2015.</para>

        <para>В данной главе обсуждаются особенности создания именно Web приложений, базовые
            принципы работы с Entity Framework и Firebird описаны в предыдущей главе <link
                linkend="app-ef-winform">«Создание приложений с использованием Entity
                Framework»</link>.</para>
        <para>Платформа .NET предоставляет два основных фреймворка для создания web приложений:
            ASP.NET Web Forms и ASP.NET MVC. Я предпочитаю использовать паттерн MVC, поэтому в
            дальнейшем будет описываться именно эта технология.</para>
        <para>Платформа <emphasis role="bold">ASP.NET MVC</emphasis> представляет собой фреймворк
            для создания сайтов и веб-приложений с помощью реализации паттерна MVC.</para>
        <para>Концепция паттерна (шаблона) MVC (model - view - controller) предполагает разделение
            приложения на три компонента:<itemizedlist>
                <listitem>
                    <para><emphasis role="bold">Контроллер</emphasis> (controller). Контроллеры
                        осуществляют взаимодействие с пользователем, работу с моделью, а также выбор
                        представления, отображающего пользовательский интерфейс. В приложении MVC
                        представления только отображают данные, а контроллер обрабатывает вводимые
                        данные и отвечает на действия пользователя. Например, контроллер может
                        обрабатывать строковые значения запроса и передавать их в модель, которая
                        может использовать эти значения для отправки запроса в базу данных.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Представление</emphasis> (view) — это собственно
                        визуальная часть или пользовательский интерфейс приложения. Пользовательский
                        интерфейс обычно создаётся на основе данных модели.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Модель</emphasis> (model). Объекты моделей являются
                        частями приложения, реализующими логику для работы данными приложения.
                        Объекты моделей часто получают и сохраняют состояние модели в базе
                        данных.</para>
                </listitem>
            </itemizedlist></para>

        <para>Общую схему взаимодействия этих компонентов можно представить следующим образом: <figure>
                <title>Структура MVC паттерна</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/mvc.png"/>
                    </imageobject>
                    <textobject>
                        <phrase>Структура MVC паттерна</phrase>
                    </textobject>
                </mediaobject>
            </figure>
        </para>

        <para>Шаблон MVC позволяет создавать приложения, различные аспекты которых (логика ввода,
            бизнес-логика и логика интерфейса) разделены, но достаточно тесно взаимодействуют друг с
            другом. Эта схема указывает расположение каждого вида логики в приложении.
            Пользовательский интерфейс располагается в представлении. Логика ввода располагается в
            контроллере. Бизнес-логика находится в модели. Это разделение позволяет работать со
            сложными структурами при создании приложения, так как обеспечивает одновременную
            реализацию только одного аспекта. Например, разработчик может сконцентрироваться на
            создании представления отдельно от бизнес-логики.</para>
        <para>Более полную информацию о технологии ASP.NET MVC вы можете найти на сайте <link
                xmlns:xlink="http://www.w3.org/1999/xlink"
                xlink:href="http://www.asp.net/mvc/overview">сообщества ASP.NET</link> .</para>
        <para>Помимо библиотек для работы с Firebird, Entity Framework и MVC.NET нам потребуется
            множество JavaScript библиотек для поддержки отзывчивого интерфейса, таких как jquery,
            jquery-ui, Bootstrap, jqGrid. В этом примере мы постарались приблизить интерфейс
            веб-приложения к настольным приложениям, активно применяя грибы для отображения и
            модальные окна для ввода данных.</para>
        <section>
            <title>Подготовка Visual Studio 2015 для работы с Firebird</title>

            <para>Для работы Visual Studio с СУБД Firebird вам придётся проделать несколько
                дополнительных шагов, которые подробно были описаны в предыдущей главе "Создание
                приложений с использованием Entity Framework" в разделе <link
                    linkend="app-dotnet-vsprepare">Подготовка Visual Studio 2015 для работы с
                    Firebird</link>. </para>
        </section>

        <section>
            <title>Создание проекта</title>

            <para>Посмотрим как создаётся каркас MVC.NET приложения с помощью мастеров Visual
                Studio.</para>

            <para>Итак, откроем Visual Studio 2015 <guimenu>Файл -> Создать -> Проект</guimenu> и
                создадим новый проект. Назовём новый проект FBMVCExample.</para>

            <figure>
                <title>Создание проекта</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/mvcnet-createproject.png" width="680"/>
                    </imageobject>
                    <textobject>
                        <phrase>Создание проекта</phrase>
                    </textobject>
                </mediaobject>
            </figure>

            <figure>
                <title>Создание MVC.NET проекта</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/mvcnet-createaspnet.png" width="680"/>
                    </imageobject>
                    <textobject>
                        <phrase>Создание MVC.NET проекта</phrase>
                    </textobject>
                </mediaobject>
            </figure>

            <para>Изменим способ проверки подлинности. В данный момент создадим веб приложение без
                проверки подлинности. К этому вопросу мы вернёмся чуть позже. <figure>
                    <title>Выбор способа проверки подлинности</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/mvcnet-auth.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Выбор способа проверки подлинности</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>После этого будет создан проект, который практически не обладает никакой
                функциональностью, хотя уже имеет базовую структуру. <table>
                    <?dbfo keep-together='auto'?>
                    <title>Структура папок MVC.NET проекта</title>

                    <tgroup cols="2">
                        <colspec colwidth="2*" align="left"/>
                        <colspec colwidth="4*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Папка или файл</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="middle">
                                <entry>/App_Data</entry>
                                <entry><para>В эту папку помещаются закрытые данные веб приложения,
                                        такие как XML-файлы или файлы базы данных.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/App_Start</entry>
                                <entry><para>Эта папка содержит ряд основных настроек конфигурации
                                        для проекта, в том числе определение маршрутов и
                                        фильтров.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Content</entry>
                                <entry><para>Сюда помещается статическое содержимое, такое как
                                        CSS-файлы и изображения. Это является необязательным
                                        соглашением. Вы можете хранить файлы стилей в любом
                                        подходящем месте.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Controllers</entry>
                                <entry><para>Сюда помещаются классы контроллеров. Это необязательное
                                        соглашение. Вы можете классы контроллеров где
                                    угодно.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Models</entry>
                                <entry><para>Сюда помещаются классы моделей представлений и моделей
                                        предметной области, хотя все кроме простейших приложений
                                        выигрывают от определения модели предметной области в
                                        отдельном проекте. Это необязательное соглашение. Вы можете
                                        размещать классы моделей в любом удобном
                                    месте.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Scripts</entry>
                                <entry><para>Эта папка предназначена для хранения библиотек
                                        JavaScript, используемых в приложении. По умолчанию Visual
                                        Studio добавляет библиотеки jQuery и несколько других
                                        популярных JavaScript-библиотек. Это необязательное
                                        соглашение.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Views</entry>
                                <entry><para>В этой папке хранятся представления и частичные
                                        представления, обычно сгруппированные вместе в папках с
                                        именами контроллеров, с которыми они связаны.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Views/Shared</entry>
                                <entry><para>В этой папке хранятся компоновки и представления, не
                                        являющиеся специфичными для какого-либо
                                    контроллера.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Views/Web.config</entry>
                                <entry><para>Это конфигурационный файл. В нем содержится
                                        конфигурационная информация, которая обеспечивает обработку
                                        представлений с помощью ASP.NET и предотвращает их
                                        обслуживание веб-сервером IIS, а также пространства имён, по
                                        умолчанию импортируемые в представления.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Global.asax</entry>
                                <entry><para>Это глобальный класс приложения ASP.NET. В файле его
                                        кода (Global.asax.cs) регистрируется конфигурация маршрутов,
                                        а также предоставляется любой код, который должен
                                        выполняться при запуске или завершении приложения либо в
                                        случае возникновения необработанного
                                    исключения.</para></entry>
                            </row>
                            <row valign="middle">
                                <entry>/Web.config</entry>
                                <entry><para>Конфигурационный файл для приложения.</para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>Теперь добавим необходимые пакеты с помощью менеджера пакетов NuGet. Нам
                потребуются установить недостающие пакеты:<itemizedlist spacing="compact">
                    <listitem>
                        <para>FirebirdSql.Data.FirebirdClient</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>EntityFramework.Firebird</para>
                    </listitem>
                    <listitem>
                        <para>Bootstrap (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>jQuery (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>jQuery.UI.Combined</para>
                    </listitem>
                    <listitem>
                        <para>Respond (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>Newtonsoft.Json</para>
                    </listitem>
                    <listitem>
                        <para>Moderninzr (автоматически добавлен мастером)</para>
                    </listitem>
                    <listitem>
                        <para>Trirand.jqGrid</para>
                    </listitem>
                </itemizedlist></para>
            <note>
                <para>Не все пакеты, предоставляемые NuGet, являются библиотеками последних версий.
                    Особенно это касается JavaScript библиотек. Вы можете подключать последние
                    версии JavaScript библиотек, используя CDN или просто скачать их, заменив
                    библиотеки, предоставленные NuGet.</para>
            </note>
            <para>Для этого необходимо щёлкнуть правой клавишей мыши по имени проекта в обозревателе
                решений и в выпадающем меню выбрать пункт «Управление пакетами NuGet». <figure>
                    <title>Контекстное меню обозревателя решений</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/mvcnet-nugetmenu.png"/>
                        </imageobject>
                        <textobject>
                            <phrase>Контекстное меню обозревателя решений</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>В появившемся менеджере пакетов произвести поиск и установку необходимых пакетов. <figure>
                    <title>Менеджер пакетов NuGet</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/mvcnet-nuget.png" width="680"/>
                        </imageobject>
                        <textobject>
                            <phrase>Менеджер пакетов NuGet</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
        </section>

        <section>
            <title>Создание EDM модели</title>

            <para>Если у вас уже есть Windows Forms приложение, которое использует Entity Framework,
                то вы просто можете перенести кассы моделей в папку <filename>Models</filename>. В
                противном случае вам необходимо будет создать их с нуля. Подробно процесс создания
                EDM модели описан в предыдущей главе «Создание приложений с использованием Entity
                Framework» (см. раздел <link linkend="app-dotnet-createedm">«Создание EDM
                    модели»</link>).</para>

            <para>Существует одно небольшое отличие. В процессе работы мастера создания модели у вас
                спросят, как хранить строку подключения. <figure>
                    <title>Сохранение строки подключения</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/dotnet-save-connectionstring.png" width="680"
                            />
                        </imageobject>
                        <textobject>
                            <phrase>Сохранение строки подключения.</phrase>
                        </textobject>
                    </mediaobject>
                </figure>
            </para>
            <para>Поскольку мы создаём веб приложение, где все пользователи будут работать с базой
                данных под одной и той же учётной записью, то смело выбираем «Да». В качестве имени
                пользователя может быть указан любой пользователь с достаточными привилегиями.
                Желательно не использовать пользователя SYSDBA, поскольку он обладает повышенными
                привилегиями, которые не требуются для функционирования веб приложения. Вы всегда
                можете это изменить в готовом приложении, просто отредактировав строку подключения в
                файле конфигурации приложения
                    <filename><replaceable>AppName</replaceable>.exe.conf</filename>. Строка
                подключения будет сохранена в секции connectionStrings примерно в таком виде <programlisting language="xml">
<![CDATA[
<add name="DbModel" 
     connectionString="character set=UTF8; data source=localhost; 
                       initial catalog=examples; port number=3050; 
                       user id=sysdba; dialect=3; isolationlevel=Snapshot; 
                       pooling=True; password=masterkey;" 
     providerName="FirebirdSql.Data.FirebirdClient" />
]]>                
            </programlisting>
            </para>
        </section>
        <section>
            <title>Создание пользовательского интерфейса справочников</title>

            <section>
                <title>Контроллеры</title>

                <para>Итак, создадим наш первый контроллер. Он будет служить для отображения и ввода
                    данных о поставщиках. <figure>
                        <title>Меню добавления контроллера</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-menu-addcontroller.png"
                                    width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Меню добавления контроллера.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                    <figure>
                        <title>Добавление контроллера</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-addcontroller-wizard1.png"
                                    width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Добавление контроллера.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                    <figure>
                        <title>Мастер создания контроллера</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-addcontroller-wizard2.png"
                                    width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Мастер создания контроллера.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>После этих действий будет создан контроллер
                        <classname>CustomerController</classname> и 5 представлений: для отображения
                    списка поставщиков, детализации поставщика, формы для создания, редактирования и
                    удаления поставщика. Поскольку мы будем активно применять технологию Ajax и
                    библиотеку jqGrid, то нам будет достаточно всего одного представления для
                    отображения списка поставщиков в виде таблицы, остальные действия будут
                    выполняться с помощью jqGrid.</para>
                <para>Список поставщиков может оказаться довольно большим. В отличие от настольных
                    приложений в Web приложениях обычно не принято возвращать весь большой список,
                    потому что это может сильно замедлить загрузку страницы. Вместо этого обычно
                    используют постраничное разбиение данных, или динамическую дозагрузку данных,
                    когда при прокрутке пользователь достигает конца страницы (или грида). В нашем
                    примере мы воспользуемся первым вариантом.</para>
                <para>Ещё одной особенностью при создании веб приложений является то, что в них
                    отсутствует постоянное соединение с базой данных. Это обусловлено тем, что сам
                    скрипт формирования страницы «живёт» не дольше чем время для формирования ответа
                    на запрос пользователя. Само по себе соединение с базой данных – это довольно
                    дорогой ресурс, поэтому его надо экономить. Конечно, для уменьшения времени
                    установления соединения с базой данных придумали пул соединений, но всё равно
                    желательно, чтобы соединение с базой данных происходило только тогда когда это
                    действительно необходимо. Одним из способов снижения количества взаимодействий с
                    базой данных является перенос проверки правильности введённых данных на сторону
                    браузера. К счастью современные HTML5 и JavaScript библиотеки могут это делать.
                    Например, вы можете проверять обязательность поля на форме ввода, или
                    максимальную длину строковых полей.</para>
                <para>Итак давайте изменим контроллер <classname>CustomerController</classname> для
                    того чтобы он работал с jqGrid. В тексте контроллера сделаны поясняющие
                    комментарии. <programlisting language="csharp">
<![CDATA[
public class CustomerController : Controller
{
    private DbModel db = new DbModel();

    // Отображение представления
    public ActionResult Index()
    {
        return View();
    }

    // Получение данных в виде JSON для грида
    public ActionResult GetData(int? rows, int? page, string sidx, string sord, 
        string searchField, string searchString, string searchOper)
    {
        // получаем номер страницы, количество отображаемых данных
        int pageNo = page ?? 1;
        int limit = rows ?? 20;
        // вычисляем смещение
        int offset = (pageNo - 1) * limit;

        // строим запрос для получения поставщиков
        var customersQuery =
            from customer in db.CUSTOMERS             
            select new
            {
                CUSTOMER_ID = customer.CUSTOMER_ID,
                NAME = customer.NAME,
                ADDRESS = customer.ADDRESS,
                ZIPCODE = customer.ZIPCODE,
                PHONE = customer.PHONE
            };
        // добавлением в запрос условия поиска, если он производится
        if (searchField != null)
        {
            switch (searchOper)
            {
                case "eq":
                    customersQuery = customersQuery.Where(
                        c => c.NAME == searchString);
                    break;
                case "bw":
                    customersQuery = customersQuery.Where(
                        c => c.NAME.StartsWith(searchString));
                    break;
                case "cn":
                    customersQuery = customersQuery.Where(
                        c => c.NAME.Contains(searchString));
                    break;
            }
        }
        // получаем общее количество поставщиков
        int totalRows = customersQuery.Count();
        // добавляем сортировку
        switch (sord) {
            case "asc":
                customersQuery = customersQuery.OrderBy(
                    customer => customer.NAME);
                break;
            case "desc":
                customersQuery = customersQuery.OrderByDescending(
                    customer => customer.NAME);
                break;
        }

        // получаем список поставщиков
        var customers = customersQuery
             .Skip(offset)
             .Take(limit)
             .ToList();

        // вычисляем общее количество страниц
        int totalPages = totalRows / limit + 1;

        // создаём результат для jqGrid
        var result = new
        {
            page = pageNo,
            total = totalPages,
            records = totalRows,
            rows = customers
        };
        // преобразуем результат в JSON
        return Json(result, JsonRequestBehavior.AllowGet);
    }

    // Добавление нового поставщика
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Create(
      [Bind(Include = "NAME,ADDRESS,ZIPCODE,PHONE")] CUSTOMER customer)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            // получаем новый идентификатор с помощью генератора
            customer.CUSTOMER_ID = db.NextValueFor("GEN_CUSTOMER_ID");
            // добавляем модель в список
            db.CUSTOMERS.Add(customer);
            // сохраняем модель
            db.SaveChanges();
            // возвращаем успех в формате JSON
            return Json(true);
        }
        else {
            // соединяем ошибки модели в одну строку
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }

    // Редактирование поставщика
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Edit(
      [Bind(Include = "CUSTOMER_ID,NAME,ADDRESS,ZIPCODE,PHONE")] CUSTOMER customer)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            // помечаем модель как изменённую
            db.Entry(customer).State = EntityState.Modified;
            // сохраняем модель
            db.SaveChanges();
            // возвращаем успех в формате JSON
            return Json(true);
         }
         else {
            // соединяем ошибки модели в одну строку
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
         }
    }

    // Удаление поставщика
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Delete(int id)
    {
        // ищем поставщика по идентификатору
        CUSTOMER customer = db.CUSTOMERS.Find(id);
        // удаляем поставщика
        db.CUSTOMERS.Remove(customer);
        // сохраняем модель
        db.SaveChanges();
        // возвращаем успех в формате JSON
        return Json(true);
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            db.Dispose();
        }
        base.Dispose(disposing);
    }
}
]]>                    
                </programlisting>
                </para>

                <para>Метод <function>Index</function> служит для отображения представления
                    Views/Cusomter/Index.cshtml. Само представление будет представлено чуть позже. В
                    общем, это представление представляет собой шаблон html страницы с разметкой и
                    JavaScript для инициализации jqGrid. Сами данные будут получены в асинхронном
                    режиме в формате JSON с помощью технологии Ajax. В зависимости от выбранной
                    сортировки, номера страницы и параметров поиска формируется HTTP запрос, который
                    будет обработан действием <function>GetData</function>. Параметры http запроса
                    отображаются на входные аргументы метода <function>GetData</function>. В
                    соответствии с этими параметры мы формируем LINQ запрос, и отправляем полученный
                    результат в формате JSON.</para>

                <note>
                    <para>Для разбора параметров запроса формируемого jqGrid и упрощения построения
                        модели существуют различные библиотеки. Мы не использовали их в наших
                        примерах, и поэтому код может быть несколько громоздким. Однако вы всегда
                        можете улучшить его.</para>
                </note>

                <para>Метод <function>Create</function> предназначен для добавления новой записи о
                    поставщике. Параметры HTTP запроса с типом POST (у метода указан атрибут
                    [HttpPost]) будут отображены на модель <classname>Cusotmer</classname>. Обратите
                    внимание на строку
                    <programlisting language="csharp">
[Bind(Include = "NAME,ADDRESS,ZIPCODE,PHONE")] CUSTOMER customer                
                </programlisting>
                    Здесь Bind указывает, какие параметры HTTP запроса отображать на свойства
                    модели. </para>
                <para>Обратите внимание на атрибут <emphasis role="bold"
                        >ValidateAntiforgeryToken</emphasis>, он предназначен для противодействия
                    подделке межсайтовых запросов, производя верификацию токенов при обращении к
                    методу действия. Наличие этого атрибута требует чтобы в HTTP запросе
                    присутствовал дополнительный параметр
                        <property>__RequestVerificationToken</property>. Этот параметр автоматически
                    добавляется в каждую форму в которой указан хелпер
                        <function>@Html.AntiForgeryToken()</function>. Однако библиотека jqGrid
                    использует динамически формируемые Ajax запросы, а не заранее созданные веб
                    формы. Давайте исправим это. Для этого изменим обобщённое представлении
                        <filename>Views/Shared/_Layout.cshtml</filename> следующим образом <programlisting language="javascript">
<![CDATA[
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewBag.Title – приложение ASP.NET</title>
    @Styles.Render("~/Content/css")
    @Scripts.Render("~/bundles/modernizr")
    @Scripts.Render("~/bundles/jquery")
    @Scripts.Render("~/bundles/jquery-ui")

    <link href="~/Content/jquery.jqGrid/ui.jqgrid.css" 
          rel="stylesheet" type="text/css" />
    <link href="~/Content/jquery.jqGrid/ui.jqgrid-bootstrap.css" 
          rel="stylesheet" type="text/css" />
    <link href="~/Content/jquery.jqGrid/ui.jqgrid-bootstrap-ui.css" 
          rel="stylesheet" type="text/css" />

    <script src="~/Scripts/jquery.jqGrid.min.js" type="text/javascript"></script>
    <script src="~/Scripts/i18n/grid.locale-ru.js" type="text/javascript"></script>
</head>
<body>
    @Html.AntiForgeryToken()
    <script>
      // получение AntiForgery токена
      function GetAntiForgeryToken() {
        var tokenField = 
          $("input[type='hidden'][name$='RequestVerificationToken']");
        if (tokenField.length == 0) {
            return null;
        } else {
            return {
                name: tokenField[0].name,
                value: tokenField[0].value
            };
        }
      }

      // добавляем префильтр на все ajax запросы
      // он будет добавлять к любому POST ajax запросу
      // AntiForgery токен
      $.ajaxPrefilter(
          function (options, localOptions, jqXHR) {
              if (options.type !== "GET") {
                  var token = GetAntiForgeryToken();
                  if (token !== null) {
                      if (options.data.indexOf("X-Requested-With") === -1) {
                          options.data = "X-Requested-With=XMLHttpRequest" 
                              + ((options.data === "") ? "" : "&" + options.data);
                      }
                      options.data = options.data + "&" + token.name + '=' 
                                   + token.value;
                  }
              }
          }
      );
      // инициализируем общие свойства модуля jqGrid
      $.jgrid.defaults.width = 780;
      $.jgrid.defaults.responsive = true;
      $.jgrid.defaults.styleUI = 'Bootstrap';
    </script>
    <!-- Навигационное меню -->
    <div class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" 
                        data-target=".navbar-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="navbar-collapse collapse">
                <ul class="nav navbar-nav">                    
                    <li>@Html.ActionLink("Поставщики", "Index", "Customer")</li>
                    <li>@Html.ActionLink("Товары", "Index", "Product")</li>
                    <li>@Html.ActionLink("Накладные", "Index", "Invoice")</li>                                       
                </ul>
            </div>
        </div>
    </div>
    <div class="container body-content">
        @RenderBody()
        <hr />
        <footer>
            <p>&copy; @DateTime.Now.Year – приложение ASP.NET</p>
        </footer>
    </div>
    
    @Scripts.Render("~/bundles/bootstrap")
    @RenderSection("scripts", required: false)
</body>
</html>
]]>                    
                </programlisting>
                </para>
            </section>

            <section>
                <title>Бандлы</title>

                <para>Бандлы предназначены для упрощения подключения JavaScript скриптов и файлов
                    стилей. С помощью хелпера Styles.Render подключаются бандлы стилей, а с помощью
                    хелпера Scripts.Render — бандлы скриптов.</para>

                <para>Регистрация бандлов осуществляется в файле
                        <filename>BundleConfig.cs</filename>, который находится в папке
                        <filename>App_Start</filename>:
                    <programlisting language="csharp">
public static void RegisterBundles(BundleCollection bundles)
{
    bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
                        "~/Scripts/jquery-{version}.js"));

    bundles.Add(new ScriptBundle("~/bundles/jqueryval").Include(
                        "~/Scripts/jquery.validate*"));

    bundles.Add(new ScriptBundle("~/bundles/jquery-ui").Include(
                        "~/Scripts/jquery-ui-{version}.js"));

    bundles.Add(new ScriptBundle("~/bundles/modernizr").Include(
                        "~/Scripts/modernizr-*"));

    bundles.Add(new ScriptBundle("~/bundles/bootstrap").Include(
                      "~/Scripts/bootstrap.js",
                      "~/Scripts/respond.js"));

    bundles.Add(new StyleBundle("~/Content/css").Include(
                      "~/Content/jquery-ui.min.css",
                      "~/Content/themes/ui-darkness/jquery-ui.min.css",
                      "~/Content/themes/ui-darkness/theme.css",
                      "~/Content/bootstrap.min.css",                     
                      "~/Content/Site.css"
                ));
}                   
                </programlisting>
                </para>
                <para> Здесь метод RegisterBundles добавляет все создаваемые бандлы в коллекцию
                    bundles. Объявление бандла выглядит следующим образом:
                    <programlisting language="csharp">
new ScriptBundle("~/bundles/jquery").Include("~/Scripts/jquery-{version}.js")
                    </programlisting>
                </para>
                <para>В конструктор <function>ScriptBundle</function> передаётся виртуальный путь
                    бандла. А с помощью метода <function>Include</function> в данный бандл
                    включаются конкретные файлы скриптов.</para>
                <para>В выражении "~/Scripts/jquery-{version}.js" параметр {version} является
                    заменителем для любого символьного обозначения версии скрипта. Это очень удобно,
                    поскольку через некоторое время мы можем поменять версию библиотеки, но при этом
                    в коде нам ничего не придётся менять, так как система уже автоматически примет
                    новую версию.</para>
                <para>Выражение "~/Scripts/jquery.validate*" с помощью знака звёздочки заменяет
                    остальную часть строки. Например, это выражение подключит в бандл сразу два
                    файла: <filename>jquery.validate.js</filename> и
                        <filename>jquery.validate.unobtrusive.js</filename> (и их минимизированные
                    версии), так как их названия начинаются с jquery.validate*".</para>
                <para>То же самое касается и создания бандлов стилей, только в этом случае
                    используется класс <classname>StyleBundle</classname>.</para>
                <para>Во время отладки желательно иметь полные версии скриптов и стилей, а при
                    развёртывании приложения – минифицированные. Бандлы позволяют решить эту задачу.
                    Когда приложение находится в режиме отладки, то файле
                        <filename>web.config</filename> параметр &lt;compilation debug="true"&gt;.
                    При изменении этого параметра на значение <literal>false</literal> (режим
                    компиляции Release ) вместо полных версий JavaScript модулей и файлов CSS стилей
                    будут использоваться минифицированные.</para>
            </section>

            <section>
                <title>Представления</title>

                <para>Из всех автоматически созданных представлений для контроллера Customer нам
                    потребуется только один View/Customer/Index.cshtml, остальные можно удалить из
                    этой папки.</para>

                <para>
                    <programlisting language="javascript">
<![CDATA[
@{
    ViewBag.Title = "Index";
}

<h2>Customers</h2>

<table id="jqg"></table>
<div id="jqg-pager"></div>

<script type="text/javascript">
    $(document).ready(function () {

        var dbGrid = $("#jqg").jqGrid({
            url: '@Url.Action("GetData")', // url для получения данных
            datatype: "json", // формат получения данных 
            mtype: "GET",     // тип http запроса
            // описание модели
            colModel: [
                {
                    label: 'Id',          // подпись
                    name: 'CUSTOMER_ID',  // имя поля
                    key: true,            // признак ключевого поля
                    hidden: true          // скрыт 
                },
                {
                    label: 'Name',
                    name: 'NAME',
                    width: 250,           // ширина
                    sortable: true,       // разрешена сортировка
                    editable: true,       // разрешено редактирование
                    edittype: "text",     // тип поля в редакторе
                    search: true,         // разрешён поиск
                    searchoptions: {
                        sopt: ['eq', 'bw', 'cn'] // разрешённые операторы поиска
                    },
                    // размер и максимальная длина для поля ввода
                    editoptions: { size: 30, maxlength: 60 }, 
                    // говорит о том что поле обязательное
                    editrules: { required: true } 
                },
                {
                    label: 'Address',
                    name: 'ADDRESS',
                    width: 300,
                    sortable: false,    // запрещаем сортировку
                    editable: true,     // редактируемое
                    search: false,      // запрещаем поиск
                    edittype: "textarea",
                    editoptions: { maxlength: 250, cols: 30, rows: 4 }
                },
                {
                    label: 'Zip Code',
                    name: 'ZIPCODE',
                    width: 30,
                    sortable: false,
                    editable: true,
                    search: false,
                    edittype: "text",
                    editoptions: { size: 30, maxlength: 10 },
                },
                {
                    label: 'Phone',
                    name: 'PHONE',
                    width: 80,
                    sortable: false,
                    editable: true,
                    search: false,
                    edittype: "text",
                    editoptions: { size: 30, maxlength: 14 },
                }
            ],
            rowNum: 500, // число отображаемых строк
            loadonce: false, // загрузка только один раз
            sortname: 'NAME', // сортировка по умолчанию по столбцу NAME
            sortorder: "asc", // порядок сортировки
            width: window.innerWidth - 80, // ширина грида
            height: 500,      // высота грида
            viewrecords: true, // отображать количество записей
            caption: "Customers", // подпись к гриду
            pager: 'jqg-pager'  // элемент для отображения навигации
        });

        dbGrid.jqGrid('navGrid', '#jqg-pager', {
            search: true,  // поиск
            add: true,     // добавление
            edit: true,    // редактирование
            del: true,     // удаление
            view: true,    // просмотр записи
            refresh: true, // обновление
            // подписи кнопок
            searchtext: "Поиск",
            addtext: "Добавить",
            edittext: "Изменить",
            deltext: "Удалить",
            viewtext: "Смотреть",
            viewtitle: "Выбранная запись",
            refreshtext: "Обновить"
        },
        update("edit"), // обновление
        update("add"), // добавление    
        update("del") // удаление
        );

        // функция возвращающая настройки редактора
        function update(act) {
            return {
                closeAfterAdd: true, // закрыть после добавления
                closeAfterEdit: true, // закрыть после редактирования
                width: 400,           // ширина редактора
                reloadAfterSubmit: true, // обновление
                drag: true,              // перетаскиваемый
                // обработчик отправки формы редактирования/удаления/добавления
                onclickSubmit: function (params, postdata) {
                    // получаем идентификатор строки
                    var selectedRow = dbGrid.getGridParam("selrow");
                    // устанавливаем url в зависимости от операции
                    switch (act) {
                        case "add":
                            params.url = '@Url.Action("Create")';
                            break;

                        case "edit":
                            params.url = '@Url.Action("Edit")';
                            postdata.CUSTOMER_ID = selectedRow;
                            break;

                        case "del":
                            params.url = '@Url.Action("Delete")';
                            postdata.CUSTOMER_ID = selectedRow;
                            break;
                    }
                },
                // обработчик результатов обработки форм (операций)
                afterSubmit: function (response, postdata) {
                    var responseData = response.responseJSON;
                    // проверяем результат на наличие сообщений об ошибках
                    if (responseData.hasOwnProperty("error")) {
                        if (responseData.error.length) {
                            return [false, responseData.error];
                        }
                    }
                    else {
                        // обновление грида
                        $(this).jqGrid(
                            'setGridParam',
                            {
                                datatype: 'json'
                            }
                        ).trigger('reloadGrid');
                    }
                    return [true, "", 0];
                }
            };
        };

    });
</script>
]]>                        
                    </programlisting>
                </para>

                <para>Как видите всё представление состоит из заголовка, таблицы jqg и блока
                    jqg-pager для отображения панели навигации, остальное занимает скрипт по
                    инициализации грида, панели навигации и диалога редактирования. Для правильного
                    отображения грида, размещения элементов ввода в форме редактирования, настройки
                    валидации форм ввода, настройки возможностей сортировки и поиска важно правильно
                    настроить свойства модели. Эта настройка довольно нетривиальна и содержит
                    множество параметров. Я постарался описать используемые параметры в
                    комментариях. Полное описание параметров модели вы можете найти в документации
                    по библиотеки jqGrid в разделе <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://www.trirand.com/jqgridwiki/doku.php?id=wiki:colmodel_options"
                        >ColModel API</link>.</para>
                <para>Обратите внимание, что для параметров редактирования и удаления нам пришлось
                    добавить в параметры запроса идентификатор заказчика <programlisting language="javascript">
<![CDATA[
    case "edit":
        params.url = '@Url.Action("Edit")';
        postdata.CUSTOMER_ID = selectedRow;
        break;

    case "del":
        params.url = '@Url.Action("Delete")';
        postdata.CUSTOMER_ID = selectedRow;
        break;
]]>                        
                    </programlisting> Это сделано потому, что jqGrid
                    автоматически не добавляет в форму ввода скрытые колонки грида, хотя, на мой
                    взгляд, это было бы логично, хотя бы для ключевых полей. </para>
                <para>Работающая страница справочника поставщиков будет выглядеть следующим образом: <figure>
                        <title>Справочник заказчиков</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-customers-screen.png" width="680"
                                />
                            </imageobject>
                            <textobject>
                                <phrase>Справочник заказчиков.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                    <figure>
                        <title>Редактирование заказчика</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="images/mvcnet-customers-edit-screen.png"
                                    width="680"/>
                            </imageobject>
                            <textobject>
                                <phrase>Редактирование заказчика.</phrase>
                            </textobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>Контроллер и представление для справочника товаров делаются по аналогии. Здесь
                    мы не будем описывать их подробно, вы можете написать их самостоятельно или
                    найти в исходных кодах, которые прилагаются к данной статье.</para>
            </section>
        </section>
        <section>
            <title>Создание пользовательского интерфейса журналов</title>

            <para>В нашем приложении будет один журнал «Счёт-фактуры». В отличие от справочников
                журналы содержат довольно большое количество записей и являются часто
                пополняемыми.</para>
            <para>Счёт-фактура – состоит из заголовка, где описываются общие атрибуты (номер, дата,
                заказчик …), и строк счёт-фактуры со списком товаром, их количеством, стоимостью и
                т.д. Для экономии пространства страницы мы сделаем детализирующий грид скрытым. Он
                будет отображён лишь при клике по иконке со знаком «+», таким образом, у нас
                получается, что детализирующий грид вложен в главный. </para>

            <section>
                <title>Контроллеры</title>

                <para>Контроллер журнала счёт фактуры должен уметь отдавать данные как по шапкам
                    счёт-фактуры, так и по её позициям. То же самое касается методов для добавления,
                    редактирования и удаления. <programlisting language="csharp">
<![CDATA[
[Authorize(Roles = "manager")]
public class InvoiceController : Controller
{
    private DbModel db = new DbModel();

    // Отображение представления
    public ActionResult Index()
    {
        return View();
    }

    // Получение данных в виде JSON для главного грида
    public ActionResult GetData(int? rows, int? page, string sidx, string sord,
        string searchField, string searchString, string searchOper)
    {
        // получаем номер страницы, количество отображаемых данных
        int pageNo = page ?? 1;
        int limit = rows ?? 20;
        // вычисляем смещение
        int offset = (pageNo - 1) * limit;

        // строим запрос для получения счёт-фактур
        var invoicesQuery =
            from invoice in db.INVOICES
            where (invoice.INVOICE_DATE >= AppVariables.StartDate) &&
                  (invoice.INVOICE_DATE <= AppVariables.FinishDate)
            select new
            {
                INVOICE_ID = invoice.INVOICE_ID,
                CUSTOMER_ID = invoice.CUSTOMER_ID,
                CUSTOMER_NAME = invoice.CUSTOMER.NAME,
                INVOICE_DATE = invoice.INVOICE_DATE,
                TOTAL_SALE = invoice.TOTAL_SALE,
                PAID = invoice.PAID
            };

        // добавлением в запрос условия поиска, если он производится
        // для разных полей доступны разные операторы
        // сравнения при поиске
        if (searchField == "CUSTOMER_NAME")
        {
             switch (searchOper)
             {
                 case "eq": // equal
                     invoicesQuery = invoicesQuery.Where(
                        c => c.CUSTOMER_NAME == searchString);
                     break;
                 case "bw": // starting with
                     invoicesQuery = invoicesQuery.Where(
                        c => c.CUSTOMER_NAME.StartsWith(searchString));
                     break;
                 case "cn": // containing
                     invoicesQuery = invoicesQuery.Where(
                        c => c.CUSTOMER_NAME.Contains(searchString));
                     break;
             }
        }
        if (searchField == "INVOICE_DATE")
        {
            var dateValue = DateTime.Parse(searchString);
            switch (searchOper)
            {
                case "eq": // =
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE == dateValue);
                    break;
                case "lt": // <
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE < dateValue);
                    break;
                case "le": // <=
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE <= dateValue);
                    break;
                case "gt": // >
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE > dateValue);
                    break;
                case "ge": // >=
                    invoicesQuery = invoicesQuery.Where(
                        c => c.INVOICE_DATE >= dateValue);
                    break;

            }
        }
        if (searchField == "PAID")
        {
            int iVal = (searchString == "on") ? 1 : 0;
            invoicesQuery = invoicesQuery.Where(c => c.PAID == iVal);
        }

        // получаем общее количество счёт-фактур
        int totalRows = invoicesQuery.Count();

        // добавляем сортировку
        switch (sord)
        {
            case "asc":
                invoicesQuery = invoicesQuery.OrderBy(
                    invoice => invoice.INVOICE_DATE);
                break;
            case "desc":
                invoicesQuery = invoicesQuery.OrderByDescending(
                    invoice => invoice.INVOICE_DATE);
                break;
        }

        // получаем список счёт-фактур
        var invoices = invoicesQuery
             .Skip(offset)
             .Take(limit)
             .ToList();

        // вычисляем общее количество страниц
        int totalPages = totalRows / limit + 1;

        // создаём результат для jqGrid
        var result = new
        {
            page = pageNo,
            total = totalPages,
            records = totalRows,
            rows = invoices
        };

        // преобразуем результат в JSON
        return Json(result, JsonRequestBehavior.AllowGet);
    }

    // Получение данных в виде JSON для детализирующего грида
    public ActionResult GetDetailData(int? invoice_id)
    {
        // строим запрос для получения позиций счёт-фактуры
        // отфильтрованный по коду счёт-фактуры
        var lines =
            from line in db.INVOICE_LINES
            where line.INVOICE_ID == invoice_id
            select new
            {
                INVOICE_LINE_ID = line.INVOICE_LINE_ID,
                INVOICE_ID = line.INVOICE_ID,
                PRODUCT_ID = line.PRODUCT_ID,
                Product = line.PRODUCT.NAME,
                Quantity = line.QUANTITY,
                Price = line.SALE_PRICE,
                Total = line.QUANTITY * line.SALE_PRICE
            };

        // получаем список позиций 
        var invoices = lines
             .ToList();

        // создаём результат для jqGrid
        var result = new
        {
            rows = invoices
        };

        // преобразуем результат в JSON
        return Json(result, JsonRequestBehavior.AllowGet);
    }


    // Добавление новой шапки счёт-фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Create(
       [Bind(Include = "CUSTOMER_ID,INVOICE_DATE")] INVOICE invoice)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            try
            {
                var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
                var CUSTOMER_ID = new FbParameter("CUSTOMER_ID", FbDbType.Integer);
                var INVOICE_DATE = new FbParameter("INVOICE_DATE", 
                                           FbDbType.TimeStamp);
                // инициализируем параметры значениями
                INVOICE_ID.Value = db.NextValueFor("GEN_INVOICE_ID");
                CUSTOMER_ID.Value = invoice.CUSTOMER_ID;
                INVOICE_DATE.Value = invoice.INVOICE_DATE;
                // выполняем ХП
                db.Database.ExecuteSqlCommand(
    "EXECUTE PROCEDURE SP_ADD_INVOICE(@INVOICE_ID, @CUSTOMER_ID, @INVOICE_DATE)",
                    INVOICE_ID,
                    CUSTOMER_ID,
                    INVOICE_DATE);
                    // возвращаем успех в формате JSON
                return Json(true);
            }
            catch (Exception ex)
            {
                // возвращаем ошибку в формате JSON
                return Json(new { error = ex.Message });
            }

        }
        else {
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }


    // Редактирование шапки счёт-фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Edit(
       [Bind(Include = "INVOICE_ID,CUSTOMER_ID,INVOICE_DATE")] INVOICE invoice)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            try
            {
                var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
                var CUSTOMER_ID = new FbParameter("CUSTOMER_ID", FbDbType.Integer);
                var INVOICE_DATE = new FbParameter("INVOICE_DATE", 
                                                   FbDbType.TimeStamp);
                // инициализируем параметры значениями
                INVOICE_ID.Value = invoice.INVOICE_ID;
                CUSTOMER_ID.Value = invoice.CUSTOMER_ID;
                INVOICE_DATE.Value = invoice.INVOICE_DATE;
                // выполняем ХП
                db.Database.ExecuteSqlCommand(
    "EXECUTE PROCEDURE SP_EDIT_INVOICE(@INVOICE_ID, @CUSTOMER_ID, @INVOICE_DATE)",
                    INVOICE_ID,
                    CUSTOMER_ID,
                    INVOICE_DATE);
                // возвращаем успех в формате JSON
                return Json(true);
            }
            catch (Exception ex)
            {
                // возвращаем ошибку в формате JSON
                return Json(new { error = ex.Message });
            }
        }
        else {
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }


    // Удаление шапки счёт-фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Delete(int id)
    {
        try
        {
            var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
            // инициализируем параметры значениями
            INVOICE_ID.Value = id;
            // выполняем ХП
            db.Database.ExecuteSqlCommand(
                "EXECUTE PROCEDURE SP_DELETE_INVOICE(@INVOICE_ID)",
                INVOICE_ID);
            // возвращаем успех в формате JSON
            return Json(true);
        }
        catch (Exception ex)
        {
            // возвращаем ошибку в формате JSON
            return Json(new { error = ex.Message });
        }
    }

    // Оплата счёт фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Pay(int id)
    {
        try
        {
            var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
            // инициализируем параметры значениями
            INVOICE_ID.Value = id;
            // выполняем ХП
            db.Database.ExecuteSqlCommand(
                "EXECUTE PROCEDURE SP_PAY_FOR_INOVICE(@INVOICE_ID)",
                INVOICE_ID);
            // возвращаем успех в формате JSON
            return Json(true);
        }
        catch (Exception ex)
        {
            // возвращаем ошибку в формате JSON
            return Json(new { error = ex.Message });
        }
    }

    // Добавление позиции счёт фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult CreateDetail(
       [Bind(Include = "INVOICE_ID,PRODUCT_ID,QUANTITY")] INVOICE_LINE invoiceLine)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            try
            {
                var INVOICE_ID = new FbParameter("INVOICE_ID", FbDbType.Integer);
                var PRODUCT_ID = new FbParameter("PRODUCT_ID", FbDbType.Integer);
                var QUANTITY = new FbParameter("QUANTITY", FbDbType.Integer);
                // инициализируем параметры значениями
                INVOICE_ID.Value = invoiceLine.INVOICE_ID;
                PRODUCT_ID.Value = invoiceLine.PRODUCT_ID;
                QUANTITY.Value = invoiceLine.QUANTITY;
                // выполняем ХП
                db.Database.ExecuteSqlCommand(
    "EXECUTE PROCEDURE SP_ADD_INVOICE_LINE(@INVOICE_ID, @PRODUCT_ID, @QUANTITY)",
                    INVOICE_ID,
                    PRODUCT_ID,
                    QUANTITY);
                // возвращаем успех в формате JSON
                return Json(true);
            }
            catch (Exception ex)
            {
                // возвращаем ошибку в формате JSON
                return Json(new { error = ex.Message });
            }
        }
        else {
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }

    // редактирование позиции счёт фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult EditDetail(
      [Bind(Include = "INVOICE_LINE_ID,INVOICE_ID,PRODUCT_ID,QUANTITY")] 
      INVOICE_LINE invoiceLine)
    {
        // проверяем правильность модели
        if (ModelState.IsValid)
        {
            try
            {
                // Создание параметров
                var INVOICE_LINE_ID = new FbParameter("INVOICE_LINE_ID", 
                                             FbDbType.Integer);
                var QUANTITY = new FbParameter("QUANTITY", FbDbType.Integer);
                // инициализируем параметры значениями
                INVOICE_LINE_ID.Value = invoiceLine.INVOICE_LINE_ID;
                QUANTITY.Value = invoiceLine.QUANTITY;
                // выполняем ХП
                db.Database.ExecuteSqlCommand(
    "EXECUTE PROCEDURE SP_EDIT_INVOICE_LINE(@INVOICE_LINE_ID, @QUANTITY)",
                    INVOICE_LINE_ID,
                    QUANTITY);
                // возвращаем успех в формате JSON
                return Json(true);
            }
            catch (Exception ex)
            {
                // возвращаем ошибку в формате JSON
                return Json(new { error = ex.Message });
            }
        }
        else {
            string messages = string.Join("; ", ModelState.Values
                                    .SelectMany(x => x.Errors)
                                    .Select(x => x.ErrorMessage));
            // возвращаем ошибку в формате JSON
            return Json(new { error = messages });
        }
    }

    // Удаление позиции счёт фактуры
    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult DeleteDetail(int id)
    {
        try
        {
            // Создание параметров
            var INVOICE_LINE_ID = new FbParameter("INVOICE_LINE_ID", 
                                          FbDbType.Integer);
            // инициализируем параметры значениями
            INVOICE_LINE_ID.Value = id;
            // выполняем ХП
            db.Database.ExecuteSqlCommand(
                 "EXECUTE PROCEDURE SP_DELETE_INVOICE_LINE(@INVOICE_LINE_ID)",
                 INVOICE_LINE_ID);
            // возвращаем успех в формате JSON
            return Json(true);
        }
        catch (Exception ex)
        {
            // возвращаем ошибку в формате JSON
            return Json(new { error = ex.Message });
        }
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            db.Dispose();
        }
        base.Dispose(disposing);
    }
}
]]>                    
                </programlisting>
                </para>
                <para>В методе <function>GetDetailData</function> для получения списка позиций
                    счёт-фактуры нет кода для постраничной навигации. Дело в том, что у конкретной
                    счёт-фактуры не очень много позиций для того чтобы применять к ним постраничную
                    навигацию. Это упрощает код, и делает его быстрее.</para>
                <para>На этот раз все действия по модификации данных выполняются в хранимых
                    процедурах, однако вы можете выполнить те же действия с помощью Entity
                    Framework. Тексты хранимых процедур вы можете посмотреть в скрипте создания
                    БД.</para>
            </section>
        </section>
    </section>

</chapter>
