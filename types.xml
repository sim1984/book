<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="types" xml:lang="ru"
    xmlns:xi="http://www.w3.org/2001/XInclude">
    <info>
        <title>Типы данных и домены</title>
    </info>

    <para>Несмотря на то, что типы данных подробно описаны в документации, необходимо рассмотреть
        ряд понятий, которые будут часто использоваться в последующих главах книги. Помимо изложения
        сведений общего характера будут рассмотрены также примеры использования типов данных в базах
        данных Firebird и изложены рекомендации по их использованию и преобразованию. Также подробно
        рассмотрим отличия в типах данных, существующие 1-м и 3-м диалектах базы данных
        Firebird.</para>

    <section>
        <title>О типах данных</title>

        <para>Типы данных — это базовые элементы любого языка программирования или любого сервера
            СУБД, и Firebird не исключение. Когда мы говорим, что в базе данных хранится какая-то
            информация, то должны всегда чётко осознавать, что эта информация не может быть свалена
            в одну большую кучу; наоборот, данные должны быть рассортированы и разложены по
            "полочкам". Типы данных определяют, что можно положить на соответствующую "полочку", а
            что нельзя. Под "полочками" понимаются прежде всего поля таблиц в базе данных (см. главу
            "Таблицы"), а также переменные внутри триггеров, хранимых процедур и функции, пакетов и
            т. д. </para>

        <para>Каждый тип данных имеет набор операций, которые можно выполнять над значениями этого
            типа, поэтому необходимо правильно выбрать тип данных при проектировании базы данных,
            что поможет избежать многих проблем при разработке клиентских программ.</para>

        <para>В Firebird существует 14 типов данных, которые способны удовлетворить практически
            любые потребности разработчика в хранении данных. Эти типы условно подразделяются на 6
            следующих групп: <itemizedlist>
                <listitem>
                    <para>для хранения целых чисел — BIGINT, INTEGER и SMALLINT;</para>
                </listitem>
                <listitem>
                    <para>для хранения вещественных чисел — FLOAT и DOUBLE PRECISION;</para>
                </listitem>
                <listitem>
                    <para>для чисел с фиксированной точностью — NUMERIC и DECIMAL;</para>
                </listitem>
                <listitem>
                    <para>для хранения даты, времени и даты/времени — DATE, TIME и TIMESTAMP;</para>
                </listitem>
                <listitem>
                    <para>для хранения символов — CHARACTER (сокращенно CHAR) и VARYING CHARACTER
                        (VARCHAR);</para>
                </listitem>
                <listitem>
                    <para>для хранения логических значений – BOOLEAN (начиная с Firebird
                        3.0);</para>
                </listitem>
                <listitem>
                    <para>для хранения динамически расширяемых данных — BLOB.</para>
                </listitem>
            </itemizedlist></para>

        <para>Также возможно определять массивы значений элементарных типов, т.е. всех перечисленных
            типов, кроме BLOB.</para>

        <para>Большинство типов данных Firebird соответствуют типам, определённым в стандарте
            SQL-99, однако, помимо этого, есть и собственные "изюминки" – массивы элементарных типов
            данных и BLOB.</para>

        <para>Массивы в Firebird могут содержать множество данных одного типа в одном поле, например
            можно определить массив значений типа INTEGER. Причём массивы могут иметь несколько
            размерностей!</para>

        <para>Тип данных BLOB — это динамически расширяемый тип данных, название которого часто
            расшифровывается как Binary Large OBject — "большие двоичные объекты". Надо сказать, что
            BLOB — это изобретение разработчиков Interbase (предшественник Firebird), которое позже
            распространилось и прижилось во всех современных SQL серверах.</para>
    </section>

    <section>
        <title>Синтаксис определения типов данных</title>

        <para>Типы данных используются для описания полей в таблицах, переменных в триггерах и
            хранимых процедурах. Ниже представлен общий синтаксис определения всех возможных в
            Firebird типов данных.</para>

        <para>
            <programlisting>
&lt;datatype&gt; ::= 
    {SMALLINT | INTEGER | BIGINT } [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {FLOAT | DOUBLE PRECISION} [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {DATE | TIME | TIMESTAMP} [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)] [<replaceable>&lt;array_dim&gt;</replaceable>] 
    [CHARACTER SET <replaceable>charname</replaceable>] 
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] [<replaceable>&lt;array_dim&gt;</replaceable>]
  | BOOLEAN [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | BLOB [SUB_TYPE {<replaceable>int</replaceable> | <replaceable>subtype_name</replaceable>}] [SEGMENT SIZE <replaceable>int</replaceable>] 
    [CHARACTER SET <replaceable>charname</replaceable>] 
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype</replaceable>])]               
            </programlisting>
        </para>

        <para>Подробно свойства типов данных, такие, как размер, точность и диапазон возможных
            значений, описаны в табл. 2.1 в [1], поэтому повторяться здесь не будем. Далее кратко
            рассмотрим основные особенности типов данных и сосредоточимся на их возможном
            применении.</para>
    </section>

    <section>
        <title>Целочисленные типы</title>

        <para>К целочисленным типам относятся SMALLINT, INTEGER и BIGINT. Надо сказать, что SMALLINT
            представляет собой урезанную версию INTEGER и имеет длину 2 байта, в отличие от 4 байт,
            выделяемых для хранения INTEGER. Тип BIGINT занимает 8 байт (64 бита). Обычно экономить
            на дисковом пространстве не следует, и поэтому общей рекомендацией будет использовать
            для хранения целых значений тип INTEGER.</para>

        <important>
            <para>Тип BIGINT доступен только в 3-м диалекте.</para>
        </important>

        <para>Область применения целочисленных типов очевидна: они нужны для полей, содержащих
            только целые числа — для хранения счётчиков, количества и т.д. Обычно тип INTEGER или
            BIGINT имеют также поля, содержащие первичные ключи.</para>
    </section>

    <section>
        <title>Вещественные типы данных</title>

        <para>К вещественным типам (их ещё называют типами чисел с плавающей точкой) относятся FLOAT
            и DOUBLE PRECISION. Сразу следует предостеречь читателя от использования типа FLOAT –
            его точность недостаточна для хранения большинства дробных значений. Особенно не
            рекомендуется хранить в нем денежные величины – в переменных типа FLOAT очень быстро
            нарастают ошибки округления, что может сильно удивить бухгалтера при подведении итогов. </para>

        <para>Если в базе данных предполагается хранить числа с плавающей точкой (например, в
            бухгалтерских системах или в системах для научных расчётов), то лучшим выбором будет тип
            DOUBLE PRECISION. </para>

        <note>
            <para>Надо отметить, что в 3-м диалекте Firebird для хранения денежных величин
                существует механизм хранения типов с фиксированной точкой длиной 64 бита (NUMBERIC,
                DECIMAL). Использование этих типов обеспечивает наилучшую точность.</para>
        </note>
    </section>

    <section>
        <title>Типы данных с фиксированной точкой</title>

        <para>К этим типам данных относятся NUMERIC и DECIMAL. Часто звучит вопрос, чем NUMERIC
            отличается от DECIMAL. Оба этих типа имеют одинаковую разрядность — от 1 до 18 знаков,
            одинаковую точность — от нуля до разрядности. </para>

        <note>
            <para>Напомним, что: разрядность — это общее число цифр в числе, а точность — число
                знаков после запятой.</para>
        </note>

        <para>Самое забавное, что, несмотря на то, что в документации написано, что эти типы
            отличаются максимальной разрядностью, на самом деле реализованы они практически
            одинаково и разницы между ними никакой нет! Вы легко можете это проверить, запустив
            утилиту <application>isql</application> и произведя нижеследующую очерёдность
            действий.</para>

        <para>Создаём таблицу следующего вида:
            <programlisting language="sql">
CREATE TABLE test (
  Num_field NUMERIC(15,2),
  Dec_field DECIMAL(15,2)
);            
        </programlisting>
        </para>
        <para>Затем даем команду показать структуру таблицы:
            <programlisting>
SQL> show tables test;            
        </programlisting> И
            наблюдаем такую картину:
            <screen>
NUM_FIELD                       NUMERIC(15, 2) Nullable
DEC_FIELD                       NUMERIC(15, 2) Nullable           
        </screen>
        </para>

        <para>Как видите, Firebird сообщает о том, что оба данных столбцы имеют тип NUMERIC!</para>

        <para>Причины такого поведения лежат в реализации типов данных с фиксированной точкой. Дело
            в том, что Firebird имеет всего 3 механизма хранения любого целочисленного выражения, и
            все типы, как бы они ни назывались, приводятся к этим вариантам реализации.</para>
        <para>Ниже представлена таблица, которая иллюстрирует, как хранятся различные значения с
            фиксированной точкой. Как видите, хранение данных в 3-м диалекте отличается для чисел с
            большой разрядностью: <table xml:id="table-store-fixed">
                <?dbfo keep-together='auto'?>
                <title>Способ физического хранения чисел с фиксированной точкой</title>

                <tgroup cols="4">
                    <colspec colname="colType" colwidth="3*" align="left"/>
                    <colspec colname="colScale" colwidth="2*" align="left"/>
                    <colspec colname="colDial01" colwidth="3*" align="left"/>
                    <colspec colname="colDial03" colwidth="3*" align="left"/>
                    <thead>
                        <row valign="middle">
                            <entry align="center">Тип данных</entry>
                            <entry align="center">Точность</entry>
                            <entry align="center">Диалект 1</entry>
                            <entry align="center">Диалект 3</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row valign="middle">
                            <entry>NUMERIC</entry>
                            <entry>1 - 4</entry>
                            <entry>SMALLINT</entry>
                            <entry>SMALLINT</entry>
                        </row>
                        <row valign="middle">
                            <entry>DECIMAL</entry>
                            <entry>1 - 4</entry>
                            <entry>INTEGER</entry>
                            <entry>INTEGER</entry>
                        </row>
                        <row valign="middle">
                            <entry>NUMERIC и DECIMAL</entry>
                            <entry>5 - 9</entry>
                            <entry>INTEGER</entry>
                            <entry>INTEGER</entry>
                        </row>
                        <row valign="middle">
                            <entry>NUMERIC и DECIMAL</entry>
                            <entry>10 - 18</entry>
                            <entry>DOUBLE PRECISION</entry>
                            <entry>BIGINT</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>
        <para>Итак, теперь мы точно можем сказать, чем отличаются типы NUMERIC и DECIMAL: в случае
            определения поля (переменной) с малой разрядностью (до четырёх) первый хранится в виде 2
            байтового целого числа SMALLINT, а второй — в виде 4 байтового INTEGER.</para>
        <para>Таким образом, в случае разрядности, большей четырех, типы DECIMAL и NUMERIC окажутся
            абсолютно эквивалентными!</para>
        <para>Обратите внимание на отличие реализации типов с большой разрядностью в 1-м и 3-м
            диалектах. В 1-м диалекте число с фиксированной точкой превращалось из целого в
            вещественное, к которому применялись механизмы округления! В 3-м диалекте эта странность
            была ликвидирована — большие целые числа хранятся действительно как целые — с
            использованием механизма BIGINT, который может хранить 64-битовые числа в диапазоне
                    <literal>-2<superscript>64</superscript></literal> -
                    <literal>2<superscript>64</superscript></literal>. Поэтому рекомендуется хранить
            данные о денежных средствах в базах данных, созданных с использованием 3-го диалекта, —
            только при использовании механизма BIGINT можно гарантировать сохранность малых денежных
            остатков.</para>
    </section>
    <section>
        <title>Типы для хранения даты и времени</title>

        <para>В СУБД Firebird для работы с данными, содержащими дату и время, используются типы
            данных DATE, TIME, TIMESTAMP. В 3-м диалекте присутствуют все три вышеназванных типа
            данных, а в 1-м для операций с датой и временем доступен только тип данных DATE, который
            не тождественен типу данных DATE 3-го диалекта, а напоминает тип данных TIMESTAMP из
            3-го диалекта. </para>
        <para>
            <itemizedlist>
                <listitem>
                    <para>Тип DATE хранит даты с точностью до дня. Диапазон возможных значений — от
                        1 января 1 г. н.э. до 31 декабря 9999 года.</para>
                </listitem>
                <listitem>
                    <para>Тип TIME хранит данные о времени с точностью до десятитысячной доли
                        секунды. Диапазон возможных значений — от 00:00:00 до 23:59:59.9999.</para>
                </listitem>
                <listitem>
                    <para>Тип TIMESTAMP представляет собой комбинацию типов DATE и TIME.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Как работать с датами? Если речь идёт о работе на уровне сервера в хранимых процедурах
            или триггерах, то всё достаточно просто — мы всегда можем объявить переменную нужного
            нам типа и присваивать ей значения из таблиц и наоборот. Однако необходимо передавать
            данные из базы данных в приложение и обратно. В этом случае есть два подхода – либо
            использовать библиотеки, которые применяют оригинальный формат дат Firebird для доступа
            к объектам этих типов и преобразуют этот формат в привычные внутриязыковые типы
            даты/времени (примером такой библиотеки является FIBPlus), либо использовать механизм
            преобразования дат в строки, встроенный в Firebird.</para>
        <para>Что делать, если нужно вырезать из полной даты только год или месяц? Для этого
            используется группа функций EXTRACT (доступная во всех клонах Firebird), которая
            позволяет выделить из даты только нужную часть. Используются эти функции следующим
            образом:
            <programlisting language="sql">
EXTRACT (MONTH FROM DATE_FIELD)
EXTRACT (YEAR FROM DATE_FIELD)                        
        </programlisting>
        </para>
        <para>Полный список параметров в функции EXTRACT таков: YEAR, MONTH, DAY, HOUR, MINUTE,
            SECOND, MILLISECOND, WEEKDAY, YEARDAY. Их назначение очевидно следует из их названия,
            поэтому не будем приводить здесь расшифровки.</para>
    </section>
    <section>
        <title>Типы данных для хранения текста</title>

        <para>В СУБД Firebird для работы с символьными данными есть тип данных фиксированной длины
            CHAR и строковый тип данных VARCHAR переменной длины. Максимальный размер текстовых
            данных, хранящийся в этих типах данных, составляет 32767 байт (32765 для VARCHAR).
            Максимальное количество <emphasis role="italic">символов</emphasis>, которое поместится
            в этот объем, зависит от используемого набора символов CHARACTER SET и/или заданного
            порядка сортировки, который для символьных данных задаётся предложением COLLATE.</para>

        <para>В случае отсутствия явного указания набора символов при описании текстового объекта
            базы данных будет использоваться набор символов по умолчанию, заданный при создании базы
            данных. При отсутствии явного указания набора символов, а также отсутствия набора
            символов по умолчанию в базе данных, поле получает набор символов CHARACTER SET
            NONE.</para>

        <para>Если база данных будет содержать строки <emphasis role="italic">только с русским
                алфавитом</emphasis>, то для неё рекомендуется к использованию кодировка WIN1251.
            При её использовании на один символ расходуется 1 байт, соответственно максимальный
            размер текстовых полей для данной кодировки будет 32767 символов. Для стандартных
            операций сортировки при работе с WIN1251 не требуется задавать порядок сортировки
            (COLLATE).</para>

        <para>В настоящее время все современные средства разработки поддерживают Unicode. При
            возникновении необходимости использования западноевропейских текстов в строковых полях
            базы данных или для более экзотических алфавитов, рекомендуется работать с набором
            символов UTF8. При этом следует иметь в виду, что на один символ в данном наборе
            приходится до 4 байт. Следовательно, максимальный размер символов в символьных полях
            составит 32767/4 (8191) байта на символ. При этом следует обратить внимание, что
            фактически значение параметра «байт на символ» зависит от диапазона, к которому
            принадлежит символ: английские буквы занимают 1 байт, русские буквы кодировки WIN1251 —
            2 байта, остальные символы — могут занимать до 4-х байт.</para>

        <para>Набор символов UTF8 поддерживает последнюю версию стандарта Unicode, до 4 байт на
            символ, поэтому для интернациональных баз рекомендуется использовать именно эту
            реализацию поддержки Unicode в Firebird.</para>

        <para>При работе со строками необходимо помнить и о параметре соединения клиентской
            программы к базе данных. В нем также задаётся набор символов. В случае различия набора
            символов, при выдаче результата для строковых столбцов происходит автоматическая
            перекодировка как при передаче данных с клиента на сервер, так и в обратном направлении
            с сервера на клиент. То есть, совершенно нормальной является ситуация, когда база
            создана в кодировке WIN1251, а в настройках клиента в параметрах соединения стоит KOI8R
            или UTF8.</para>

        <para>Упомянутый выше набор символов NONE относится к специальным наборам символов. Его
            можно охарактеризовать тем, что каждый байт является частью <emphasis role="italic"
                >строки</emphasis>, но в системе хранится без указаний, к какому <emphasis
                role="italic">фактическому</emphasis> набору символов они относятся. Разбираться с
            такими данными должно клиентское приложение, на него возлагается ответственность в
            правильной трактовке символов из таких полей. Также к специальным наборам символов
            относится OCTETS. В этом случае данные рассматриваются как байты, которые могут в
            принципе не интерпретироваться как символы. OCTETS позволяет хранить бинарные данные
            и/или результаты работы некоторых функций Firebird. Правильное отображение данных
            пользователю, хранящихся в полях с CHARACTER SET OCTETS, также становится заботой
            клиентской стороны. При работе с подобными данными следует также помнить, что СУБД не
            контролирует их содержимое и возможно возникновение исключения при работе кода, когда
            идёт попытка отображения бинарных данных в желаемой кодировке.</para>

        <para>Каждый текстовый набор символов (CHARACTER SET) имеет последовательность сортировки
            (COLLATE) по умолчанию, задающий порядок сортировки и упорядочивания. Если необходимо
            нестандартное поведение строк при указанных выше действиях, то в описании строкового
            столбца может быть указан параметр COLLATE, который его опишет. Помимо описания
            объявления столбца, выражение COLLATE может быть добавлено в предложениях SELECT в
            секции WHERE, когда происходят операции сравнения больше – меньше, в секции ORDER BY при
            сортировке по символьному полю, а также при операциях группировки для указания
            специальной последовательности сортировки при выводе в предложении GROUP BY.</para>

        <para>Чтобы создать символьное поле с явным указанием набора символов, необходимо в описании
            столбца (в предложениях CREATE TABLE или ALTER TABLE) добавить описание набора символов.
            Для поддержки русского языка обычно используется набор символов WIN1251. Вот пример
            таблицы, содержащей символьное поле с явно описанным набором символов WIN1251:
            <programlisting language="sql">
CREATE TABLE TestCHARSET(
  Field1 CHAR(255),
  Field2 VARCHAR(255),
  Field3 VARCHAR(255) CHARACTER SET win1251);            
        </programlisting>
        </para>
        <para>Типы CHAR и VARCHAR во многом схожи, но есть и отличия. Хотя хранятся эти два типа в
            базе данных одинаково, но работает с ними Firebird по разному. Это можно
            продемонстрировать следующим примером:
            <programlisting language="sql">
create table testCHAR (c1 char(10), c2 varchar(10));
insert into testCHAR(c1, c2) values('Test', 'Test');
SELECT '('||c1||')', '('||c2||')' from testCHAR;                
           </programlisting>
        </para>
        <para>В результате получим следующий результат:
            <screen>
(Test      ) (Test)            
        </screen>
        </para>
        <para>Как видите, после значения 'Test', выбранного из поля c1, оказались пробелы. Это
            означает, что при выборке данных из поля типа CHAR возвращаемое значение дополняется
            пробелами до полной длины поля.</para>
    </section>
    <section>
        <title>Тип данных BOOLEAN</title>

        <para>BOOLEAN является SQL-2008 совместимым типом данных. Он доступен начиная с Fireibrd
            3.0. BOOLEAN хранит значения истинности TRUE и FALSE. Если не установлено ограничение
            NOT NULL, то тип данных BOOLEAN поддерживает также значение истинности UNKNOWN как NULL
            значение. Спецификация не делает различия между значением NULL этого типа и значением
            истинности UNKNOWN, которое является результатом SQL предиката, поискового условия или
            выражения логического типа. Эти значения взаимозаменяемы и обозначают одно и то
            же.</para>

        <note>
            <para>До Firebird 3.0 тип данных BOOLEAN не поддерживался. Вместо него использовались
                домены, например вот такие
                <programlisting language="sql">
CREATE DOMAIN D_BOOLEAN AS
SMALLINT
CHECK (VALUE IN (0, 1));
            </programlisting>
                Конечно вы не можете производить различные логические операции в PSQL над такими
                доменами как над нативным типом BOOLEAN. Однако на клиентской стороне некоторые
                компоненты доступа, например FibPlus, позволяют отображать и работать с такими
                полями как с типом boolean.</para>
            <para>Компоненты доступа и драйверы старых версий могут ничего не знать о нативном типе
                BOOLEAN.</para>
        </note>

        <para>Как и в других языках программирования, значения типа BOOLEAN могут быть проверены в
            неявных значениях истинности. Например, <code>field1 OR field2</code> или NOT field1
            являются допустимыми выражениями. Предикаты могут использовать оператор IS [NOT] для
            проверки соответствия. Например, <code>field1 IS FALSE</code> или <code>field1 IS NOT
                TRUE</code>.</para>

        <para>Приведём примеры использования типа BOOLEAN. <programlisting language="sql">
 <![CDATA[           
CREATE TABLE TBOOL (ID INT, BVAL BOOLEAN);
COMMIT;

INSERT INTO TBOOL VALUES (1, TRUE);
INSERT INTO TBOOL VALUES (2, 2 = 4);
INSERT INTO TBOOL VALUES (3, NULL = 1);
COMMIT;

SELECT * FROM TBOOL
]]>            
        </programlisting>
            <screen>      
 <![CDATA[     
ID      BVAL
======= =======
1       <true>
2       <false>
3       <null>
]]> 
</screen>
            <programlisting language="sql">
 <![CDATA[ 
-- Проверка TRUE значения
SELECT * FROM TBOOL WHERE BVAL
]]>            
        </programlisting>
            <screen>
            <![CDATA[ 
ID     BVAL
====== =======
1      <true>
]]> 
</screen>
            <programlisting language="sql">
 <![CDATA[ 
-- Проверка FALSE значения
SELECT * FROM TBOOL WHERE BVAL IS FALSE
]]>            
        </programlisting>
            <screen>
            <![CDATA[ 
ID     BVAL
====== =======
2      <false>	
]]> 
</screen>
            <programlisting language="sql">
 <![CDATA[ 
-- Проверка UNKNOWN значения
SELECT * FROM TBOOL WHERE BVAL IS UNKNOWN
]]>            
        </programlisting>
            <screen>
            <![CDATA[ 
ID     BVAL
====== =======
3      <null>
]]> 
</screen>
            <programlisting language="sql">
 <![CDATA[ 
-- Логические значения в SELECT списке
SELECT ID, BVAL, BVAL AND ID < 2
FROM TBOOL
]]>            
        </programlisting>
            <screen>
            <![CDATA[ 
ID     BVAL
====== ======= =======
1      <true>  <true>
2      <false> <false>
3      <null>  <false>
]]> 
</screen>
            <programlisting language="sql">
 <![CDATA[ 
-- PSQL объявления с начальным значением
DECLARE VARIABLE VAR1 BOOLEAN = TRUE;

-- Допустимый синтаксис, но как и сравнение
-- с NULL, никогда не вернёт ни одной записи
SELECT * FROM TBOOL WHERE BVAL = UNKNOWN
SELECT * FROM TBOOL WHERE BVAL <> UNKNOWN
]]>            
        </programlisting>
        </para>
    </section>
    <section>
        <title>Тип данных BLOB</title>

        <para>Тип данных BLOB предназначен для хранения большого количества данных переменного
            размера. Тип BLOB позволяет хранить данные, которые не могут быть помещены в поля других
            типов, — например, картинки, музыкальные файлы, видеофрагменты и т. д. </para>

        <para>Чтобы определить самое простое поле типа BLOB в таблице, не нужно ничего сверх того,
            что обычно требуется для определения поля любого элементарного типа:
            <programlisting language="sql">
CREATE TABLE testBLOB(
  myBlobField BLOB);            
        </programlisting>
        </para>

        <para>В результате будет создано поле myBlobField, в котором можно хранить данные большого
            размера. Но несмотря на то что поля BLOB по способу определения никак не отличаются от
            других, реализация их внутри базы данных значительно отличается. Не-BLOB-поля
            расположены на странице данных (см. главу "Структура базы данных Firebird" (ч. 4)) рядом
            друг с другом, а в случае BLOB на странице данных хранится только идентификатор BLOB, а
            сам BLOB располагается на специальной странице. Именно такая организация данных
            позволяет хранить данные нефиксированного размера.</para>

        <para>У типа BLOB имеется возможность определять набор нескольких подтипов и специальных
            процедур, называемых <emphasis role="italic">фильтрами</emphasis> (BLOB filters), для
            работы с этими подтипами. Существует несколько предопределенных подтипов BLOB, которые
            встроены в Firebird. Все эти подтипы имеют неотрицательные номера, например subtype 0 –
            это данные неопределенного типа, subtype 1 – текст, subtype 2 – BLR (Binary Language
            Representation) и т. д. Пользователь также может определять свои подтипы BLOB, которые
            могут иметь отрицательные значения. Каждому типу может быть поставлен в соответствие
            фильтр, который преобразует поле этого подтипа в другой подтип. </para>

        <para>Надо отметить, что использование BLOB-полей обычно служит альтернативой хранению
            внешних относительно базы данных файлов. Что касается фильтров BLOB, то они используются
            достаточно редко по причине своей ориентации на узкий класс задач.</para>
    </section>

    <section>
        <title>Массивы</title>

        <para>Поддержка массивов в базе данных является расширением традиционной реляционной модели.
            Наличие массивов позволяет упростить работу со множествами данных одного типа.</para>

        <para>Массив – это совокупность значений одного типа, имеющая общее имя и позволяющая
            обратиться к любому элементу массива по его номеру. Массивы в Firebird могут быть
            одномерными и многомерными.</para>

        <para>Для того чтобы создать в таблице поле типа массив чисел INTEGER, необходимо написать
            что-то вроде следующего:
            <programlisting language="sql">
CREATE TABLE test(
  myOneDimArray INTEGER[12],
  myTwoDimArray INTEGER[5, 4],
  myThreeDimArray INTEGER[2, 10, 8]);            
        </programlisting>
        </para>

        <para>При этом создадутся 3 поля типа массив: поле myOneDimArray, содержащее одномерный
            массив длиной 12 чисел, myTwoDimArray, содержащее двумерный массив (матрицу) 5х4 чисел
            Integer, и поле myThreeDimArray – трехмерный массив 2х10х8. Надо отметить, что при таком
            определении элементы массива нумеруются начиная с единицы, т. е. первый элемент имеет
            номер 1, второй – номер 2 и т. д. Если кто-то хочет указать границы массива
            самостоятельно, например с 0 до 5, то он должен задать определение поля так:
            <programlisting language="sql">
myArray INTEGER[0:5]                
            </programlisting>
        </para>

        <para>Массивы реализованы на базе полей типа BLOB, поэтому не следует опасаться, что
            многомерный массив "загрязнит" вашу таблицу невероятным количеством данных: Firebird
            аккуратно разместит данные массива на отдельных страницах, чтобы оптимизировать операции
            ввода-вывода в этих полях.</para>

        <para>Как использовать массивы? Они предоставляют удобный механизм для хранения однотипных
            объектов. Однако в 80% случаев вместо массивов разработчики предпочитают держать
            множественные данные в подчиненных (detail) таблицах, поэтому массивы не так часто
            используются в клиентских приложениях СУБД Firebird. </para>
    </section>
    <section>
        <title>Домены</title>

        <para>Домены в СУБД Firebird реализуют широко известный по многим языкам программирования
            инструмент «типы данных, определенные пользователем». Когда несколько таблиц в базе
            данных содержат поля с характеристиками одинаковыми или практически одинаковыми, то есть
            целесообразность сделать домен, в котором описать набор свойств поля и использовать
            такой набор свойств, описанный один раз, в нескольких объектах базы данных. Домены могут
            использоваться помимо описания полей таблиц и представлений (VIEW) и при объявлении
            входных и выходных параметров, а также при объявлении переменных в коде PSQL.</para>

        <para>Определение домена содержит обязательные и необязательные атрибуты. К обязательному
            атрибуту относится <emphasis role="italic">тип данных</emphasis>. К необязательным
            относятся: <itemizedlist spacing="compact">
                <listitem>
                    <para>значение по умолчанию;</para>
                </listitem>
                <listitem>
                    <para>возможности использования NULL для домена;</para>
                </listitem>
                <listitem>
                    <para>ограничения CHECK для данных домена;</para>
                </listitem>
                <listitem>
                    <para>набор символов (для символьных типов данных и BLOB полей);</para>
                </listitem>
                <listitem>
                    <para>порядок сортировки (для символьных типов данных).</para>
                </listitem>
            </itemizedlist></para>

        <para>Создание домена производится командой CREATE DOMAIN, синтаксис которой показан ниже:
            <programlisting>
CREATE DOMAIN <replaceable>&lt;name&gt;</replaceable> [AS] <replaceable>&lt;type&gt;</replaceable>
[DEFAULT {<replaceable>&lt;literal&gt;</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>}]
[NOT NULL] [CHECK (<replaceable>&lt;condition&gt;</replaceable>)]
[COLLATE <replaceable>collation</replaceable>];            
        </programlisting>
        </para>
        <para>Пример создания домена:
            <programlisting language="sql">
CREATE DOMAIN BOOL3 AS SMALLINT
CHECK (VALUE IS NULL OR VALUE IN (0, 1));            
        </programlisting>
        </para>
        <para>Для редактирования свойств домена используют оператор ALTER DOMAIN языка определения
            данных (DDL).</para>
        <para>При редактировании домена можно: <itemizedlist spacing="compact">
                <listitem>
                    <para>переименовать домен;</para>
                </listitem>
                <listitem>
                    <para>изменить тип данных;</para>
                </listitem>
                <listitem>
                    <para>удалить текущее значение по умолчанию;</para>
                </listitem>
                <listitem>
                    <para>установить новое значение по умолчанию;</para>
                </listitem>
                <listitem>
                    <para>установить ограничение NOT NULL (начиная с Firebird 3.0);</para>
                </listitem>
                <listitem>
                    <para>удалить ограничение NOT NULL (начиная с Firebird 3.0);</para>
                </listitem>
                <listitem>
                    <para>удалить текущее ограничение CHECK;</para>
                </listitem>
                <listitem>
                    <para>добавить новое ограничение CHECK.</para>
                </listitem>
            </itemizedlist></para>
        <para>Краткий синтаксис оператора ALTER DOMAIN:
            <programlisting>                   
ALTER DOMAIN <replaceable>name</replaceable>
  [{TO <replaceable>new_name</replaceable>}]
  [{SET DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>} | 
    DROP DEFAULT}]
  [{SET | DROP} NOT NULL]
  [{ADD [CONSTRAINT] CHECK (<replaceable>&lt;dom_condition&gt;</replaceable>) | 
    DROP CONSTRAINT}]
  [{TYPE <replaceable>&lt;datatype&gt;</replaceable>}];                                         
            </programlisting>
        </para>
        <para>Пример:
            <programlisting language="sql">
ALTER DOMAIN STORE_GRP SET DEFAULT -1;                
            </programlisting>
        </para>
        <para>При изменении доменов следует учитывать и его зависимости: имеются ли столбцы таблиц;
            находятся ли в коде PSQL объявления переменных, входных и/или выходных параметров с
            типом этого домена. При поспешном редактировании без внимательной проверки можно сделать
            данный код неработоспособным! </para>
        <important>
            <para>При смене в домене типа данных не допустимы преобразования, которые могут привести
                к потере данных. Также, например, при преобразовании VARCHAR в INTEGER проверьте,
                все ли данные, что используют данных домен, смогут пройти преобразование. </para>
        </important>
    </section>
    <section>
        <title>Заключение</title>

        <para>Надо отметить, что невозможно рассказать о типах данных, не забегая вперёд, –
            настолько они проникают во все ключевые области, связанные с разработкой приложений баз
            данных. Поэтому в процессе чтения этой книги стоит использовать данную главу как
            справочник, к которому можно обращаться всякий раз, когда надо освежить в памяти основы
            Firebird.</para>
    </section>
</chapter>
