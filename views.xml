<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="views" xml:lang="ru">
    <info>
        <title>Представления</title>
    </info>
    <indexterm>
        <primary>VIEW</primary>
    </indexterm>
    <para>Те, кто знаком с языком SQL, не нуждаются в подробных объяснениях этого предмета, но для
        сохранения порядка изложения приведем все же краткое определение представлений.</para>
    <para>Представление (VIEW) — это виртуальная таблица, созданная на основе запроса к обычным
        таблицам. Представление реализовано как запрос, хранящийся на сервере и выполняющийся всякий
        раз, когда происходит обращение к представлению.</para>
    <para>Давайте рассмотрим различные варианты использования представлений. Представления дают
        возможность создать уровни организации данных, позволяющие отделить реализацию хранения
        данных от их вида. Например, можно создать представление, которое выбирает данные из
        несколько таблиц. Если клиенты будут использовать это представление, а не напрямую
        обращаться к лежащим в его основе таблицам, то у разработчика базы данных появляется
        возможность менять запрос, лежащий в основе представления, изменять его (с целью
        оптимизации, например), а клиент ничего не будет замечать — для него это будет все то же
        представление.</para>
    <para>Помимо того что они изолируют реализацию хранения данных от пользователя, представления
        позволяют организовать данные в более удобном и простом виде. Проблема "упрощения"
        организации данных возникает, когда число таблиц в базе данных становится достаточно
        большим, а взаимосвязи между ними — сложными. Представление позволяет исключить (или,
        наоборот, добавить) часть данных, не нужных конкретному клиенту базы данных (или —
        необходимых).</para>
    <para>Также представления позволяют более просто организовать безопасность в базе данных
        Firebird. Определенные пользователи могут иметь права только на чтение/изменение данных в
        представлении, но не иметь никаких прав (и даже никакого понятия) о таблицах, лежащих в
        основе представления! Подробнее о вопросах безопасности в Firebird см. главу "Безопасность в
        Firebird: пользователи, роли и права".</para>

    <section>
        <title>Синтаксис DDL для работы с представлениями</title>

        <para>Для создания и удаления представлений существуют команды, определенные DDL (Data
            Definition Language — подмножество SQL, см. глоссарий), которые мы сейчас рассмотрим. </para>

        <indexterm>
            <primary>VIEW</primary>
            <secondary>CREATE VIEW</secondary>
        </indexterm>
        <indexterm>
            <primary>VIEW</primary>
            <secondary>RECREATE VIEW</secondary>
        </indexterm>
        <indexterm>
            <primary>VIEW</primary>
            <secondary>CREATE OR ALTER VIEW</secondary>
        </indexterm>
        <para>Чтобы создать представление в Firebird, необходимо использовать предложение следующего
            синтаксиса:
            <programlisting>
{RECREATE | CREATE [OR ALTER]} VIEW <replaceable>viewname</replaceable> [<replaceable>&lt;column_list&gt;</replaceable>] 
AS <replaceable>&lt;select_statement&gt;</replaceable>
[WITH CHECK OPTION];

<replaceable>&lt;column_list&gt;</replaceable> ::= (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
                </programlisting>
        </para>
        <para>Здесь <replaceable>viewname</replaceable> – имя представления, которое должно быть
            уникальным в пределах базы данных, далее идет группа не всегда обязательных наименований
            полей, входящих в представление: (<replaceable>colname</replaceable> [,
                <replaceable>colname</replaceable> ...]). Обязательно необходимо определить
            предложение <replaceable>&lt;select_statement&gt;</replaceable>, которое выбирает
            данные, включаемые в представление. Необязательный параметр WITH CHECK OPTION мы обсудим
            ниже – в разделе "Модифицируемые представления".</para>
        <indexterm>
            <primary>VIEW</primary>
            <secondary>ALTER VIEW</secondary>
        </indexterm>
        <para>Для изменения представления используйте оператор ALTER VIEW, его синтаксис представлен
            ниже:
            <programlisting>
ALTER VIEW <replaceable>viewname</replaceable> [<replaceable>&lt;column_list&gt;</replaceable>] 
AS <replaceable>&lt;select_statement&gt;</replaceable>
[WITH CHECK OPTION];

<replaceable>&lt;column_list&gt;</replaceable> ::= (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
                </programlisting>
        </para>
        <para>Оператор <database>ALTER VIEW</database> изменяет определение существующего
            представления, существующие права на представления и зависимости при этом сохраняются.
            Синтаксис оператора <database>ALTER VIEW</database> полностью аналогичен синтаксису
            оператора <database>CREATE VIEW</database>. </para>
        <para>Оператор <database>CREATE OR ALTER VIEW</database> создаёт представление, если оно не
            существует. В противном случае он изменит представление с сохранением существующих
            зависимостей. Этот оператор является наиболее удобным.</para>
        <indexterm>
            <primary>VIEW</primary>
            <secondary>DROP VIEW</secondary>
        </indexterm>
        <para>Оператор <database>DROP VIEW</database> удаляет существующее представление. Если
            представление имеет зависимости, то удаление не будет произведено. Синтаксис оператора
            DROP VIEW представлен ниже.
            <programlisting>
DROP VIEW <replaceable>viewname</replaceable>;
                </programlisting>
        </para>
    </section>
    <section>
        <title>Примеры представлений</title>

        <para>Вот пример простого представления:
            <programlisting language="sql">
CREATE VIEW MyView AS 
SELECT NAME, PRICE
FROM Table_example;
                </programlisting>
        </para>
        <para>В этом примере мы создаем представление на основе запроса к таблице Table_example,
            которую мы рассматривали в главе "Таблицы. Первичные ключи и генераторы". В данном
            случае представление будет состоять из двух полей – NAME и PRICE, которые будут
            выбираться из таблицы Table_example без всяких условий, т. е. число записей в
            представлении MyView будет равно числу записей в Table_example.</para>
        <para>Однако представления не всегда являются такими простыми. Они могут основываться на
            данных из нескольких таблиц и даже на основе других представлений. Также представления
            могут содержать данные, получаемые на основе различных выражений — в том числе на основе
            агрегатных функций.</para>
        <para>Чтобы подробнее рассмотреть использование этого применения представлений, давайте
            создадим две таблицы, связанные отношением один-ко-многим (часто такое отношение
            называют мастер-деталью или master-detail). Вот DDL скрипт для создания этих таблиц:
            <programlisting language="sql">
/* Table: WISEMEN */
CREATE TABLE WISEMEN (
    ID_WISEMAN INTEGER NOT NULL,
    WISEMAN_NAME VARCHAR(80));
    
/* Primary keys definition */
ALTER TABLE WISEMEN ADD CONSTRAINT PK_WISEMEN PRIMARY KEY (ID_WISEMAN);

/* Table: WISEBOOK */
CREATE TABLE WISEBOOK (
    ID_BOOK INTEGER NOT NULL,
    ID_WISEMAN INTEGER,
    BOOK VARCHAR(80));
    
/* Primary keys definition */
ALTER TABLE WISEBOOK ADD CONSTRAINT PK_WISEBOOK PRIMARY KEY (ID_BOOK);

/* Foreign keys definition */
ALTER TABLE WISEBOOK ADD CONSTRAINT FK_WISEBOOK FOREIGN KEY (ID_WISEMAN) REFERENCES WISEMEN (ID_WISEMAN);
                </programlisting>
        </para>
        <para>Итак, мы создали две таблицы — WISEMEN и WISEBOOK, которые связали между собой
            отношением master-detail с помощью ограничения внешнего ключа — FOREIGN KEY.
            Предположим, что эти таблицы будут хранить информацию о великих китайских мудрецах и их
            произведениях. Теперь мы можем создать несколько представлений на основе этих таблиц.
            Например, создадим представление, которое показывает, сколько произведений есть у
            каждого мудреца:
            <programlisting language="sql">
CREATE VIEW WiseBookCount (
  WISEMAN,
  HOW_WISEBOOKS) AS 
SELECT M.WISEMAN_NAME, COUNT(B.BOOK)
FROM WISEMEN M
JOIN WISEBOOK B ON B.ID_WISEMAN = M.ID_WISEMAN
GROUP BY M.WISEMAN_NAME

                </programlisting>
        </para>
        <para>Обратите внимание, что при использовании любых вычисляемых выражений вроде агрегатных
            функций COUNT, SUM, MAX и д.р., необходимо использовать явное именование полей
            представления, т. е. давать имена всем полям, возвращаемым запросом. Как видно из этого
            примера, эти имена не обязательно должны совпадать с именами полей запроса, но их
            количество должно совпадать с количеством полей, возвращаемых запросом. Установление
            того, какое поле, возвращаемое запросом, соответствует какому полю представления,
            осуществляется по порядковому номеру – первое поле запроса отобразится в первое поле
            представления, второе – во второе и т. д.</para>

        <para>Пожалуй, стоит привести еще один пример, иллюстрирующий применение представлений.
            Предположим, нам необходимо вывести список мудрецов, чье имя начинается с буквы "K". В
            этом случае нам поможет представление с условиями:
            <programlisting language="sql">
CREATE VIEW WiseMen2
(WISEMAN) AS
SELECT M.WISEMAN_NAME
FROM WISEMEN M
WHERE M.WISEMAN_NAME STARTING WITH 'K'
                </programlisting>
        </para>

        <para>Таким образом, легко создавать представления, которые исполняют роль постоянно
            обновляемых поставщиков данных, отбирая их из базы данных по определенным
            условиям.</para>
    </section>
    <section>
        <title>Модифицируемые представления</title>

        <para>Выше мы упомянули о том, что есть возможность создавать изменяемые представления
            данных. Это действительно так — существует возможность не только читать данные из
            представления, но и изменять их.</para>

        <para>Есть два способа сделать представление модифицируемым. Представление является
            модифицируемым если выполняются следующие условия: <itemizedlist spacing="compact">
                <listitem>
                    <para>оператор выборки SELECT обращается только к одной таблице или одному
                        изменяемому представлению;</para>
                </listitem>
                <listitem>
                    <para>оператор выборки SELECT не должен обращаться к хранимым процедурам;</para>
                </listitem>
                <listitem>
                    <para>все столбцы базовой таблицы или обновляемого представления, которые не
                        присутствуют в данном представлении, должны удовлетворять одному из
                        следующих условий: <itemizedlist spacing="compact">
                            <listitem>
                                <para>позволять значение NULL</para>
                            </listitem>
                            <listitem>
                                <para>NOT NULL столбцы должны иметь значение по умолчанию</para>
                            </listitem>
                            <listitem>
                                <para>значение NOT NULL столбцов должны быть инициализированы в
                                    триггерах базовых таблиц</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>оператор выборки <database>SELECT</database> не содержит полей
                        определённых через подзапросы или другие выражения;</para>
                </listitem>
                <listitem>
                    <para>оператор выборки <database>SELECT</database> не содержит полей
                        определённых через агрегатные функции (MIN, MAX, AVG, COUNT, LIST),
                        статистические функции (CORR, COVAR_POP, COVAR_SAMP и др.), функции линейной
                        регрессии (REGR_AVGX, REGR_AVGY и др.) и все виды оконных функций;</para>
                </listitem>
                <listitem>
                    <para>оператор выборки <database>SELECT</database> не содержит предложений
                            <database>ORDER BY</database>, <database>GROUP BY</database>,
                            <database>HAVING</database>;</para>
                </listitem>
                <listitem>
                    <para>оператор выборки <database>SELECT</database> не содержит ключевого слова
                        DISTINCT и ограничений количества строк с помощью ROWS, FIRST/SKIP,
                        OFFSET/FETCH.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Список условий довольно внушительный и сильно ограничивает применение таких
            модифицируемых представлений, поэтому они используются относительно редко. </para>
        <para>Чтобы сделать модифицируемым представление, которое нарушает любое из
            вышеперечисленных условий, применяется механизм триггеров. После того как на
            представлении будет определён один или несколько триггеров, то изменения не будут
            автоматически попадать в базовую таблицу, даже если перед этим представление было
            обновляемым. В этом случае ответственность за обновление (удаление или вставку) записей
            базовых таблиц, лежит на программисте, определяющем триггеры. Подробнее о том, что такое
            триггер, рассказывается в главе "Триггеры", а сейчас мы лишь рассмотрим общие принципы
            организации изменения данных во VIEW.</para>
        <para>Для реализации модифицируемого представления с помощью триггеров необходимо создать
            триггеры на события BEFORE DELETE, BEFORE UPDATE и BEFORE INSERT. В этих триггерах
            описать, что должно происходить с данными при удалении, изменении и вставке. После того
            как на представлении будет определён один или несколько триггеров, то изменения не будут
            автоматически попадать в базовую таблицу, даже если перед этим представление было
            обновляемым. В этом случае ответственность за обновление (удаление или вставку) записей
            базовых таблиц, лежит на программисте, определяющем триггеры.</para>
        <para>Таким образом, есть возможность реализовать сложные цепочки обновлений данных в
            представлениях.</para>
        <section>
            <title>WITH CHECK OPTIONS</title>
            <indexterm>
                <primary>VIEW</primary>
                <secondary>WITH CHECK OPTIONS</secondary>
            </indexterm>
            <para>Необязательное предложение <database>WITH CHECK OPTIONS</database> задаёт для
                изменяемого представления требования проверки вновь введённых или модифицируемых
                данных условию, указанному в предложении WHERE оператора выборки SELECT. При попытке
                вставки новой записи или модификации записи проверяется, выполняется ли для этой
                записи условие в предложении WHERE, если условие не выполняется, то
                вставка/модификация не выполняется и будет выдано соответствующее диагностическое
                сообщение. </para>
            <para>Предложение <database>WITH CHECK OPTION</database> может задаваться в операторе
                создания представления только в том случае, если в главном операторе SELECT
                представления указано предложение WHERE. Иначе будет выдано сообщение об ошибке. </para>

            <note>
                <para> Если используется предложение <database>WITH CHECK OPTIONS</database>, то
                    система проверяет входные значение на соответствие условию в предложении WHERE
                    до того как они будут переданы в базовую таблицу. Таким образом, если входные
                    значения не проходят проверку, то предложения DEFAULT или триггеры на базовой
                    таблице, не могут исправить входные значения, поскольку действия никогда не
                    будут выполнены. </para>
                <para>Кроме того, поля представления не указанные в операторе INSERT передаются в
                    базовую таблицу как значения NULL, независимо от их наличия или отсутствия в
                    предложении WHERE. В результате значения по умолчанию, определённые на таких
                    полях базовой таблицы, не будут применены. С другой стороны, триггеры будут
                    вызываться и работать как ожидалось.</para>
                <para>Для представлений у которых отсутствует предложение <database>WITH CHECK
                        OPTIONS</database>, поля, отсутствующие в операторе INSERT, не передаются
                    вовсе, поэтому любые значения по умолчанию будут применены.</para>
            </note>
        </section>
    </section>
    <section>
        <title>Заключение</title>

        <para>Несмотря на кажущуюся простоту создания и использования представлений, они дают
            большие возможности для улучшения организации данных в базе данных и позволяют создавать
            иерархию организации данных. </para>

        <para>Одни разработчики приложений базы данных очень активно используют представления в
            своей работе, другие избегают их применения, мотивируя это стремлением сохранить схему
            своей базы данных максимально простой и эффективной. Как вы будете применять
            представления в своей работе — решать вам. Главное — помнить о существовании такого
            мощного инструмента, как представление, и уметь им пользоваться.</para>
    </section>
</chapter>
